program wrappermaker;

//**********************************************************************************************************************************
//
//  Pascal interface generator for TensorFlow operations
//
//  Copyright: (C) 2020-2023, Zsolt Szakaly
//
//  This source is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
//  published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
//
//  This code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
//  A copy of the GNU General Public License is available on the World Wide Web at <http://www.gnu.org/copyleft/gpl.html>. You can
//  also obtain it by writing to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1335, USA.
//
//  Change log:
//    13/02/2020 Initial version
//    15/02/2020 The integer attributes changed to cint64
//               The generated Add<oper> results changed to string in line with the change in AddOper
//    18/02/2020 Created interfaces use Dynamic Arrays instead of Open Arrays
//               Length of InputLists are automatically generated from the relevant Attribute
//    21/02/2020 TGraph.Add<oper> part is changed significantly to cater for OutputLists
//               Timestamp is added to the generated file
//    23/02/2020 Add<oper> with InputList or OutputList fixed (changed from array of string to TF_StringList)
//    18/01/2023 As the TF 2.11 ops.pbtxt has a different structure than the earlier one used (1.15) some significant changes had to
//                   be made, parsing differently and handling summary and description fields.
//               Some objects are initialized "=nil" in the generated tf_wrapper so to avoid warnings there
//    25/01/2023 Reworked to handle when Inputs and InputLists are mixed or Outputs and OutputLists are mixed
//               Operation name can be now added to Add<oper> methods
//
//**********************************************************************************************************************************
//
//  Description
//
//  This program is really Work-In-Progress.
//  This is reading TensorFlow's ops.pbtxt file (available from github.com/tensorflow) and generates from it Pascal interfaces.
//  There are two ways to use them.
//  The classic TensorFlow approach, whereby a Graph is built. The base object for that is TGraph declared in tf_operations.
//  Its most important function is AddOper, what adds a new node or operation to the TensorFlow Graph. The unit that can be
//  generated by this program declares TGraphExt and declares Add<oper> functions for all the operations declared in ops.pbtxt
//  (currently well over 1000).
//  The other approach does not require building of a Graph, but the operations can be called directly with Tensor inputs (defined
//  using tf_tensors). Just like for the Graph approach, there are General version of ExecOper in tf_operations. The unit generated
//  using this program is built on ExecOper, creating an operation specific Exec<oper> function for all of the function that has no
//  OutputList.
//  For details how to use this program read its help (help1.txt and help2.txt) or run it with option -h.
//
//**********************************************************************************************************************************

// The global uses
uses
  Sysutils;

const
  CRLF=#$0d#$0a;

// The CommandLine parameter handling variables
var
  // RFU CmdLineC:                    integer=        1; // Comments in the generated unit: 0 - none, 1 - defaults, 3 - details
  // RFU CmdLineD:                    integer=        1; // Default handling: 0 - only full, 1 - full and none, 2 - many combinations,
                                                  //   3 - all with different names
  CmdLineE:                    string=         'Exec'; // The prefix to add before the Ops name in the Eager version
  CmdLineG:                    string=         'Add'; // The prefix to add before the Ops name in the Graph version
  CmdLineH:                    integer=        0; // The help level: 0 - no help, 1 - short (default), 2 - full
  CmdLineO:                    string=         'tf_wrapper.pas'; // The output file name
  CmdLineS:                    string=         'ops.pbtxt'; // The source to use
  CmdLineT:                    string=         'tf_wrappertemplate.pas'; // The template to use
  CmdLineU:                    integer=        3; // Unit generated: 1 - Graph only, 2 - Eager only, 3 - Both
  CmdLineV:                    integer=        1; // Verbose: 0 - nothing, 1 - error and summary, 2 - comments
function ProcessCommandLine:boolean;
  var
    i:integer;
    ParameterProcessed:boolean;
    ParameterID:string;
    ParameterValue:string;
    ParameterCode:integer;
    ErrorCode:integer;
  begin
  result:=false;
  for i:=1 to ParamCount do
    begin
    ParameterProcessed:=false;
    // Preparation
    if Pos('=',ParamStr(i))>0 then
      begin
      ParameterID:=Copy(ParamStr(i),1,Pos('=',ParamStr(i))-1);
      ParameterValue:=Copy(ParamStr(i),Pos('=',ParamStr(i))+1);
      ParameterID:=lowercase(ParameterID);
      end
    else
      begin
      ParameterID:=lowercase(ParamStr(i));
      ParameterValue:='';
      end;
    (*
    // Comments
    if (ParameterID='-c') or
       (ParameterID='--comments') then
      begin
      val(ParameterValue,ParameterCode,ErrorCode);
      if (ErrorCode<>0) or (ParameterCode<0) or (ParameterCode>2) then
        begin
        writeln('Invalid value for '+ParameterID);
        exit;
        end;
      CmdLineC:=ParameterCode;
      ParameterProcessed:=true;
      end;
    *)
    (*
    // Default handling
    if (ParameterID='-d') or
       (ParameterID='--default-handling') then
      begin
      val(ParameterValue,ParameterCode,ErrorCode);
      if (ErrorCode<>0) or (ParameterCode<0) or (ParameterCode>3) then
        begin
        writeln('Invalid value for '+ParameterID);
        exit;
        end;
      CmdLineD:=ParameterCode;
      ParameterProcessed:=true;
      end;
    *)
    // EagerPrefix
    if (ParameterID='-e') or
       (ParameterID='--eager-prefix') then
      begin
      CmdLineE:=ParameterValue;
      if Pos('''',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'''' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineE:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      if Pos('"',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'"' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineE:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      ParameterProcessed:=true;
      end;
    // GraphPrefix
    if (ParameterID='-g') or
       (ParameterID='--graph-prefix') then
      begin
      CmdLineG:=ParameterValue;
      if Pos('''',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'''' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineG:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      if Pos('"',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'"' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineG:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      ParameterProcessed:=true;
      end;
    // Help
    if (ParameterID='?') or
       (ParameterID='-h') or
       (ParameterID='--help') then
      begin
      if ParameterValue='' then
        ParameterValue:='1'; // The default help value for unspecified help
      val(ParameterValue,ParameterCode,ErrorCode);
      if (ErrorCode<>0) or (ParameterCode<1) or (ParameterCode>2) then
        begin
        writeln('Invalid value for '+ParameterID);
        exit;
        end;
      CmdLineH:=ParameterCode;
      ParameterProcessed:=true;
      end;
    // OutputFile
    if (ParameterID='-o') or
       (ParameterID='--output-file') then
      begin
      CmdLineO:=ParameterValue;
      if Pos('''',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'''' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineO:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      if Pos('"',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'"' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineO:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      ParameterProcessed:=true;
      end;
    // Source
    if (ParameterID='-s') or
       (ParameterID='--source') then
      begin
      CmdLineS:=ParameterValue;
      if Pos('''',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'''' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineS:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      if Pos('"',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'"' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineS:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      ParameterProcessed:=true;
      end;
    // Template
    if (ParameterID='-t') or
       (ParameterID='--template') then
      begin
      CmdLineT:=ParameterValue;
      if Pos('''',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'''' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineT:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      if Pos('"',ParameterValue)=1 then
        begin
        if ParameterValue[Length(ParameterValue)]<>'"' then
          begin
          writeln('Misformatted parameter for '+ParameterID);
          exit;
          end;
        CmdLineT:=copy(ParameterValue,2,Length(ParameterValue)-2);
        end;
      ParameterProcessed:=true;
      end;
    // Unit generated
    if (ParameterID='-u') or
       (ParameterID='--unit') then
      begin
      val(ParameterValue,ParameterCode,ErrorCode);
      if (ErrorCode<>0) or (ParameterCode<1) or (ParameterCode>3) then
        begin
        writeln('Invalid value for '+ParameterID);
        exit;
        end;
      CmdLineU:=ParameterCode;
      ParameterProcessed:=true;
      end;
    // Verbose
    if (ParameterID='-v') or
       (ParameterID='--verbose') then
      begin
      val(ParameterValue,ParameterCode,ErrorCode);
      if (ErrorCode<>0) or (ParameterCode<1) or (ParameterCode>3) then
        begin
        writeln('Invalid value for '+ParameterID);
        exit;
        end;
      CmdLineV:=ParameterCode;
      ParameterProcessed:=true;
      end;
    if not ParameterProcessed then
      begin
      writeln('Unknown parameter: '+ParamStr(i));
      writeln('Use -H for "Help"');
      exit;
      end;
    end;
  result:=true;
  end;

// The help files and their printing
const
  Help1={$i help1.txt};
  Help2={$i help2.txt};
procedure PrintHelp;
  begin
  case CmdLineH of
    1:writeln(Help1);
    2:writeln(Help2);
    end;
  end;

// The load or later the download of the TensorFlow definition file
var OpsPbtxt:                  string;
function LoadOpsPbtxt:boolean;
  var
    OpsPbtxtFile:system.text;
    OneLine:string;
  begin
  result:=false;
  // Read the file into one long string
  AssignFile(OpsPbtxtFile,CmdLineS);
  try
    Reset(OpsPbtxtFile);
  except
    if CmdLineV>=1 then
      writeln('Cannot read Source file '+CmdLineS);
    exit;
    end;
  OpsPbtxt:='';
  while not eof(OpsPbtxtFile) do
    begin
    readln(OpsPbtxtFile,OneLine);
    OpsPbtxt:=OpsPbtxt+OneLine+' '; // to make sure that when two lines are cooncatanated a space is added
    end;
  CloseFile(OpsPbtxtFile);
  result:=true;
  end;
function GetOpsPbtxt:boolean;
  begin
  // Placeholder to potentially Download from GitHub the latest definition file, if CmdLineS is a site, not a file
  // Currently only file load is supported
  { TODO : Add Download option }
  result:=LoadOpsPbtxt;
  end;
function RemoveExtraSpaces:boolean;
  var
    TempStr:                   string;
    Counter:                   Int32;
    I:                         Int32;
    LastSpace:                 boolean;
  begin
  Counter:=0;
  TempStr:=OpsPbtxt; // Manage the output in the memory area of the original OpsPbtxt, and so no frequent memory allocation is needed
  LastSpace:=true;
  for I:=1 to Length(TempStr) do
    if (TempStr[I]<>' ') or (not LastSpace) then
      begin
      inc(Counter);
      OpsPbtxt[Counter]:=TempStr[I];
      LastSpace:=TempStr[I]=' ';
      end;
  SetLength(OpsPbtxt,Counter);
  result:=true;
  end;

// The load of the template for the output
var TemplateStr:                  string;
function LoadTemplate:boolean;
  var
    TemplateFile:system.text;
    OneLine:string;
  begin
  result:=false;
  // Read the file into one long string
  AssignFile(TemplateFile,CmdLineT);
  try
    Reset(TemplateFile);
  except
    if CmdLineV>=1 then
      writeln('Cannot read Template file '+CmdLineT);
    exit;
    end;
  TemplateStr:='';
  while not eof(TemplateFile) do
    begin
    readln(TemplateFile,OneLine);
    TemplateStr:=TemplateStr+OneLine+CRLF;
    end;
  CloseFile(TemplateFile);
  result:=true;
  end;
function SaveUnit:boolean;
  var
    UnitFile:file;
  begin
  result:=false;
  AssignFile(UnitFile,CmdLineO);
  try
    Rewrite(UnitFile,1);
  except
    exit;
    end;
  BlockWrite(UnitFile,TemplateStr[1],Length(TemplateStr));
  CloseFile(UnitFile);
  result:=true;
end;

// A parser to cut a string into three
procedure ParseStringIntoThree(const AInput:string; var ALabel:string; var AContent:string; var ARest:string);
  var
    SplitPos:                  Int32;
    ParanthesisCount:          Int32;
  begin
  SplitPos:=Pos(' ',AInput);
  ALabel:=Copy(AInput,1,SplitPos-1);
  ARest:=Copy(AInput,SplitPos+1);

  if ARest[1]='{' then
    begin
    SplitPos:=1;
    ParanthesisCount:=1;
    while ParanthesisCount<>0 do
      begin
      inc(SplitPos);
      if ARest[SplitPos]='{' then
        inc(ParanthesisCount)
      else
        if ARest[SplitPos]='}' then
          dec(ParanthesisCount);
      end;
    AContent:=Copy(ARest,3,SplitPos-4);
    ARest:=Copy(ARest,SplitPos+2);
    end else
  if ARest[1]='"' then
    begin
    SplitPos := 2;
    while (ARest[SplitPos] <> '"') or (ARest[SplitPos - 1] = '\') do
      inc(SplitPos);
    AContent := Copy(ARest, 2, SplitPos - 2);
    ARest:=Copy(ARest,SplitPos+2);
    end else
    begin
    SplitPos:=Pos(' ',ARest);
    if SplitPos=0 then
      begin
      AContent:=ARest;
      ARest:='';
      end
    else
      begin
      AContent:=Copy(ARest,1,SplitPos-1);
      ARest:=Copy(ARest,SplitPos+1);
      end;
    end;
  end;

// The actual processing of the file
type
  TAttributeInputPair=record
    Attribute:              string;
    Input:                  string;
    end;
function InAttributeInputPair(const AArray:array of TAttributeInputPair; const AAttribute:string):integer;
  var i:integer;
  begin
  result:=-1;
  i:=0;
  while (i<Length(AArray)) and // has not reached the end
        (AArray[i].Attribute<>AAttribute) do
    inc(i);
  if i<Length(AArray) then
    result:=i;
  end;
var
  InputsAndInputLists:       array of string = nil;
  InputOrInputLists:         array of boolean = nil; // naming not a mistake Inputs And InputLists vs Input Or InputList in an array
  OutputsAndOutputLists:     array of string = nil;
  OutputOrOutputLists:       array of boolean = nil;
  AttributeNames:            array of string = nil;
  AttributeTypes:            array of string = nil;
  AttributeDefaults:         array of boolean = nil;
  InputTypes:                array of TAttributeInputPair = nil;
procedure ProcessInputArg(var AInput:string);
  var
    LabelString:               string='';
    ContentString:             string='';
    InputName:                 string='';
    InputMultiple:             boolean=false;
    SourceOfType:              integer = -1;
  begin
  while AInput<>'' do
    begin
    ParseStringIntoThree(AInput,LabelString,ContentString,AInput);
    if LabelString='description:' then
      begin
      end else
    if LabelString='is_ref:' then
      begin
      // no need to processed { TODO : Is it surely not needed }
      end else
    if LabelString='name:' then
      begin
      if InputName='' then
        InputName:=ContentString
      else
        begin
        if CmdLineV>=1 then
          writeln('Input has duplicate Name value!');
        end;
      end else
    if LabelString='number_attr:' then
      begin
      InputMultiple:=true;
      end else
    if LabelString='type:' then
      begin
      end else
    if LabelString='type_attr:' then
      begin
      if InAttributeInputPair(InputTypes,ContentString) = -1 then
        begin // This input (first occurence) will be used for this attribute
        SetLength(InputTypes,Length(InputTypes) + 1);
        SourceOfType := High(InputTypes);
        with InputTypes[SourceOfType] do
          Attribute:=ContentString;
        end;
      end else
    if LabelString='type_list_attr:' then
      begin
      InputMultiple:=true;
      end else
    if CmdLineV>=1 then
      writeln('Unknown Input component found "'+LabelString+'" with content "'+ContentString+'".');
    end;
  if InputName<>'' then
    begin
    // new combined version 25/01/2023
    SetLength(InputsAndInputLists,Length(InputsAndInputLists) + 1);
    InputsAndInputLists[High(InputsAndInputLists)] := InputName;
    SetLength(InputOrInputLists,Length(InputOrInputLists) + 1);
    InputOrInputLists[High(InputOrInputLists)] := not InputMultiple;
    if SourceOfType >= 0 then
      begin
      if InputMultiple then
        InputTypes[SourceOfType].Input := 'IL_' + InputName + '[0]'
      else
        InputTypes[SourceOfType].Input := 'I_' + InputName
      end;
    end
  else
    begin
    if CmdLineV>=1 then
      writeln('Input has no Name');
    end;
  end;
procedure ProcessOutputArg(var AOutput:string);
  var
    LabelString:               string='';
    ContentString:             string='';
    OutputName:                string='';
    OutputMultiple:            boolean=false;
  begin
  while AOutput<>'' do
    begin
    ParseStringIntoThree(AOutput,LabelString,ContentString,AOutput);
    if LabelString='experimental_full_type' then // TODO What is it for?
      begin
      end else
    if LabelString='is_ref:' then
      begin
      end else
    if LabelString='name:' then
      begin
      if OutputName='' then
        OutputName:=ContentString
      else
        if CmdLineV>=1 then
          writeln('Output has duplicate Name value!');
      end else
    if LabelString='number_attr:' then
      begin
      OutputMultiple:=true;
      end else
    if LabelString='summary:' then
      begin
      end else
    if LabelString='type:' then
      begin
      end else
    if LabelString='type_attr:' then
      begin
      end else
    if LabelString='type_list_attr:' then
      begin
      OutputMultiple:=true;
      end else
    if CmdLineV>=1 then
      writeln('Unknown Output component found "'+LabelString+'" with content "'+ContentString+'".');
    end;
  if OutputName<>'' then
    begin
    // new combined version 25/01/2023
    SetLength(OutputsAndOutputLists,Length(OutputsAndOutputLists) + 1);
    OutputsAndOutputLists[High(OutputsAndOutputLists)] := OutputName;
    SetLength(OutputOrOutputLists,Length(OutputOrOutputLists) + 1);
    OutputOrOutputLists[High(OutputOrOutputLists)] := not OutputMultiple;
    end
  else
    if CmdLineV>=1 then
      writeln('Output has no Name');
  end;
procedure ProcessAttr(var AAttr:string);
  var
    LabelString:               string='';
    ContentString:             string='';
    AttrName:                  string='';
    AttrType:                  string='';
    AttrDefault:               boolean=false;
  begin
  while AAttr<>'' do
    begin
    ParseStringIntoThree(AAttr,LabelString,ContentString,AAttr);
    if LabelString='allowed_values' then
      begin
      // no need to do anything, it is checked at run-time
      end else
    if LabelString='default_value' then
      begin
      if not AttrDefault then
        begin
        AttrDefault:=true;
        end
      else
        begin
        writeln('Attr has duplicate Default value!');
        end;
      end else
    if LabelString='description:' then
      begin
      end else
    if LabelString='has_minimum:' then
      begin
      // no need to do anything, it is checked at run-time
      end else
    if LabelString='minimum:' then
      begin
      // no need to do anything, it is checked at run-time
      end else
    if LabelString='name:' then
      begin
      if AttrName='' then
        AttrName:=ContentString
      else
        writeln('Attr has duplicate Name value!');
      end else
    if LabelString='type:' then
      begin
      if AttrType='' then
        AttrType:=ContentString
      else
        writeln('Attr has duplicate Type value!');
      end else
    if CmdLineV>=1 then
      writeln('Unknown Attr component found "'+LabelString+'" with content "'+ContentString+'".');
    end;
  if (AttrName<>'') and (AttrType<>'') then
    begin
    SetLength(AttributeNames,Length(AttributeNames)+1);
    AttributeNames[High(AttributeNames)]:=AttrName;
    SetLength(AttributeTypes,Length(AttributeTypes)+1);
    AttributeTypes[High(AttributeTypes)]:=AttrType;
    SetLength(AttributeDefaults,Length(AttributeDefaults)+1);
    AttributeDefaults[High(AttributeDefaults)]:=AttrDefault;
    end
  else
    writeln('Attr  has no Name or Type');
  end;
procedure ProcessOps(const AOpName:string; var AOp:string);
  var
    LabelString:               string=         '';
    ContentString:             string=         '';
  begin
  if CmdLineV>=2 then
    write('Processing Ops: '+AOpName+'                                            '+CRLF);
  SetLength(InputsAndInputLists, 0);
  SetLength(InputOrInputLists, 0);
  SetLength(OutputsAndOutputLists, 0);
  SetLength(OutputOrOutputLists, 0);
  SetLength(AttributeNames,0);
  SetLength(AttributeTypes,0);
  SetLength(AttributeDefaults,0);
  SetLength(InputTypes,0);
  while AOp<>'' do
    begin
    ParseStringIntoThree(AOp,LabelString,ContentString,AOp);
    if LabelString='allows_uninitialized:' then
      begin
      end else
    if LabelString='allows_uninitialized_input:' then
      begin
      end else
    if LabelString='description:' then
      begin
      end else
    if LabelString='input_arg' then
      begin
      ProcessInputArg(ContentString);
      end else
    if LabelString='output_arg' then
      begin
      ProcessOutputArg(ContentString);
      end else
    if LabelString='attr' then
      begin
      ProcessAttr(ContentString);
      end else
    if LabelString='is_aggregate:' then
      begin
      end else
    if LabelString='is_commutative:' then
      begin
      end else
    if LabelString='is_distributed_communication:' then
      begin
      end else
    if LabelString='is_stateful:' then
      begin
      end else
    if LabelString='summary:' then
      begin
      end else
    if LabelString='deprecation' then
      begin
      end else
    if CmdLineV>=1 then
      writeln('Unknown component found "'+LabelString+'" with content "'+ContentString+'" in '+AOpName);
    end;
  end;
var
  GraphInterface:              string=         '';
  GraphImplementation:         string=         '';
  EagerInterface:              string=         '';
  EagerImplementation:         string=         '';
  GraphCount:                  integer=        0;
  EagerCount:                  integer=        0;
procedure GenerateGraph(const AOpName:string);
  var
    OneCall:                   string=         '';
    OneExecution:              string=         '';
    PascalType:                string;
    i:                         integer;
    InputMode:                 integer = 0;
    OutputMode:                integer = 0;
  begin
  // first make the call
  OneCall:=CmdLineG+AOpName+'(';
  for i := 0 to High(InputsAndInputLists) do
    if InputOrInputLists[i] then
      OneCall := OneCall + 'const I_' + InputsAndInputLists[i] + ':string; ' // Something is needed, because of input names like "var". "I" is not sufficient, because of "f" giving "If".
    else
      OneCall := OneCall + 'const IL_' + InputsAndInputLists[i] + ':TF_StringList; ';
  for i := 0 to High(OutputsAndOutputLists) do
    if OutputOrOutputLists[i] then
      OneCall := OneCall + 'const O_' + OutputsAndOutputLists[i] + ':string; '
    else
      OneCall := OneCall + 'const OL_' + OutputsAndOutputLists[i] + ':TF_StringList; ';
  for i:=0 to High(AttributeNames) do
    begin
    OneCall:=OneCall+'const A_'+AttributeNames[i]+':';
    PascalType:='';
    if AttributeTypes[i]='bool' then             PascalType:='boolean';
    if AttributeTypes[i]='float' then            PascalType:='real';
    if AttributeTypes[i]='func' then             PascalType:='TF_Function';
    if AttributeTypes[i]='int' then              PascalType:='cint64';
    if AttributeTypes[i]='list(float)' then      PascalType:='TF_FloatList';
    if AttributeTypes[i]='list(func)' then       PascalType:='TF_FuncnameList';
    if AttributeTypes[i]='list(int)' then        PascalType:='TF_IntList';
    if AttributeTypes[i]='list(shape)' then      PascalType:='TF_ShapeList';
    if AttributeTypes[i]='list(string)' then     PascalType:='TF_StringList';
    if AttributeTypes[i]='list(type)' then       PascalType:='TF_TypeList';
    if AttributeTypes[i]='shape' then            PascalType:='TF_Shape';
    if AttributeTypes[i]='string' then           PascalType:='string';
    if AttributeTypes[i]='tensor' then           PascalType:='TF_TensorPtr';
    if AttributeTypes[i]='type' then             PascalType:='TF_DataType';
    if PascalType='' then
      begin
      if CmdLineV>=1 then
        writeln('Unknown type: '+AttributeTypes[i]);
      PascalType:='boolean';
      end;
    OneCall:=OneCall+PascalType+'; ';
    end;
  OneCall:=OneCall + 'const AOperationName:string=''''):string;'+CRLF;
  GraphInterface:=GraphInterface+'    function '+OneCall;

  // and then the execution
  // decide which input mechanism to call 0: no input, no inputlist, 1: only input(s), 2: inputlist(s) (with or without input(s))
  for i := 0 to High(InputOrInputLists) do
    begin
    InputMode := 1; // at least
    if not InputOrInputLists[i] then
      begin
      InputMode := 2;
      break;
      end;
    end;
  // decide which output mechanism to call 0: no output, no outputlist, 1: only output(s), 2: only one outputlist without output(s),
  //                                       3: more
  for i := 0 to High(OutputOrOutputLists) do
    begin
    if OutputOrOutputLists[i] then // this one is a normal output
      begin
      if OutputMode = 2 then // was earlier an outputlist, so it is the most complex case
        begin
        OutputMode := 3;
        break;
        end
      else // this is the first one, or only single outputs existed before (i.e. OutputMode = 0 or 1)
        begin
        OutputMode := 1;
        end;
      end
    else // this is an outputlist
      begin
      If OutputMode = 0 then // this is the first item
        begin
        OutputMode := 2;
        end
      else // there was either an output or an outputlist before, so it is the most complex case
        begin
        OutputMode := 3;
        break;
        end;
      end;
    end;
  // now build the execution as needed
  // for complex outputs even a variable is needed
  if OutputMode = 3 then
    begin // a variable is declared and filled up
    OneExecution:='  var'+CRLF;
    OneExecution:=OneExecution+'    OutputNames : TF_StringList = nil;'+CRLF;
    OneExecution:=OneExecution+'    Index       : integer;'+CRLF;
    OneExecution:=OneExecution+'    Counter     : integer = 0;'+CRLF;
    OneExecution:=OneExecution+'  begin'+CRLF;
    OneExecution:=OneExecution+'  SetLength(OutputNames,';
    for i := 0 to High(OutputsAndOutputLists) do
      begin
      if OutputOrOutputLists[i] then
        OneExecution := OneExecution + '1 '
      else
        OneExecution := OneExecution + 'length(OL_' + OutputsAndOutputLists[i] + ')';
      if i < High(OutputsAndOutputLists) then
        OneExecution:=OneExecution+' + ';
      end;
    OneExecution := OneExecution + ');' + CRLF;
    for i := 0 to High(OutputsAndOutputLists) do
      begin
      if OutputOrOutputLists[i] then
        begin
        OneExecution:=OneExecution+'  Outputnames[Counter] := O_' + OutputsAndOutputLists[i] + ';' + CRLF;
        if i < High(OutputsAndOutputLists) then
          OneExecution:=OneExecution+'  inc(Counter);' + CRLF;
        end
      else
        begin
        OneExecution:=OneExecution+'  for Index := 0 to High(OL_'+OutputsAndOutputLists[i]+') do' + CRLF;
        OneExecution:=OneExecution+'    OutputNames[Counter+Index] := OL_'+OutputsAndOutputLists[i] + '[Index];' + CRLF;
        if i < High(OutputsAndOutputLists) then
          OneExecution:=OneExecution+'  Counter := Counter + length(OL_'+OutputsAndOutputLists[i] + ');' + CRLF;
        end;
      end;
    end
  else // otherwise can start immediately
    OneExecution:='  begin' + CRLF;
  // the type
  OneExecution := OneExecution+'  result := AddOper('''+AOpName+''', ';
  // the input(s)
  case InputMode of
    0: begin // no need to add anything
       end;
    1: begin
       OneExecution := OneExecution + '[';
       for i := 0 to High(InputsAndInputLists) do
         begin
         OneExecution := OneExecution + 'I_' + InputsAndInputLists[i];
         if i < High(InputsAndInputLists) then
           OneExecution := OneExecution + ', ';
         end;
       OneExecution := OneExecution + '], ';
       end;
    2: begin
       OneExecution := OneExecution + '[';
       for i := 0 to High(InputsAndInputLists) do
         begin
         if InputOrInputLists[i] then
           OneExecution := OneExecution + '[I_' + InputsAndInputLists[i] + ']'
         else
           OneExecution := OneExecution + 'IL_' + InputsAndInputLists[i];
         if i < High(InputsAndInputLists) then
           OneExecution := OneExecution + ', ';
         end;
       OneExecution := OneExecution + '], [';
       for i := 0 to High(InputsAndInputLists) do
         begin
         if InputOrInputLists[i] then
           OneExecution := OneExecution + 'true'
         else
           OneExecution := OneExecution + 'false';
         if i < High(InputsAndInputLists) then
           OneExecution := OneExecution + ', ';
         end;
       OneExecution := OneExecution + '], ';
       end;
    end;
  // the outputs
  case OutputMode of
    0: begin
       OneExecution := OneExecution + '[], '; // AddOper has no version with no output
       end;
    1: begin
       OneExecution := OneExecution + '[';
       for i := 0 to High(OutputsAndOutputLists) do
         begin
         OneExecution := OneExecution + 'O_'+OutputsAndOutputLists[i];
         if i < High(OutputsAndOutputLists) then
           OneExecution := OneExecution + ', ';
         end;
       OneExecution := OneExecution + '], ';
       end;
    2: begin
       OneExecution := OneExecution + 'OL_'+OutputsAndOutputLists[0] + ', ' // use the only OL
       end;
    3: begin
       OneExecution := OneExecution + 'OutputNames, '; // use the combined OutputNames
       end;
    end;
  // the attributes
  OneExecution := OneExecution + '[';
  for i := 0 to High(AttributeNames) do
    begin
    OneExecution := OneExecution + '''' + AttributeNames[i] + '''';
    if i < High(AttributeNames) then
      OneExecution := OneExecution + ', ';
    end;
  OneExecution := OneExecution + '], [';
  for i:=0 to High(AttributeTypes) do
    begin
    OneExecution := OneExecution + '''' + AttributeTypes[i] + '''';
    if i < High(AttributeTypes) then
      OneExecution := OneExecution + ', ';
    end;
  OneExecution := OneExecution +'], [';
  for i:=0 to High(AttributeNames) do
    begin
    OneExecution := OneExecution + '@A_' + AttributeNames[i];
    if i < High(AttributeNames) then
      OneExecution := OneExecution + ', ';
    end;
  OneExecution := OneExecution + '], AOperationName);' + CRLF + '  end;' + CRLF;
  GraphImplementation:=GraphImplementation + 'function TGraphExt.' + OneCall + OneExecution;

  inc(GraphCount);
  end;
procedure GenerateEager(const AOpName:string);
  var
    OneCall:                   string=         '';
    OneExecution:              string=         '';
    PascalType:                string;
    i:                         integer;
    InputMode:                 integer = 0;
    OutputCount:               integer = 0;
  begin
  // In eager mode only those operations are made that has no OutputList. Multiple individual outputs are allowed though.
  // decide which output mechanism to call 0: no output, no outputlist, 1: only one output, 2: more than one output and/or at least one outputlist
  for i := 0 to High(OutputOrOutputLists) do
    begin
    if OutputOrOutputLists[i] then // this one is a normal output
      inc(OutputCount)
    else // this is an outputlist, so no Exec<oper> is generated
      exit;
    end;
  // decide which input mechanism to call 0: no input, no inputlist, 1: only one input, 2: only inputs, 3: inputlist(s) with or without input(s)
  for i := 0 to High(InputOrInputLists) do
    begin
    if InputOrInputLists[i] then
      begin
      if InputMode < 2 then
        inc(InputMode);
      end
    else
      begin
      InputMode := 3;
      break;
      end;
    end;
  // here make the call and teh execution parallel in order to do the PascalType allocation only once
  // first the general part
  if OutputCount = 0 then
    begin
    OneCall:='procedure ' + CmdLineE + AOpName + '(';
    OneExecution := '  ';
    end
  else
    begin
    OneCall:='function ' + CmdLineE + AOpName + '(';
    OneExecution:='  result := ';
    end;
  OneExecution := OneExecution + 'ExecOper('''+AOpName+'''';
  case OutputCount of
    0: OneExecution := OneExecution + ', 0'; // there is no ExecOper with no output, hence a multiple output is called with 0
    1: begin end; // there isan ExecOper for one output
    else  OneExecution := OneExecution + ', ' + IntToStr(OutputCount);
    end;
  // second the inputs
  for i:=0 to High(InputsAndInputLists) do
    begin
    if InputOrInputLists[i] then
      OneCall := OneCall + 'const I_' + InputsAndInputLists[i] + ':TF_TensorPtr; ' // Something is needed, because of input names like "var". "I" is not sufficient, because of "f" giving "If".
    else
      OneCall := OneCall + 'const IL_' + InputsAndInputLists[i] + ':TF_TensorPtrs; ';
    end;
  case InputMode of
    0: begin // no need to add anything
       end;
    1: begin
       OneExecution := OneExecution + ', I_' + InputsAndInputLists[0];
       end;
    2: begin
       OneExecution := OneExecution + ', [';
       for i := 0 to High(InputsAndInputLists) do
         begin
         OneExecution := OneExecution + 'I_' + InputsAndInputLists[i];
         if i < High(InputsAndInputLists) then
           OneExecution := OneExecution + ', ';
         end;
       OneExecution := OneExecution + ']';
       end;
    3: begin
       OneExecution := OneExecution + ', [';
       for i := 0 to High(InputsAndInputLists) do
         begin
         if InputOrInputLists[i] then
           OneExecution := OneExecution + '[I_' + InputsAndInputLists[i] + ']'
         else
           OneExecution := OneExecution + 'IL_' + InputsAndInputLists[i];
         if i < High(InputsAndInputLists) then
           OneExecution := OneExecution + ', ';
         end;
       OneExecution := OneExecution + '], [';
       for i := 0 to High(InputsAndInputLists) do
         begin
         if InputOrInputLists[i] then
           OneExecution := OneExecution + 'true'
         else
           OneExecution := OneExecution + 'false';
         if i < High(InputsAndInputLists) then
           OneExecution := OneExecution + ', ';
         end;
       OneExecution := OneExecution + ']';
       end;
    end;
  // third the attributes
  OneExecution := OneExecution+', [';
  for i:=0 to High(AttributeNames) do
    begin
    PascalType:='';
    if AttributeTypes[i]='bool' then             PascalType:='boolean';
    if AttributeTypes[i]='float' then            PascalType:='real';
    if AttributeTypes[i]='func' then             PascalType:='TF_Function';
    if AttributeTypes[i]='int' then              PascalType:='cint64';
    if AttributeTypes[i]='list(float)' then      PascalType:='TF_FloatList';
    if AttributeTypes[i]='list(func)' then       PascalType:='TF_FuncnameList';
    if AttributeTypes[i]='list(int)' then        PascalType:='TF_IntList';
    if AttributeTypes[i]='list(shape)' then      PascalType:='TF_ShapeList';
    if AttributeTypes[i]='list(string)' then     PascalType:='TF_StringList';
    if AttributeTypes[i]='list(type)' then       PascalType:='TF_TypeList';
    if AttributeTypes[i]='shape' then            PascalType:='TF_Shape';
    if AttributeTypes[i]='string' then           PascalType:='string';
    if AttributeTypes[i]='tensor' then           PascalType:='TF_TensorPtr';
    if AttributeTypes[i]='type' then             PascalType:='TF_DataType';
    if PascalType='' then
      begin
      if CmdLineV>=1 then
        writeln('Unknown type: '+AttributeTypes[i]);
      PascalType:='boolean';
      end;
    if (InAttributeInputPair(InputTypes,AttributeNames[i]) = -1) then
      OneCall:=OneCall + 'const A_' + AttributeNames[i] + ':' + PascalType + '; '; // only add to the call, if cannot be calculated
    OneExecution := OneExecution + '''' + AttributeNames[i] + ''', ';
    end;
  if OneCall[Length(OneCall)]=' ' then // we cannot be sure that which is the last (because of calculated attributes) and hence only at the end we can know
    SetLength(OneCall,Length(OneCall)-2);
  if OneExecution[Length(OneExecution)]=' ' then
    SetLength(OneExecution,Length(OneExecution)-2);
  OneExecution:=OneExecution+'], [';
  for i := 0 to High(AttributeTypes) do
    OneExecution := OneExecution + '''' + AttributeTypes[i] + ''', ';
  if OneExecution[Length(OneExecution)]=' ' then
    SetLength(OneExecution,Length(OneExecution)-2);
  OneExecution := OneExecution + '], [';
  for i := 0 to High(AttributeNames) do
    begin
    if (InAttributeInputPair(InputTypes,AttributeNames[i]) = -1) then
      OneExecution := OneExecution + '@A_' + AttributeNames[i] + ', '
    else
      OneExecution := OneExecution + '@F_' + AttributeNames[i] + ', ';
    end;
  if OneExecution[Length(OneExecution)]=' ' then
    SetLength(OneExecution,Length(OneExecution) - 2);
  OneExecution:=OneExecution+']';
  // fourth the Delete parameters
  for i:=0 to High(InputsAndInputLists) do
    begin
    if i = 0 then
      begin
      OneCall := OneCall + '; '; // after the attributes the ; is removed as it is not sure that there is any D_
      OneExecution := OneExecution + ', [';
      end;
    if InputOrInputLists[i] then
      begin
      OneCall := OneCall + 'const D_' + InputsAndInputLists[i] + ':boolean = false';
      OneExecution := OneExecution + 'D_'+InputsAndInputLists[i];
      end
    else
      begin
      OneCall := OneCall + 'const DL_' + InputsAndInputLists[i] + ':boolean = false';
      OneExecution := OneExecution + 'DL_'+InputsAndInputLists[i];
      end;
    if i < High(InputsAndInputLists) then
      begin
      OneCall := OneCall + '; ';
      OneExecution := OneExecution + ', ';
      end
    else
      OneExecution := OneExecution + ']';
    end;
  case OutputCount of
    0: OneCall := OneCall+');'+CRLF;
    1: OneCall := OneCall+'):TF_TensorPtr;'+CRLF;
    else OneCall := OneCall+'):TF_TensorPtrs;'+CRLF;
    end;
  OneExecution := OneExecution + ');' + CRLF;

  // completion
  // interface is only the call
  EagerInterface := EagerInterface + OneCall;
  // implementation is more complicated, variables might be declared
  EagerImplementation := EagerImplementation + OneCall;
  if Length(InputTypes) > 0 then
    EagerImplementation := EagerImplementation + '  var'+CRLF;
  for i := 0 to High(InputTypes) do
    EagerImplementation := EagerImplementation+'    F_'+InputTypes[i].Attribute + ': TF_DataType;' + CRLF;
  EagerImplementation := EagerImplementation + '  begin' + CRLF;
  for i := 0 to High(InputTypes) do
    EagerImplementation := EagerImplementation + '  F_' + InputTypes[i].Attribute + ' := TF_TensorType(' + InputTypes[i].Input + ');' + CRLF;
  EagerImplementation := EagerImplementation + OneExecution;
  EagerImplementation := EagerImplementation + '  end;' + CRLF;

  inc(EagerCount);
  end;
procedure ProcessOp(var AOp:string);
  var
    LabelString:               string=         '';
    ContentString:             string=         '';
  begin
  ParseStringIntoThree(AOp,LabelString,ContentString,AOp);
  if LabelString='name:' then
    begin
    ProcessOps(ContentString,AOp);
    if (CmdLineU=1) or (CmdLineU=3) then
      GenerateGraph(ContentString);
    if (CmdLineU=2) or (CmdLineU=3) then
      GenerateEager(ContentString);
    end
  else
    begin
    if CmdLineV>=1 then
      writeln('"name:" expected "'+LabelString+'" received');
    end;
  end;
const
  TDB='//  #TemplateDescriptionBegin';
  TDE='//  #TemplateDescriptionEnd';
  GDB='//  #GraphDescriptionBegin';
  GDE='//  #GraphDescriptionEnd';
  EDB='//  #EagerDescriptionBegin';
  EDE='//  #EagerDescriptionEnd';
  GNB='//  #GraphInterfaceBegin';
  GNF='//  #GraphInterfaceFill';
  GNE='//  #GraphInterfaceEnd';
  ENB='//  #EagerInterfaceBegin';
  ENF='//  #EagerInterfaceFill';
  ENE='//  #EagerInterfaceEnd';
  GMB='//  #GraphImplementationBegin';
  GMF='//  #GraphImplementationFill';
  GME='//  #GraphImplementationEnd';
  EMB='//  #EagerImplementationBegin';
  EMF='//  #EagerImplementationFill';
  EME='//  #EagerImplementationEnd';
  TS ='//  #TimeStamp';
function ProcessFile:boolean;
  var
    LabelString:               string=         '';
    ContentString:             string=         '';
    OperationCount:            integer=        0;
  begin
  if CmdLineV>=1 then
    begin
    writeln('Wrapper Maker by Zsolt Szakaly, 2020-2023');
    end;
  if CmdLineV>=2 then
    begin
    writeln('Processing input file. Actual parameters:');
    writeln('TensorFlow definition file (-S): ',CmdLineS);
    writeln('Template file              (-T): ',CmdLineT);
    writeln('Output (unit) file         (-O): ',CmdLineO);
    write  ('Wrapper unit generated for (-U): ');
    case CmdLineU of
      1:writeln('1 - Only TGraphExt.',CmdLineG,'<oper>');
      2:writeln('2 - Only Eager ',CmdLineE,'<oper>');
      3:writeln('3 - Both TGraphExt.',CmdLineG,'<oper> and Eager ',CmdLineE,'<oper>');
      end;
    if (CmdLineU=1) or (CmdLineU=3) then
      writeln('Prefix for TGraphExt       (-G): ',CmdLineG,'<oper>');
    if CmdLineU>=2 then
      writeln('Prefix for Eager           (-E): ',CmdLineE,'<oper>');
    writeln('Verbose level              (-V): ',CmdLineV);
    end;
  while OpsPbtxt<>'' do
    begin
    ParseStringIntoThree(OpsPbtxt,LabelString,ContentString,OpsPbtxt);
    if LabelString='op' then
      begin
      ProcessOp(ContentString);
      inc(OperationCount);
      end
    else
      begin
      if CmdLineV>=1 then
        writeln('"op" expected "'+LabelString+'" received');
      end;
    end;
  TemplateStr:=Copy(TemplateStr,1,Pos(TS,TemplateStr)-1)+
               '//  This file was automatically generated by Wrapper Maker on '+DateToStr(Now)+
               Copy(TemplateStr,Pos(TS,TemplateStr)+Length(TS));
  TemplateStr:=Copy(TemplateStr,1,Pos(TDB,TemplateStr)-1)+Copy(TemplateStr,Pos(TDE,TemplateStr)+Length(TDE)+2);
  if (CmdLineU=1) or (CmdLineU=3) then
    begin // TGraphExt is generated
    TemplateStr:=Copy(TemplateStr,1,Pos(GDB,TemplateStr)-1)+Copy(TemplateStr,Pos(GDB,TemplateStr)+Length(GDB)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GDE,TemplateStr)-1)+Copy(TemplateStr,Pos(GDE,TemplateStr)+Length(GDE)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GNB,TemplateStr)-1)+Copy(TemplateStr,Pos(GNB,TemplateStr)+Length(GNB)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GNF,TemplateStr)-1)+GraphInterface+Copy(TemplateStr,Pos(GNF,TemplateStr)+Length(GNF)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GNE,TemplateStr)-1)+Copy(TemplateStr,Pos(GNE,TemplateStr)+Length(GNE)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GMB,TemplateStr)-1)+Copy(TemplateStr,Pos(GMB,TemplateStr)+Length(GMB)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GMF,TemplateStr)-1)+GraphImplementation+Copy(TemplateStr,Pos(GMF,TemplateStr)+Length(GMF)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GME,TemplateStr)-1)+Copy(TemplateStr,Pos(GME,TemplateStr)+Length(GME)+2);
    end
  else
    begin // TGraphExt is not generated, references removed
    TemplateStr:=Copy(TemplateStr,1,Pos(GDB,TemplateStr)-1)+Copy(TemplateStr,Pos(GDE,TemplateStr)+Length(GDE)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GNB,TemplateStr)-1)+Copy(TemplateStr,Pos(GNE,TemplateStr)+Length(GNE)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(GMB,TemplateStr)-1)+Copy(TemplateStr,Pos(GME,TemplateStr)+Length(GME)+2);
    end;
  if (CmdLineU=2) or (CmdLineU=3) then
    begin // Exec<oper> is generated
    TemplateStr:=Copy(TemplateStr,1,Pos(EDB,TemplateStr)-1)+Copy(TemplateStr,Pos(EDB,TemplateStr)+Length(EDB)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(EDE,TemplateStr)-1)+Copy(TemplateStr,Pos(EDE,TemplateStr)+Length(EDE)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(ENB,TemplateStr)-1)+Copy(TemplateStr,Pos(ENB,TemplateStr)+Length(ENB)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(ENF,TemplateStr)-1)+EagerInterface+Copy(TemplateStr,Pos(ENF,TemplateStr)+Length(ENF)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(ENE,TemplateStr)-1)+Copy(TemplateStr,Pos(ENE,TemplateStr)+Length(ENE)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(EMB,TemplateStr)-1)+Copy(TemplateStr,Pos(EMB,TemplateStr)+Length(EMB)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(EMF,TemplateStr)-1)+EagerImplementation+Copy(TemplateStr,Pos(EMF,TemplateStr)+Length(EMF)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(EME,TemplateStr)-1)+Copy(TemplateStr,Pos(EME,TemplateStr)+Length(EME)+2);
    end
  else
    begin // Exec<oper> is not generated, references removed
    TemplateStr:=Copy(TemplateStr,1,Pos(EDB,TemplateStr)-1)+Copy(TemplateStr,Pos(EDE,TemplateStr)+Length(EDE)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(ENB,TemplateStr)-1)+Copy(TemplateStr,Pos(ENE,TemplateStr)+Length(ENE)+2);
    TemplateStr:=Copy(TemplateStr,1,Pos(EMB,TemplateStr)-1)+Copy(TemplateStr,Pos(eME,TemplateStr)+Length(EME)+2);
    end;
  SaveUnit;
  result:=true;
  if CmdLineV>=1 then
    begin
    writeln;
    writeln('Wrapper unit completed');
    end;
  if CmdLineV>=2 then
    writeln('Processed ',OperationCount,' operations, added ',GraphCount,' TGraph.',CmdLineG,'<oper> and ',EagerCount,
             ' ',CmdLineE,'<oper> functions.');
  end;
function RunGenerator:boolean;
  begin
  result:=
    GetOpsPbtxt and
    RemoveExtraSpaces and
    LoadTemplate and
    ProcessFile;
  end;

// The Main program
begin
if ProcessCommandLine then // no error in the command line
  begin
  if CmdLineH>0 then // help requested
    PrintHelp
  else
    RunGenerator;
  end;
end.

