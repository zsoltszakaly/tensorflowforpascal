unit tf_wrapper;

//**********************************************************************************************************************************
//
//  Pascal methods to create and manage TensorFlow based Operations in a Specific manner
//
//  Copyright: (C) 2020-2023, Zsolt Szakaly
//
//  This source is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
//  published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
//
//  This code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
//  A copy of the GNU General Public License is available on the World Wide Web at <http://www.gnu.org/copyleft/gpl.html>. You can
//  also obtain it by writing to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1335, USA.
//
//  This file was automatically generated by Wrapper Maker on 18-1-23
//
//**********************************************************************************************************************************
//
//  Description
//
//  This wrapper file includes a TGraphExt object, built on the TGraph object defined in tf_operations. This extension of the
//  TGraph adds operation specific Add<oper> methods. Using them is functionally the same as using the original AddOper function.
//  There are some benefits though. Already at the time typing the Add<oper>( the editor (if you use an IDE, like Lazarus) will
//  bring up the parameter list, so you can see what inputs and parameters are needed for a given operation. This can simplify
//  the programming work. On the other hand, it must be mentioned that certain TensorFlow operations have default attributes. E.g.
//  MatMul (matrix multiplication) have two attributes (transpose_a and transpose_b) indicating whether the input matrix/matrices
//  need to be transposed before the operation or not. The default value for both, is false. If you use AddOper, you can safely skip
//  these attributes if you do not want to transpose your matrices. In the Specific calls (e.g. AddMatMul), included in this file
//  all attributes of the given operation must be specified. There were considerations to avoid this, but none of the options is
//  practical to implement. The "elegant" way of having "transpose:boolean=false" instead of just having "transpose:boolean" in the
//  declaration could be done. The problem with this approach is that there are operations that use a Tensor as an attribute and it
//  even has a default, but it is not possible to use something like "const Attr:TF_Tensor=CreateTensor". For the majority of
//  attributes with default however this approach could work, but in this case the default value would already be in tf_wrapper and
//  if TensorFlow changes it in the library, the wrapper would still call it with the old default. This was not a desired outcome.
//  Another approach could be to have different versions of the definition. In case of the above mentioned MatMul, there could be
//  three different versions, one with no transpose atribute, one with one transpose atribute and one with two transpose attributes.
//  The problem that in case of one, it can only be either the first or the second, but there is no way do define versions depending
//  which one you want to give. For more complicated operations with more attributes the number of combinations increases rapidly,
//  especially when the attributes have different types. So, again this was not a desired outcome. The third way is even uglier.
//  There could be functions with different names, depending which attribute is specified and which is not. This would make the use
//  probably even more complicated, e.g. having AddMatMul, AddMatMulTransposea, AddMatMulTransposeb, AddMatMulTransposeaTransposeb.
//  Oddly enough in this case the name could already indicate even the value of the attribute (using the one with Transposea
//  probably means that you want to transpose a, so it is not needed as an attribute. For more comlex operations the number of such
//  name combinations would be 2^n, what is again not a desired outcome. This is why the Add<oper> functions include all the
//  attributes, regardless if they have default value or not.
//  It is possible, that later the WrapperMaker will be improved in a way, that at least for the easy cases some simplification is
//  added, but it is not a priority. If for whatever reason you cannot specify the attribute and you want to use the TensorFlow
//  default value, you can still use the base AddOper function. AddOper and the different Add<oper> functions can be used together,
//  so if only for one operation you have this problem with, you can still use TGraphExt and use the different Add<oper> functions.
//
//
//  This wrapper file includes operation specific Exec<oper> functions. These functions are built on the Generic ExecOper function
//  defined in tf_operations. Exec<oper> functions are only generated for operations that have only ONE Output and no InputList or
//  OutputList parameters. In the background the Specific Exec<oper> functions call a version of the ExecOper function.
//  The benefit of using Exec<oper> is that it lists what parameters are required to call the given operation, let it be Inputs or
//  Attributes. If you use an IDE, already at typing Exec<oper>(, you can see the parameter list, do not need to look it up in the
//  specification. Also, if an Attribute can be retrieved from the Input Tensor (typically the data type of it, often called "T"),
//  then it is automatically done, you do not need to input it.
//  As described in the Description of the TGraphExt.Add<oper> (if this tf_wrapper was generated without generating TGraphExt, then
//  you can find this description in the tf_wrappertemplate file) there is a difference between how ExecOper and Exec<oper> handle
//  the TensorFlow default attributes. In ExecOper you can skip those attributes that have a default value and you are happy with
//  it. In the Exec<oper> functions you have to explicitely give all attributes of the given operations. The reasons can be found in
//  the mentioned TGraphExt description. Similarly to TGraphExt this is currently a low priority to improve on this. It is not a bad
//  programming practice anyway to specify these parameters explicitely, but if you want to avoid it, just use the base ExecOper.
//  Just like, in case of ExecOper, all Exec<oper> functions have optional boolean parameters (starting with D_) to delete the input
//  Tensors at the end of the Operation. This is to make memory management much easier and allow in-line TensorCreate when calling
//  ExecOper or one of the Exec<oper> functions, without creating a memory leak.
//
//**********************************************************************************************************************************


interface

uses
  ctypes,
  SysUtils,
  tf_api,
  tf_operations;


// The new TGraphExt object based on the TGraph, specified in tf_operations
type
  TGraphExt=object(TGraph)
    function AddAbort(const A_error_msg:string; const A_exit_without_error:boolean):string;
    function AddAbs(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient:string; const A_dtype:TF_DataType):string;
    function AddAccumulatorNumAccumulated(const I_handle:string; const O_num_accumulated:string):string;
    function AddAccumulatorSetGlobalStep(const I_handle:string; const I_new_global_step:string):string;
    function AddAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_average:string; const A_dtype:TF_DataType):string;
    function AddAcos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAcosh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAdd(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddAddManySparseToTensorsMap(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_sparse_handles:string; const A_T:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddAddN(const IL_inputs:TF_StringList; const O_sum:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddAddSparseToTensorsMap(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_sparse_handle:string; const A_T:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddAdjustContrast(const I_images:string; const I_contrast_factor:string; const I_min_value:string; const I_max_value:string; const O_output:string; const A_T:TF_DataType):string;
    function AddAdjustContrastv2(const I_images:string; const I_contrast_factor:string; const O_output:string):string;
    function AddAdjustHue(const I_images:string; const I_delta:string; const O_output:string):string;
    function AddAdjustSaturation(const I_images:string; const I_scale:string; const O_output:string):string;
    function AddAll(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_Tidx:TF_DataType):string;
    function AddAllCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_seed:cint64; const A_seed2:cint64):string;
    function AddAny(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_Tidx:TF_DataType):string;
    function AddApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyAdam(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyDelayCompensatedGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const I_lambda:string; const I_shadow:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_delta:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApproximateEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType; const A_tolerance:real):string;
    function AddArgMax(const I_input:string; const I_dimension:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_output_type:TF_DataType):string;
    function AddArgMin(const I_input:string; const I_dimension:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_output_type:TF_DataType):string;
    function AddAsString(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_precision:cint64; const A_scientific:boolean; const A_shortest:boolean; const A_width:cint64; const A_fill:string):string;
    function AddAsin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAsinh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAssert(const I_condition:string; const IL_data:TF_StringList; const A_T:TF_TypeList; const A_summarize:cint64):string;
    function AddAssign(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_validate_shape:boolean; const A_use_locking:boolean):string;
    function AddAssignAdd(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddAssignSub(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddAtan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAtan2(const I_y:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddAtanh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAudioSpectrogram(const I_input:string; const O_spectrogram:string; const A_window_size:cint64; const A_stride:cint64; const A_magnitude_squared:boolean):string;
    function AddAudioSummary(const I_tag:string; const I_tensor:string; const O_summary:string; const A_sample_rate:real; const A_max_outputs:cint64):string;
    function AddAudioSummaryV2(const I_tag:string; const I_tensor:string; const I_sample_rate:string; const O_summary:string; const A_max_outputs:cint64):string;
    function AddAvgPool(const I_value:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddAvgPool3D(const I_input:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddAvgPool3DGrad(const I_orig_input_shape:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddAvgPoolGrad(const I_orig_input_shape:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddBarrier(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddBarrierClose(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
    function AddBarrierIncompleteSize(const I_handle:string; const O_size:string):string;
    function AddBarrierInsertMany(const I_handle:string; const I_keys:string; const I_values:string; const A_T:TF_DataType; const A_component_index:cint64):string;
    function AddBarrierReadySize(const I_handle:string; const O_size:string):string;
    function AddBarrierTakeMany(const I_handle:string; const I_num_elements:string; const O_indices:string; const O_keys:string; const OL_values:TF_StringList; const A_component_types:TF_TypeList; const A_allow_small_batch:boolean; const A_wait_for_incomplete:boolean; const A_timeout_ms:cint64):string;
    function AddBatchCholesky(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchCholeskyGrad(const I_l:string; const I_grad:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchDataset(const I_input_dataset:string; const I_batch_size:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddBatchFFT(const I_input:string; const O_output:string):string;
    function AddBatchFFT2D(const I_input:string; const O_output:string):string;
    function AddBatchFFT3D(const I_input:string; const O_output:string):string;
    function AddBatchIFFT(const I_input:string; const O_output:string):string;
    function AddBatchIFFT2D(const I_input:string; const O_output:string):string;
    function AddBatchIFFT3D(const I_input:string; const O_output:string):string;
    function AddBatchMatMul(const I_x:string; const I_y:string; const O_output:string; const A_T:TF_DataType; const A_adj_x:boolean; const A_adj_y:boolean):string;
    function AddBatchMatrixBandPart(const I_input:string; const I_num_lower:string; const I_num_upper:string; const O_band:string; const A_T:TF_DataType):string;
    function AddBatchMatrixDeterminant(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchMatrixDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchMatrixDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
    function AddBatchMatrixInverse(const I_input:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddBatchMatrixSetDiag(const I_input:string; const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchMatrixSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddBatchMatrixSolveLs(const I_matrix:string; const I_rhs:string; const I_l2_regularizer:string; const O_output:string; const A_T:TF_DataType; const A_fast:boolean):string;
    function AddBatchMatrixTriangularSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_lower:boolean; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddBatchNormWithGlobalNormalization(const I_t:string; const I_m:string; const I_v:string; const I_beta:string; const I_gamma:string; const O_result:string; const A_T:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
    function AddBatchNormWithGlobalNormalizationGrad(const I_t:string; const I_m:string; const I_v:string; const I_gamma:string; const I_backprop:string; const O_dx:string; const O_dm:string; const O_dv:string; const O_db:string; const O_dg:string; const A_T:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
    function AddBatchSelfAdjointEig(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchSelfAdjointEigV2(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType):string;
    function AddBatchSvd(const I_input:string; const O_s:string; const O_u:string; const O_v:string; const A_compute_uv:boolean; const A_full_matrices:boolean; const A_T:TF_DataType):string;
    function AddBatchToSpace(const I_input:string; const I_crops:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64; const A_Tidx:TF_DataType):string;
    function AddBatchToSpaceND(const I_input:string; const I_block_shape:string; const I_crops:string; const O_output:string; const A_T:TF_DataType; const A_Tblock_shape:TF_DataType; const A_Tcrops:TF_DataType):string;
    function AddBetainc(const I_a:string; const I_b:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddBiasAdd(const I_value:string; const I_bias:string; const O_output:string; const A_T:TF_DataType; const A_data_format:string):string;
    function AddBiasAddGrad(const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_data_format:string):string;
    function AddBiasAddV1(const I_value:string; const I_bias:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBincount(const I_arr:string; const I_size:string; const I_weights:string; const O_bins:string; const A_T:TF_DataType):string;
    function AddBitcast(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_type:TF_DataType):string;
    function AddBitwiseAnd(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddBitwiseOr(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddBitwiseXor(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddBroadcastArgs(const I_s0:string; const I_s1:string; const O_r0:string; const A_T:TF_DataType):string;
    function AddBroadcastGradientArgs(const I_s0:string; const I_s1:string; const O_r0:string; const O_r1:string; const A_T:TF_DataType):string;
    function AddBucketize(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_boundaries:TF_FloatList):string;
    function AddCTCBeamSearchDecoder(const I_inputs:string; const I_sequence_length:string; const O_log_probability:string; const OL_decoded_indices:TF_StringList; const OL_decoded_values:TF_StringList; const OL_decoded_shape:TF_StringList; const A_beam_width:cint64; const A_top_paths:cint64; const A_merge_repeated:boolean):string;
    function AddCTCGreedyDecoder(const I_inputs:string; const I_sequence_length:string; const O_decoded_indices:string; const O_decoded_values:string; const O_decoded_shape:string; const O_log_probability:string; const A_merge_repeated:boolean):string;
    function AddCTCLoss(const I_inputs:string; const I_labels_indices:string; const I_labels_values:string; const I_sequence_length:string; const O_loss:string; const O_gradient:string; const A_preprocess_collapse_repeated:boolean; const A_ctc_merge_repeated:boolean; const A_ignore_longer_outputs_than_inputs:boolean):string;
    function AddCacheDataset(const I_input_dataset:string; const I_filename:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddCast(const I_x:string; const O_y:string; const A_SrcT:TF_DataType; const A_DstT:TF_DataType):string;
    function AddCeil(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddCheckNumerics(const I_tensor:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
    function AddCholesky(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddCholeskyGrad(const I_l:string; const I_grad:string; const O_output:string; const A_T:TF_DataType):string;
    function AddComplex(const I_real:string; const I_imag:string; const O_out:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddComplexAbs(const I_x:string; const O_y:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddComputeAccidentalHits(const I_true_classes:string; const I_sampled_candidates:string; const O_indices:string; const O_ids:string; const O_weights:string; const A_num_true:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddConcat(const I_concat_dim:string; const IL_values:TF_StringList; const O_output:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddConcatOffset(const I_concat_dim:string; const IL_shape:TF_StringList; const OL_offset:TF_StringList; const A_N:cint64):string;
    function AddConcatV2(const I_axis:string; const IL_values:TF_StringList; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddConcatenateDataset(const I_input_dataset:string; const I_another_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string):string;
    function AddConj(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddConst(const O_output:string; const A_value:TF_TensorPtr; const A_dtype:TF_DataType):string;
    function AddControlTrigger():string;
    function AddConv2D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string):string;
    function AddConv2DBackpropFilter(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string):string;
    function AddConv2DBackpropInput(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string):string;
    function AddConv3D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
    function AddConv3DBackpropFilter(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string):string;
    function AddConv3DBackpropFilterV2(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
    function AddConv3DBackpropInput(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string):string;
    function AddConv3DBackpropInputV2(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
    function AddCopy(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList):string;
    function AddCopyHost(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList):string;
    function AddCos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddCosh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddCountUpTo(const I_ref:string; const O_output:string; const A_limit:cint64; const A_T:TF_DataType):string;
    function AddCropAndResize(const I_image:string; const I_boxes:string; const I_box_ind:string; const I_crop_size:string; const O_crops:string; const A_T:TF_DataType; const A_method:string; const A_extrapolation_value:real):string;
    function AddCropAndResizeGradBoxes(const I_grads:string; const I_image:string; const I_boxes:string; const I_box_ind:string; const O_output:string; const A_T:TF_DataType; const A_method:string):string;
    function AddCropAndResizeGradImage(const I_grads:string; const I_boxes:string; const I_box_ind:string; const I_image_size:string; const O_output:string; const A_T:TF_DataType; const A_method:string):string;
    function AddCross(const I_a:string; const I_b:string; const O_product:string; const A_T:TF_DataType):string;
    function AddCumprod(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddCumsum(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddDebugIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean):string;
    function AddDebugNanCount(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean):string;
    function AddDebugNumericSummary(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_lower_bound:real; const A_upper_bound:real; const A_mute_if_healthy:boolean; const A_gated_grpc:boolean):string;
    function AddDecodeBase64(const I_input:string; const O_output:string):string;
    function AddDecodeBmp(const I_contents:string; const O_image:string; const A_channels:cint64):string;
    function AddDecodeCSV(const I_records:string; const IL_record_defaults:TF_StringList; const OL_output:TF_StringList; const A_OUT_TYPE:TF_TypeList; const A_field_delim:string; const A_use_quote_delim:boolean):string;
    function AddDecodeGif(const I_contents:string; const O_image:string):string;
    function AddDecodeJSONExample(const I_json_examples:string; const O_binary_examples:string):string;
    function AddDecodeJpeg(const I_contents:string; const O_image:string; const A_channels:cint64; const A_ratio:cint64; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string):string;
    function AddDecodePng(const I_contents:string; const O_image:string; const A_channels:cint64; const A_dtype:TF_DataType):string;
    function AddDecodeRaw(const I_bytes:string; const O_output:string; const A_out_type:TF_DataType; const A_little_endian:boolean):string;
    function AddDecodeWav(const I_contents:string; const O_audio:string; const O_sample_rate:string; const A_desired_channels:cint64; const A_desired_samples:cint64):string;
    function AddDeleteSessionTensor(const I_handle:string):string;
    function AddDenseToDenseSetOperation(const I_set1:string; const I_set2:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
    function AddDenseToSparseBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_row_shape:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddDenseToSparseSetOperation(const I_set1:string; const I_set2_indices:string; const I_set2_values:string; const I_set2_shape:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
    function AddDepthToSpace(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64):string;
    function AddDepthwiseConv2dNative(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
    function AddDepthwiseConv2dNativeBackpropFilter(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
    function AddDepthwiseConv2dNativeBackpropInput(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
    function AddDequantize(const I_input:string; const I_min_range:string; const I_max_range:string; const O_output:string; const A_T:TF_DataType; const A_mode:string):string;
    function AddDeserializeManySparse(const I_serialized_sparse:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType):string;
    function AddDestroyTemporaryVariable(const I_ref:string; const O_value:string; const A_T:TF_DataType; const A_var_name:string):string;
    function AddDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
    function AddDigamma(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddDilation2D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
    function AddDilation2DBackpropFilter(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_filter_backprop:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
    function AddDilation2DBackpropInput(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_in_backprop:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
    function AddDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddDrawBoundingBoxes(const I_images:string; const I_boxes:string; const O_output:string; const A_T:TF_DataType):string;
    function AddDynamicPartition(const I_data:string; const I_partitions:string; const OL_outputs:TF_StringList; const A_num_partitions:cint64; const A_T:TF_DataType):string;
    function AddDynamicStitch(const IL_indices:TF_StringList; const IL_data:TF_StringList; const O_merged:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddEditDistance(const I_hypothesis_indices:string; const I_hypothesis_values:string; const I_hypothesis_shape:string; const I_truth_indices:string; const I_truth_values:string; const I_truth_shape:string; const O_output:string; const A_normalize:boolean; const A_T:TF_DataType):string;
    function AddElu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddEluGrad(const I_gradients:string; const I_outputs:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddEncodeBase64(const I_input:string; const O_output:string; const A_pad:boolean):string;
    function AddEncodeJpeg(const I_image:string; const O_contents:string; const A_format:string; const A_quality:cint64; const A_progressive:boolean; const A_optimize_size:boolean; const A_chroma_downsampling:boolean; const A_density_unit:string; const A_x_density:cint64; const A_y_density:cint64; const A_xmp_metadata:string):string;
    function AddEncodePng(const I_image:string; const O_contents:string; const A_compression:cint64; const A_T:TF_DataType):string;
    function AddEncodeWav(const I_audio:string; const I_sample_rate:string; const O_contents:string):string;
    function AddEnter(const I_data:string; const O_output:string; const A_T:TF_DataType; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64):string;
    function AddEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddErf(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddErfc(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddExit(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
    function AddExp(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddExpandDims(const I_input:string; const I_dim:string; const O_output:string; const A_T:TF_DataType; const A_Tdim:TF_DataType):string;
    function AddExpm1(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddExtractGlimpse(const I_input:string; const I_size:string; const I_offsets:string; const O_glimpse:string; const A_centered:boolean; const A_normalized:boolean; const A_uniform_noise:boolean):string;
    function AddExtractImagePatches(const I_images:string; const O_patches:string; const A_ksizes:TF_IntList; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_T:TF_DataType; const A_padding:string):string;
    function AddFFT(const I_input:string; const O_output:string):string;
    function AddFFT2D(const I_input:string; const O_output:string):string;
    function AddFFT3D(const I_input:string; const O_output:string):string;
    function AddFIFOQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddFIFOQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddFact(const O_fact:string):string;
    function AddFakeQuantWithMinMaxArgs(const I_inputs:string; const O_outputs:string; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxArgsGradient(const I_gradients:string; const I_inputs:string; const O_backprops:string; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxVars(const I_inputs:string; const I_min:string; const I_max:string; const O_outputs:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxVarsGradient(const I_gradients:string; const I_inputs:string; const I_min:string; const I_max:string; const O_backprops_wrt_input:string; const O_backprop_wrt_min:string; const O_backprop_wrt_max:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxVarsPerChannel(const I_inputs:string; const I_min:string; const I_max:string; const O_outputs:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxVarsPerChannelGradient(const I_gradients:string; const I_inputs:string; const I_min:string; const I_max:string; const O_backprops_wrt_input:string; const O_backprop_wrt_min:string; const O_backprop_wrt_max:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQueue(const I_resource:string; const O_handle:string):string;
    function AddFill(const I_dims:string; const I_value:string; const O_output:string; const A_T:TF_DataType):string;
    function AddFilterDataset(const I_input_dataset:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_predicate:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddFixedLengthRecordDataset(const I_filenames:string; const I_header_bytes:string; const I_record_bytes:string; const I_footer_bytes:string; const O_handle:string):string;
    function AddFixedLengthRecordReader(const O_reader_handle:string; const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string):string;
    function AddFixedLengthRecordReaderV2(const O_reader_handle:string; const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string; const A_encoding:string):string;
    function AddFixedUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_vocab_file:string; const A_distortion:real; const A_num_reserved_ids:cint64; const A_num_shards:cint64; const A_shard:cint64; const A_unigrams:TF_FloatList; const A_seed:cint64; const A_seed2:cint64):string;
    function AddFlatMapDataset(const I_input_dataset:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddFloor(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddFloorDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddFloorMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddFractionalAvgPool(const I_value:string; const O_output:string; const O_row_pooling_sequence:string; const O_col_pooling_sequence:string; const A_pooling_ratio:TF_FloatList; const A_pseudo_random:boolean; const A_overlapping:boolean; const A_deterministic:boolean; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
    function AddFractionalAvgPoolGrad(const I_orig_input_tensor_shape:string; const I_out_backprop:string; const I_row_pooling_sequence:string; const I_col_pooling_sequence:string; const O_output:string; const A_overlapping:boolean; const A_T:TF_DataType):string;
    function AddFractionalMaxPool(const I_value:string; const O_output:string; const O_row_pooling_sequence:string; const O_col_pooling_sequence:string; const A_pooling_ratio:TF_FloatList; const A_pseudo_random:boolean; const A_overlapping:boolean; const A_deterministic:boolean; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
    function AddFractionalMaxPoolGrad(const I_orig_input:string; const I_orig_output:string; const I_out_backprop:string; const I_row_pooling_sequence:string; const I_col_pooling_sequence:string; const O_output:string; const A_overlapping:boolean; const A_T:TF_DataType):string;
    function AddFusedBatchNorm(const I_x:string; const I_scale:string; const I_offset:string; const I_mean:string; const I_variance:string; const O_y:string; const O_batch_mean:string; const O_batch_variance:string; const O_reserve_space_1:string; const O_reserve_space_2:string; const A_T:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
    function AddFusedBatchNormGrad(const I_y_backprop:string; const I_x:string; const I_scale:string; const I_reserve_space_1:string; const I_reserve_space_2:string; const O_x_backprop:string; const O_scale_backprop:string; const O_offset_backprop:string; const O_reserve_space_3:string; const O_reserve_space_4:string; const A_T:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
    function AddFusedPadConv2D(const I_input:string; const I_paddings:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_mode:string; const A_strides:TF_IntList; const A_padding:string):string;
    function AddFusedResizeAndPadConv2D(const I_input:string; const I_size:string; const I_paddings:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_resize_align_corners:boolean; const A_mode:string; const A_strides:TF_IntList; const A_padding:string):string;
    function AddGather(const I_params:string; const I_indices:string; const O_output:string; const A_validate_indices:boolean; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddGatherNd(const I_params:string; const I_indices:string; const O_output:string; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddGatherV2(const I_params:string; const I_indices:string; const I_axis:string; const O_output:string; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType; const A_Taxis:TF_DataType):string;
    function AddGetSessionHandle(const I_value:string; const O_handle:string; const A_T:TF_DataType):string;
    function AddGetSessionHandleV2(const I_value:string; const O_handle:string; const A_T:TF_DataType):string;
    function AddGetSessionTensor(const I_handle:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddGreater(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddGreaterEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddGroupByWindowDataset(const I_input_dataset:string; const I_window_size:string; const IL_key_func_other_arguments:TF_StringList; const IL_reduce_func_other_arguments:TF_StringList; const O_handle:string; const A_key_func:TF_Function; const A_reduce_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddHSVToRGB(const I_images:string; const O_output:string; const A_T:TF_DataType):string;
    function AddHashTable(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
    function AddHashTableV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
    function AddHistogramSummary(const I_tag:string; const I_values:string; const O_summary:string; const A_T:TF_DataType):string;
    function AddIFFT(const I_input:string; const O_output:string):string;
    function AddIFFT2D(const I_input:string; const O_output:string):string;
    function AddIFFT3D(const I_input:string; const O_output:string):string;
    function AddIRFFT(const I_input:string; const I_fft_length:string; const O_output:string):string;
    function AddIRFFT2D(const I_input:string; const I_fft_length:string; const O_output:string):string;
    function AddIRFFT3D(const I_input:string; const I_fft_length:string; const O_output:string):string;
    function AddIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddIdentityReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddIdentityReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddIgamma(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddIgammac(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddIgnoreErrorsDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddImag(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddImageSummary(const I_tag:string; const I_tensor:string; const O_summary:string; const A_max_images:cint64; const A_T:TF_DataType; const A_bad_color:TF_TensorPtr):string;
    function AddImmutableConst(const O_tensor:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_memory_region_name:string):string;
    function AddInTopK(const I_predictions:string; const I_targets:string; const O_precision:string; const A_k:cint64; const A_T:TF_DataType):string;
    function AddInitializeTable(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tkey:TF_DataType; const A_Tval:TF_DataType):string;
    function AddInitializeTableFromTextFile(const I_table_handle:string; const I_filename:string; const A_key_index:cint64; const A_value_index:cint64; const A_vocab_size:cint64; const A_delimiter:string):string;
    function AddInitializeTableFromTextFileV2(const I_table_handle:string; const I_filename:string; const A_key_index:cint64; const A_value_index:cint64; const A_vocab_size:cint64; const A_delimiter:string):string;
    function AddInitializeTableV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tkey:TF_DataType; const A_Tval:TF_DataType):string;
    function AddInterleaveDataset(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddInv(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddInvGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddInvert(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddInvertPermutation(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddIsFinite(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddIsInf(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddIsNan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddIsVariableInitialized(const I_ref:string; const O_is_initialized:string; const A_dtype:TF_DataType):string;
    function AddIterator(const O_handle:string; const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddIteratorDispose(const I_iterator:string):string;
    function AddIteratorFromStringHandle(const I_string_handle:string; const O_resource_handle:string):string;
    function AddIteratorGetNext(const I_iterator:string; const OL_components:TF_StringList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddIteratorToStringHandle(const I_resource_handle:string; const O_string_handle:string):string;
    function AddL2Loss(const I_t:string; const O_output:string; const A_T:TF_DataType):string;
    function AddLMDBReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddLRN(const I_input:string; const O_output:string; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const A_T:TF_DataType):string;
    function AddLRNGrad(const I_input_grads:string; const I_input_image:string; const I_output_image:string; const O_output:string; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const A_T:TF_DataType):string;
    function AddLearnedUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddLess(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddLessEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddLgamma(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddLinSpace(const I_start:string; const I_stop:string; const I_num:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddListDiff(const I_x:string; const I_y:string; const O_out:string; const O_idx:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
    function AddLog(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddLog1p(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddLogSoftmax(const I_logits:string; const O_logsoftmax:string; const A_T:TF_DataType):string;
    function AddLogUniformCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddLogicalAnd(const I_x:string; const I_y:string; const O_z:string):string;
    function AddLogicalNot(const I_x:string; const O_y:string):string;
    function AddLogicalOr(const I_x:string; const I_y:string; const O_z:string):string;
    function AddLookupTableExport(const I_table_handle:string; const O_keys:string; const O_values:string; const A_Tkeys:TF_DataType; const A_Tvalues:TF_DataType):string;
    function AddLookupTableExportV2(const I_table_handle:string; const O_keys:string; const O_values:string; const A_Tkeys:TF_DataType; const A_Tvalues:TF_DataType):string;
    function AddLookupTableFind(const I_table_handle:string; const I_keys:string; const I_default_value:string; const O_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableFindV2(const I_table_handle:string; const I_keys:string; const I_default_value:string; const O_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableImport(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableImportV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableInsert(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableInsertV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableSize(const I_table_handle:string; const O_size:string):string;
    function AddLookupTableSizeV2(const I_table_handle:string; const O_size:string):string;
    function AddLoopCond(const I_input:string; const O_output:string):string;
    function AddMakeIterator(const I_dataset:string; const I_iterator:string):string;
    function AddMapClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapDataset(const I_input_dataset:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddMapIncompleteSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapPeek(const I_key:string; const I_indices:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapStage(const I_key:string; const I_indices:string; const IL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_fake_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapUnstage(const I_key:string; const I_indices:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapUnstageNoKey(const I_indices:string; const O_key:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMatMul(const I_a:string; const I_b:string; const O_product:string; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_T:TF_DataType):string;
    function AddMatchingFiles(const I_pattern:string; const O_filenames:string):string;
    function AddMatrixBandPart(const I_input:string; const I_num_lower:string; const I_num_upper:string; const O_band:string; const A_T:TF_DataType):string;
    function AddMatrixDeterminant(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
    function AddMatrixInverse(const I_input:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddMatrixSetDiag(const I_input:string; const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddMatrixSolveLs(const I_matrix:string; const I_rhs:string; const I_l2_regularizer:string; const O_output:string; const A_T:TF_DataType; const A_fast:boolean):string;
    function AddMatrixTriangularSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_lower:boolean; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddMax(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddMaxPool(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
    function AddMaxPool3D(const I_input:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPool3DGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType; const A_TInput:TF_DataType):string;
    function AddMaxPool3DGradGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPoolGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPoolGradGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPoolGradGradWithArgmax(const I_input:string; const I_grad:string; const I_argmax:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_Targmax:TF_DataType; const A_T:TF_DataType):string;
    function AddMaxPoolGradWithArgmax(const I_input:string; const I_grad:string; const I_argmax:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_Targmax:TF_DataType; const A_T:TF_DataType):string;
    function AddMaxPoolWithArgmax(const I_input:string; const O_output:string; const O_argmax:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_Targmax:TF_DataType; const A_padding:string; const A_T:TF_DataType):string;
    function AddMaximum(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddMean(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddMerge(const IL_inputs:TF_StringList; const O_output:string; const O_value_index:string; const A_T:TF_DataType; const A_N:cint64):string;
    function AddMergeSummary(const IL_inputs:TF_StringList; const O_summary:string; const A_N:cint64):string;
    function AddMergeV2Checkpoints(const I_checkpoint_prefixes:string; const I_destination_prefix:string; const A_delete_old_dirs:boolean):string;
    function AddMfcc(const I_spectrogram:string; const I_sample_rate:string; const O_output:string; const A_upper_frequency_limit:real; const A_lower_frequency_limit:real; const A_filterbank_channel_count:cint64; const A_dct_coefficient_count:cint64):string;
    function AddMin(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddMinimum(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddMirrorPad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_mode:string):string;
    function AddMirrorPadGrad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_mode:string):string;
    function AddMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddMul(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddMultinomial(const I_logits:string; const I_num_samples:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
    function AddMutableDenseHashTable(const I_empty_key:string; const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real):string;
    function AddMutableDenseHashTableV2(const I_empty_key:string; const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real):string;
    function AddMutableHashTable(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
    function AddMutableHashTableOfTensors(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):string;
    function AddMutableHashTableOfTensorsV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):string;
    function AddMutableHashTableV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
    function AddNeg(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddNegTrain(const I_w_in:string; const I_w_out:string; const I_examples:string; const I_labels:string; const I_lr:string; const A_vocab_count:TF_IntList; const A_num_negative_samples:cint64):string;
    function AddNextIteration(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
    function AddNoOp():string;
    function AddNonMaxSuppression(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const O_selected_indices:string; const A_iou_threshold:real):string;
    function AddNonMaxSuppressionV2(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const O_selected_indices:string):string;
    function AddNotEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddOneHot(const I_indices:string; const I_depth:string; const I_on_value:string; const I_off_value:string; const O_output:string; const A_axis:cint64; const A_T:TF_DataType; const A_TI:TF_DataType):string;
    function AddOneShotIterator(const O_handle:string; const A_dataset_factory:TF_Function; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_container:string; const A_shared_name:string):string;
    function AddOnesLike(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddOrderedMapClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapIncompleteSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapPeek(const I_key:string; const I_indices:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapStage(const I_key:string; const I_indices:string; const IL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_fake_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapUnstage(const I_key:string; const I_indices:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapUnstageNoKey(const I_indices:string; const O_key:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddPack(const IL_values:TF_StringList; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_axis:cint64):string;
    function AddPad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType):string;
    function AddPadV2(const I_input:string; const I_paddings:string; const I_constant_values:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType):string;
    function AddPaddedBatchDataset(const I_input_dataset:string; const I_batch_size:string; const IL_padded_shapes:TF_StringList; const IL_padding_values:TF_StringList; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
    function AddPaddingFIFOQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddPaddingFIFOQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddParallelConcat(const IL_values:TF_StringList; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_shape:TF_Shape):string;
    function AddParallelMapDataset(const I_input_dataset:string; const I_num_threads:string; const I_output_buffer_size:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddParameterizedTruncatedNormal(const I_shape:string; const I_means:string; const I_stdevs:string; const I_minvals:string; const I_maxvals:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddParseExample(const I_serialized:string; const I_names:string; const IL_sparse_keys:TF_StringList; const IL_dense_keys:TF_StringList; const IL_dense_defaults:TF_StringList; const OL_sparse_indices:TF_StringList; const OL_sparse_values:TF_StringList; const OL_sparse_shapes:TF_StringList; const OL_dense_values:TF_StringList; const A_Nsparse:cint64; const A_Ndense:cint64; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList):string;
    function AddParseSingleSequenceExample(const I_serialized:string; const I_feature_list_dense_missing_assumed_empty:string; const I_debug_name:string; const IL_context_sparse_keys:TF_StringList; const IL_context_dense_keys:TF_StringList; const IL_feature_list_sparse_keys:TF_StringList; const IL_feature_list_dense_keys:TF_StringList; const IL_context_dense_defaults:TF_StringList; const OL_context_sparse_indices:TF_StringList; const OL_context_sparse_values:TF_StringList; const OL_context_sparse_shapes:TF_StringList; const OL_context_dense_values:TF_StringList; const OL_feature_list_sparse_indices:TF_StringList; const OL_feature_list_sparse_values:TF_StringList; const OL_feature_list_sparse_shapes:TF_StringList; const OL_feature_list_dense_values:TF_StringList; const A_Ncontext_sparse:cint64; const A_Ncontext_dense:cint64; const A_Nfeature_list_sparse:cint64; const A_Nfeature_list_dense:cint64; const A_context_sparse_types:TF_TypeList; const A_Tcontext_dense:TF_TypeList; const A_feature_list_dense_types:TF_TypeList; const A_context_dense_shapes:TF_ShapeList; const A_feature_list_sparse_types:TF_TypeList; const A_feature_list_dense_shapes:TF_ShapeList):string;
    function AddParseTensor(const I_serialized:string; const O_output:string; const A_out_type:TF_DataType):string;
    function AddPlaceholder(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddPlaceholderV2(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddPlaceholderWithDefault(const I_input:string; const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddPolygamma(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddPow(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddPreventGradient(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
    function AddPrint(const I_input:string; const IL_data:TF_StringList; const O_output:string; const A_T:TF_DataType; const A_U:TF_TypeList; const A_message:string; const A_first_n:cint64; const A_summarize:cint64):string;
    function AddPriorityQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddPriorityQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddProd(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddPyFunc(const IL_input:TF_StringList; const OL_output:TF_StringList; const A_token:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
    function AddPyFuncStateless(const IL_input:TF_StringList; const OL_output:TF_StringList; const A_token:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
    function AddQr(const I_input:string; const O_q:string; const O_r:string; const A_full_matrices:boolean; const A_T:TF_DataType):string;
    function AddQuantizeAndDequantize(const I_input:string; const O_output:string; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_input_min:real; const A_input_max:real; const A_T:TF_DataType):string;
    function AddQuantizeAndDequantizeV2(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output:string; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_T:TF_DataType):string;
    function AddQuantizeAndDequantizeV3(const I_input:string; const I_input_min:string; const I_input_max:string; const I_num_bits:string; const O_output:string; const A_signed_input:boolean; const A_range_given:boolean; const A_T:TF_DataType):string;
    function AddQuantizeDownAndShrinkRange(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizeV2(const I_input:string; const I_min_range:string; const I_max_range:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_mode:string):string;
    function AddQuantizedAdd(const I_x:string; const I_y:string; const I_min_x:string; const I_max_x:string; const I_min_y:string; const I_max_y:string; const O_z:string; const O_min_z:string; const O_max_z:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType):string;
    function AddQuantizedAvgPool(const I_input:string; const I_min_input:string; const I_max_input:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string):string;
    function AddQuantizedBatchNormWithGlobalNormalization(const I_t:string; const I_t_min:string; const I_t_max:string; const I_m:string; const I_m_min:string; const I_m_max:string; const I_v:string; const I_v_min:string; const I_v_max:string; const I_beta:string; const I_beta_min:string; const I_beta_max:string; const I_gamma:string; const I_gamma_min:string; const I_gamma_max:string; const O_result:string; const O_result_min:string; const O_result_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
    function AddQuantizedBiasAdd(const I_input:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_bias:string; const I_max_bias:string; const O_output:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizedConcat(const I_concat_dim:string; const IL_values:TF_StringList; const IL_input_mins:TF_StringList; const IL_input_maxes:TF_StringList; const O_output:string; const O_output_min:string; const O_output_max:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddQuantizedConv2D(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string):string;
    function AddQuantizedInstanceNorm(const I_x:string; const I_x_min:string; const I_x_max:string; const O_y:string; const O_y_min:string; const O_y_max:string; const A_T:TF_DataType; const A_output_range_given:boolean; const A_given_y_min:real; const A_given_y_max:real; const A_variance_epsilon:real; const A_min_separation:real):string;
    function AddQuantizedMatMul(const I_a:string; const I_b:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_Tactivation:TF_DataType):string;
    function AddQuantizedMaxPool(const I_input:string; const I_min_input:string; const I_max_input:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string):string;
    function AddQuantizedMul(const I_x:string; const I_y:string; const I_min_x:string; const I_max_x:string; const I_min_y:string; const I_max_y:string; const O_z:string; const O_min_z:string; const O_max_z:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType):string;
    function AddQuantizedRelu(const I_features:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizedRelu6(const I_features:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizedReluX(const I_features:string; const I_max_value:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizedReshape(const I_tensor:string; const I_shape:string; const I_input_min:string; const I_input_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_Tshape:TF_DataType):string;
    function AddQuantizedResizeBilinear(const I_images:string; const I_size:string; const I_min:string; const I_max:string; const O_resized_images:string; const O_out_min:string; const O_out_max:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
    function AddQueueClose(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
    function AddQueueCloseV2(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
    function AddQueueDequeue(const I_handle:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueMany(const I_handle:string; const I_n:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueManyV2(const I_handle:string; const I_n:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueUpTo(const I_handle:string; const I_n:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueUpToV2(const I_handle:string; const I_n:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueV2(const I_handle:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueEnqueue(const I_handle:string; const IL_components:TF_StringList; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueEnqueueMany(const I_handle:string; const IL_components:TF_StringList; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueEnqueueManyV2(const I_handle:string; const IL_components:TF_StringList; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueEnqueueV2(const I_handle:string; const IL_components:TF_StringList; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueIsClosed(const I_handle:string; const O_is_closed:string):string;
    function AddQueueIsClosedV2(const I_handle:string; const O_is_closed:string):string;
    function AddQueueSize(const I_handle:string; const O_size:string):string;
    function AddQueueSizeV2(const I_handle:string; const O_size:string):string;
    function AddRFFT(const I_input:string; const I_fft_length:string; const O_output:string):string;
    function AddRFFT2D(const I_input:string; const I_fft_length:string; const O_output:string):string;
    function AddRFFT3D(const I_input:string; const I_fft_length:string; const O_output:string):string;
    function AddRGBToHSV(const I_images:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRandomCrop(const I_image:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64):string;
    function AddRandomGamma(const I_shape:string; const I_alpha:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_T:TF_DataType):string;
    function AddRandomPoisson(const I_shape:string; const I_rate:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_dtype:TF_DataType):string;
    function AddRandomShuffle(const I_value:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
    function AddRandomShuffleQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):string;
    function AddRandomShuffleQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):string;
    function AddRandomStandardNormal(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddRandomUniform(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddRandomUniformInt(const I_shape:string; const I_minval:string; const I_maxval:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_Tout:TF_DataType; const A_T:TF_DataType):string;
    function AddRange(const I_start:string; const I_limit:string; const I_delta:string; const O_output:string; const A_Tidx:TF_DataType):string;
    function AddRangeDataset(const I_start:string; const I_stop:string; const I_step:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddRank(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddReadFile(const I_filename:string; const O_contents:string):string;
    function AddReaderNumRecordsProduced(const I_reader_handle:string; const O_records_produced:string):string;
    function AddReaderNumRecordsProducedV2(const I_reader_handle:string; const O_records_produced:string):string;
    function AddReaderNumWorkUnitsCompleted(const I_reader_handle:string; const O_units_completed:string):string;
    function AddReaderNumWorkUnitsCompletedV2(const I_reader_handle:string; const O_units_completed:string):string;
    function AddReaderRead(const I_reader_handle:string; const I_queue_handle:string; const O_key:string; const O_value:string):string;
    function AddReaderReadUpTo(const I_reader_handle:string; const I_queue_handle:string; const I_num_records:string; const O_keys:string; const O_values:string):string;
    function AddReaderReadUpToV2(const I_reader_handle:string; const I_queue_handle:string; const I_num_records:string; const O_keys:string; const O_values:string):string;
    function AddReaderReadV2(const I_reader_handle:string; const I_queue_handle:string; const O_key:string; const O_value:string):string;
    function AddReaderReset(const I_reader_handle:string):string;
    function AddReaderResetV2(const I_reader_handle:string):string;
    function AddReaderRestoreState(const I_reader_handle:string; const I_state:string):string;
    function AddReaderRestoreStateV2(const I_reader_handle:string; const I_state:string):string;
    function AddReaderSerializeState(const I_reader_handle:string; const O_state:string):string;
    function AddReaderSerializeStateV2(const I_reader_handle:string; const O_state:string):string;
    function AddReal(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddRealDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddReciprocal(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddReciprocalGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddRecordInput(const O_records:string; const A_file_pattern:string; const A_file_random_seed:cint64; const A_file_shuffle_shift_ratio:real; const A_file_buffer_size:cint64; const A_file_parallelism:cint64; const A_batch_size:cint64):string;
    function AddReduceJoin(const I_inputs:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_separator:string):string;
    function AddRefEnter(const I_data:string; const O_output:string; const A_T:TF_DataType; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64):string;
    function AddRefExit(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRefIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRefMerge(const IL_inputs:TF_StringList; const O_output:string; const O_value_index:string; const A_T:TF_DataType; const A_N:cint64):string;
    function AddRefNextIteration(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRefSelect(const I_index:string; const IL_inputs:TF_StringList; const O_output:string; const A_T:TF_DataType; const A_N:cint64):string;
    function AddRefSwitch(const I_data:string; const I_pred:string; const O_output_false:string; const O_output_true:string; const A_T:TF_DataType):string;
    function AddRelu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddRelu6(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddRelu6Grad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddReluGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddRemoteFusedGraphExecute(const IL_inputs:TF_StringList; const OL_outputs:TF_StringList; const A_Tinputs:TF_TypeList; const A_Toutputs:TF_TypeList; const A_serialized_remote_fused_graph_execute_info:string):string;
    function AddRepeatDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddRequantizationRange(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType):string;
    function AddRequantize(const I_input:string; const I_input_min:string; const I_input_max:string; const I_requested_output_min:string; const I_requested_output_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddReshape(const I_tensor:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tshape:TF_DataType):string;
    function AddResizeArea(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
    function AddResizeBicubic(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
    function AddResizeBilinear(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
    function AddResizeBilinearGrad(const I_grads:string; const I_original_image:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
    function AddResizeNearestNeighbor(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
    function AddResizeNearestNeighborGrad(const I_grads:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
    function AddResourceApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyAdam(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddResourceApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddResourceApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_delta:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddResourceSparseApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceStridedSliceAssign(const I_ref:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddRestore(const I_file_pattern:string; const I_tensor_name:string; const O_tensor:string; const A_dt:TF_DataType; const A_preferred_shard:cint64):string;
    function AddRestoreSlice(const I_file_pattern:string; const I_tensor_name:string; const I_shape_and_slice:string; const O_tensor:string; const A_dt:TF_DataType; const A_preferred_shard:cint64):string;
    function AddRestoreV2(const I_prefix:string; const I_tensor_names:string; const I_shape_and_slices:string; const OL_tensors:TF_StringList; const A_dtypes:TF_TypeList):string;
    function AddReverse(const I_tensor:string; const I_dims:string; const O_output:string; const A_T:TF_DataType):string;
    function AddReverseSequence(const I_input:string; const I_seq_lengths:string; const O_output:string; const A_seq_dim:cint64; const A_batch_dim:cint64; const A_T:TF_DataType; const A_Tlen:TF_DataType):string;
    function AddReverseV2(const I_tensor:string; const I_axis:string; const O_output:string; const A_Tidx:TF_DataType; const A_T:TF_DataType):string;
    function AddRint(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddRound(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddRsqrt(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddRsqrtGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSampleDistortedBoundingBox(const I_image_size:string; const I_bounding_boxes:string; const O_begin:string; const O_size:string; const O_bboxes:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64; const A_min_object_covered:real; const A_aspect_ratio_range:TF_FloatList; const A_area_range:TF_FloatList; const A_max_attempts:cint64; const A_use_image_if_no_bounding_boxes:boolean):string;
    function AddSampleDistortedBoundingBoxV2(const I_image_size:string; const I_bounding_boxes:string; const I_min_object_covered:string; const O_begin:string; const O_size:string; const O_bboxes:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64; const A_aspect_ratio_range:TF_FloatList; const A_area_range:TF_FloatList; const A_max_attempts:cint64; const A_use_image_if_no_bounding_boxes:boolean):string;
    function AddSave(const I_filename:string; const I_tensor_names:string; const IL_data:TF_StringList; const A_T:TF_TypeList):string;
    function AddSaveSlices(const I_filename:string; const I_tensor_names:string; const I_shapes_and_slices:string; const IL_data:TF_StringList; const A_T:TF_TypeList):string;
    function AddSaveV2(const I_prefix:string; const I_tensor_names:string; const I_shape_and_slices:string; const IL_tensors:TF_StringList; const A_dtypes:TF_TypeList):string;
    function AddScalarSummary(const I_tags:string; const I_values:string; const O_summary:string; const A_T:TF_DataType):string;
    function AddScatterAdd(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterDiv(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterMul(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterNd(const I_indices:string; const I_updates:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddScatterNdAdd(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterNdNonAliasingAdd(const I_input:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddScatterNdSub(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterNdUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterSub(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSdcaFprint(const I_input:string; const O_output:string):string;
    function AddSdcaOptimizer(const I_example_weights:string; const I_example_labels:string; const I_example_state_data:string; const IL_sparse_example_indices:TF_StringList; const IL_sparse_feature_indices:TF_StringList; const IL_sparse_feature_values:TF_StringList; const IL_dense_features:TF_StringList; const IL_sparse_indices:TF_StringList; const IL_sparse_weights:TF_StringList; const IL_dense_weights:TF_StringList; const O_out_example_state_data:string; const OL_out_delta_sparse_weights:TF_StringList; const OL_out_delta_dense_weights:TF_StringList; const A_loss_type:string; const A_adaptative:boolean; const A_num_sparse_features:cint64; const A_num_sparse_features_with_values:cint64; const A_num_dense_features:cint64; const A_l1:real; const A_l2:real; const A_num_loss_partitions:cint64; const A_num_inner_iterations:cint64):string;
    function AddSdcaShrinkL1(const IL_weights:TF_StringList; const A_num_features:cint64; const A_l1:real; const A_l2:real):string;
    function AddSegmentMax(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSegmentMean(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSegmentMin(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSegmentProd(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSegmentSum(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSelect(const I_condition:string; const I_t:string; const I_e:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSelfAdjointEig(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSelfAdjointEigV2(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType):string;
    function AddSerializeManySparse(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_serialized_sparse:string; const A_T:TF_DataType):string;
    function AddSerializeSparse(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_serialized_sparse:string; const A_T:TF_DataType):string;
    function AddSetSize(const I_set_indices:string; const I_set_values:string; const I_set_shape:string; const O_size:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
    function AddShape(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddShapeN(const IL_input:TF_StringList; const OL_output:TF_StringList; const A_N:cint64; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddShardedFilename(const I_basename:string; const I_shard:string; const I_num_shards:string; const O_filename:string):string;
    function AddShardedFilespec(const I_basename:string; const I_num_shards:string; const O_filename:string):string;
    function AddShuffleDataset(const I_input_dataset:string; const I_buffer_size:string; const I_seed:string; const I_seed2:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddSigmoid(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSigmoidGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSign(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSinh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSize(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddSkipDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddSkipgram(const O_vocab_word:string; const O_vocab_freq:string; const O_words_per_epoch:string; const O_current_epoch:string; const O_total_words_processed:string; const O_examples:string; const O_labels:string; const A_filename:string; const A_batch_size:cint64; const A_window_size:cint64; const A_min_count:cint64; const A_subsample:real):string;
    function AddSlice(const I_input:string; const I_begin:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType):string;
    function AddSoftmax(const I_logits:string; const O_softmax:string; const A_T:TF_DataType):string;
    function AddSoftmaxCrossEntropyWithLogits(const I_features:string; const I_labels:string; const O_loss:string; const O_backprop:string; const A_T:TF_DataType):string;
    function AddSoftplus(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddSoftplusGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddSoftsign(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddSoftsignGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddSpaceToBatch(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_block_size:cint64):string;
    function AddSpaceToBatchND(const I_input:string; const I_block_shape:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tblock_shape:TF_DataType; const A_Tpaddings:TF_DataType):string;
    function AddSpaceToDepth(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64):string;
    function AddSparseAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient_indices:string; const I_gradient_values:string; const I_gradient_shape:string; const A_dtype:TF_DataType; const A_has_known_shape:boolean):string;
    function AddSparseAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_indices:string; const O_values:string; const O_shape:string; const A_dtype:TF_DataType):string;
    function AddSparseAdd(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const I_thresh:string; const O_sum_indices:string; const O_sum_values:string; const O_sum_shape:string; const A_T:TF_DataType; const A_Treal:TF_DataType):string;
    function AddSparseAddGrad(const I_backprop_val_grad:string; const I_a_indices:string; const I_b_indices:string; const I_sum_indices:string; const O_a_val_grad:string; const O_b_val_grad:string; const A_T:TF_DataType):string;
    function AddSparseApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddSparseApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseConcat(const IL_indices:TF_StringList; const IL_values:TF_StringList; const IL_shapes:TF_StringList; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_concat_dim:cint64; const A_N:cint64; const A_T:TF_DataType):string;
    function AddSparseConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string):string;
    function AddSparseCross(const IL_indices:TF_StringList; const IL_values:TF_StringList; const IL_shapes:TF_StringList; const IL_dense_inputs:TF_StringList; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_N:cint64; const A_hashed_output:boolean; const A_num_buckets:cint64; const A_hash_key:cint64; const A_sparse_types:TF_TypeList; const A_dense_types:TF_TypeList; const A_out_type:TF_DataType; const A_internal_type:TF_DataType):string;
    function AddSparseDenseCwiseAdd(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseDenseCwiseDiv(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseDenseCwiseMul(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseFillEmptyRows(const I_indices:string; const I_values:string; const I_dense_shape:string; const I_default_value:string; const O_output_indices:string; const O_output_values:string; const O_empty_row_indicator:string; const O_reverse_index_map:string; const A_T:TF_DataType):string;
    function AddSparseFillEmptyRowsGrad(const I_reverse_index_map:string; const I_grad_values:string; const O_d_values:string; const O_d_default_value:string; const A_T:TF_DataType):string;
    function AddSparseMatMul(const I_a:string; const I_b:string; const O_product:string; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_a_is_sparse:boolean; const A_b_is_sparse:boolean; const A_Ta:TF_DataType; const A_Tb:TF_DataType):string;
    function AddSparseReduceMax(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
    function AddSparseReduceMaxSparse(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
    function AddSparseReduceSum(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
    function AddSparseReduceSumSparse(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
    function AddSparseReorder(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
    function AddSparseReshape(const I_input_indices:string; const I_input_shape:string; const I_new_shape:string; const O_output_indices:string; const O_output_shape:string):string;
    function AddSparseSegmentMean(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentMeanGrad(const I_grad:string; const I_indices:string; const I_segment_ids:string; const I_output_dim0:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentSqrtN(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentSqrtNGrad(const I_grad:string; const I_indices:string; const I_segment_ids:string; const I_output_dim0:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentSum(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSlice(const I_indices:string; const I_values:string; const I_shape:string; const I_start:string; const I_size:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_T:TF_DataType):string;
    function AddSparseSoftmax(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseSoftmaxCrossEntropyWithLogits(const I_features:string; const I_labels:string; const O_loss:string; const O_backprop:string; const A_T:TF_DataType; const A_Tlabels:TF_DataType):string;
    function AddSparseSparseMaximum(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
    function AddSparseSparseMinimum(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
    function AddSparseSplit(const I_split_dim:string; const I_indices:string; const I_values:string; const I_shape:string; const OL_output_indices:TF_StringList; const OL_output_values:TF_StringList; const OL_output_shape:TF_StringList; const A_num_split:cint64; const A_T:TF_DataType):string;
    function AddSparseTensorDenseAdd(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSparseTensorDenseMatMul(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b:string; const O_product:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_adjoint_a:boolean; const A_adjoint_b:boolean):string;
    function AddSparseTensorSliceDataset(const I_indices:string; const I_values:string; const I_dense_shape:string; const O_handle:string; const A_Tvalues:TF_DataType):string;
    function AddSparseToDense(const I_sparse_indices:string; const I_output_shape:string; const I_sparse_values:string; const I_default_value:string; const O_dense:string; const A_validate_indices:boolean; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSparseToSparseSetOperation(const I_set1_indices:string; const I_set1_values:string; const I_set1_shape:string; const I_set2_indices:string; const I_set2_values:string; const I_set2_shape:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
    function AddSplit(const I_split_dim:string; const I_value:string; const OL_output:TF_StringList; const A_num_split:cint64; const A_T:TF_DataType):string;
    function AddSplitV(const I_value:string; const I_size_splits:string; const I_split_dim:string; const OL_output:TF_StringList; const A_num_split:cint64; const A_T:TF_DataType; const A_Tlen:TF_DataType):string;
    function AddSqrt(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSqrtGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSquare(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSquaredDifference(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSqueeze(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_squeeze_dims:TF_IntList):string;
    function AddStack(const O_handle:string; const A_elem_type:TF_DataType; const A_stack_name:string):string;
    function AddStackClose(const I_handle:string):string;
    function AddStackCloseV2(const I_handle:string):string;
    function AddStackPop(const I_handle:string; const O_elem:string; const A_elem_type:TF_DataType):string;
    function AddStackPopV2(const I_handle:string; const O_elem:string; const A_elem_type:TF_DataType):string;
    function AddStackPush(const I_handle:string; const I_elem:string; const O_output:string; const A_T:TF_DataType; const A_swap_memory:boolean):string;
    function AddStackPushV2(const I_handle:string; const I_elem:string; const O_output:string; const A_T:TF_DataType; const A_swap_memory:boolean):string;
    function AddStackV2(const I_max_size:string; const O_handle:string; const A_elem_type:TF_DataType; const A_stack_name:string):string;
    function AddStage(const IL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddStageClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddStagePeek(const I_index:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddStageSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddStatelessRandomNormal(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddStatelessRandomUniform(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddStatelessTruncatedNormal(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddStopGradient(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddStridedSlice(const I_input:string; const I_begin:string; const I_end:string; const I_strides:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddStridedSliceAssign(const I_ref:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddStridedSliceGrad(const I_shape:string; const I_begin:string; const I_end:string; const I_strides:string; const I_dy:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddStringJoin(const IL_inputs:TF_StringList; const O_output:string; const A_N:cint64; const A_separator:string):string;
    function AddStringSplit(const I_input:string; const I_delimiter:string; const O_indices:string; const O_values:string; const O_shape:string):string;
    function AddStringToHashBucket(const I_string_tensor:string; const O_output:string; const A_num_buckets:cint64):string;
    function AddStringToHashBucketFast(const I_input:string; const O_output:string; const A_num_buckets:cint64):string;
    function AddStringToHashBucketStrong(const I_input:string; const O_output:string; const A_num_buckets:cint64; const A_key:TF_IntList):string;
    function AddStringToNumber(const I_string_tensor:string; const O_output:string; const A_out_type:TF_DataType):string;
    function AddSub(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSubstr(const I_input:string; const I_pos:string; const I_len:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSum(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSvd(const I_input:string; const O_s:string; const O_u:string; const O_v:string; const A_compute_uv:boolean; const A_full_matrices:boolean; const A_T:TF_DataType):string;
    function AddSwitch(const I_data:string; const I_pred:string; const O_output_false:string; const O_output_true:string; const A_T:TF_DataType):string;
    function AddSymbolicGradient(const IL_input:TF_StringList; const OL_output:TF_StringList; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function):string;
    function AddTFRecordDataset(const I_filenames:string; const I_compression_type:string; const O_handle:string):string;
    function AddTFRecordReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string; const A_compression_type:string):string;
    function AddTFRecordReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string; const A_compression_type:string):string;
    function AddTakeDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddTakeManySparseFromTensorsMap(const I_sparse_handles:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddTan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddTanh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddTanhGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddTemporaryVariable(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_var_name:string):string;
    function AddTensorArray(const I_size:string; const O_handle:string; const A_dtype:TF_DataType; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const A_element_shape:TF_Shape):string;
    function AddTensorArrayClose(const I_handle:string):string;
    function AddTensorArrayCloseV2(const I_handle:string):string;
    function AddTensorArrayCloseV3(const I_handle:string):string;
    function AddTensorArrayConcat(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
    function AddTensorArrayConcatV2(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
    function AddTensorArrayConcatV3(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
    function AddTensorArrayGather(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorArrayGatherV2(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorArrayGatherV3(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorArrayGrad(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const A_source:string):string;
    function AddTensorArrayGradV2(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const A_source:string):string;
    function AddTensorArrayGradV3(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const O_flow_out:string; const A_source:string):string;
    function AddTensorArrayPack(const I_handle:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorArrayRead(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddTensorArrayReadV2(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddTensorArrayReadV3(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddTensorArrayScatter(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayScatterV2(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayScatterV3(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArraySize(const I_handle:string; const I_flow_in:string; const O_size:string):string;
    function AddTensorArraySizeV2(const I_handle:string; const I_flow_in:string; const O_size:string):string;
    function AddTensorArraySizeV3(const I_handle:string; const I_flow_in:string; const O_size:string):string;
    function AddTensorArraySplit(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArraySplitV2(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArraySplitV3(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayUnpack(const I_handle:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayV2(const I_size:string; const O_handle:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string):string;
    function AddTensorArrayV3(const I_size:string; const O_handle:string; const O_flow:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string):string;
    function AddTensorArrayWrite(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayWriteV2(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayWriteV3(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorDataset(const IL_components:TF_StringList; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddTensorSliceDataset(const IL_components:TF_StringList; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddTensorSummary(const I_tensor:string; const O_summary:string; const A_T:TF_DataType; const A_description:string; const A_labels:TF_StringList; const A_display_name:string):string;
    function AddTensorSummaryV2(const I_tag:string; const I_tensor:string; const I_serialized_summary_metadata:string; const O_summary:string; const A_T:TF_DataType):string;
    function AddTextLineDataset(const I_filenames:string; const I_compression_type:string; const O_handle:string):string;
    function AddTextLineReader(const O_reader_handle:string; const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):string;
    function AddTextLineReaderV2(const O_reader_handle:string; const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):string;
    function AddThreadUnsafeUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddTile(const I_input:string; const I_multiples:string; const O_output:string; const A_T:TF_DataType; const A_Tmultiples:TF_DataType):string;
    function AddTileGrad(const I_input:string; const I_multiples:string; const O_output:string; const A_T:TF_DataType):string;
    function AddTopK(const I_input:string; const O_values:string; const O_indices:string; const A_k:cint64; const A_sorted:boolean; const A_T:TF_DataType):string;
    function AddTopKV2(const I_input:string; const I_k:string; const O_values:string; const O_indices:string; const A_sorted:boolean; const A_T:TF_DataType):string;
    function AddTranspose(const I_x:string; const I_perm:string; const O_y:string; const A_T:TF_DataType; const A_Tperm:TF_DataType):string;
    function AddTruncateDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddTruncateMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddTruncatedNormal(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddUniformCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddUnique(const I_x:string; const O_y:string; const O_idx:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
    function AddUniqueWithCounts(const I_x:string; const O_y:string; const O_idx:string; const O_count:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
    function AddUnpack(const I_value:string; const OL_output:TF_StringList; const A_num:cint64; const A_T:TF_DataType; const A_axis:cint64):string;
    function AddUnsortedSegmentMax(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddUnsortedSegmentSum(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddUnstage(const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddVariable(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddVariableV2(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddWhere(const I_input:string; const O_index:string):string;
    function AddWholeFileReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddWholeFileReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddWriteFile(const I_filename:string; const I_contents:string):string;
    function AddZerosLike(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddZeta(const I_x:string; const I_q:string; const O_z:string; const A_T:TF_DataType):string;
    function AddZipDataset(const IL_input_datasets:TF_StringList; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
    end;


// The new Exec<oper> functions, built on top of the short version of ExecOper function, specified in tf_operations

function ExecAbs(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAccumulatorNumAccumulated(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecAccumulatorTakeGradient(const I_handle:TF_TensorPtr; const I_num_required:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_num_required:boolean=false):TF_TensorPtr;
function ExecAcos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAcosh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAdd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecAddManySparseToTensorsMap(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
function ExecAddSparseToTensorsMap(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
function ExecAdjustContrast(const I_images:TF_TensorPtr; const I_contrast_factor:TF_TensorPtr; const I_min_value:TF_TensorPtr; const I_max_value:TF_TensorPtr; const D_images:boolean=false; const D_contrast_factor:boolean=false; const D_min_value:boolean=false; const D_max_value:boolean=false):TF_TensorPtr;
function ExecAdjustContrastv2(const I_images:TF_TensorPtr; const I_contrast_factor:TF_TensorPtr; const D_images:boolean=false; const D_contrast_factor:boolean=false):TF_TensorPtr;
function ExecAdjustHue(const I_images:TF_TensorPtr; const I_delta:TF_TensorPtr; const D_images:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
function ExecAdjustSaturation(const I_images:TF_TensorPtr; const I_scale:TF_TensorPtr; const D_images:boolean=false; const D_scale:boolean=false):TF_TensorPtr;
function ExecAll(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecAny(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecApplyAdadelta(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_accum_update:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_accum_update:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyAdagradDA(const I_var:TF_TensorPtr; const I_gradient_accumulator:TF_TensorPtr; const I_gradient_squared_accumulator:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_global_step:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_gradient_accumulator:boolean=false; const D_gradient_squared_accumulator:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_global_step:boolean=false):TF_TensorPtr;
function ExecApplyAdam(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta1_power:TF_TensorPtr; const I_beta2_power:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_beta1:TF_TensorPtr; const I_beta2:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta1_power:boolean=false; const D_beta2_power:boolean=false; const D_lr:boolean=false; const D_beta1:boolean=false; const D_beta2:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyCenteredRMSProp(const I_var:TF_TensorPtr; const I_mg:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_mg:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyFtrl(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
function ExecApplyFtrlV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_l2_shrinkage:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_l2_shrinkage:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
function ExecApplyGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_delta:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
function ExecApplyMomentum(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_momentum:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_momentum:boolean=false):TF_TensorPtr;
function ExecApplyProximalAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyProximalGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_delta:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
function ExecApplyRMSProp(const I_var:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApproximateEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_tolerance:real; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecArgMax(const I_input:TF_TensorPtr; const I_dimension:TF_TensorPtr; const A_output_type:TF_DataType; const D_input:boolean=false; const D_dimension:boolean=false):TF_TensorPtr;
function ExecArgMin(const I_input:TF_TensorPtr; const I_dimension:TF_TensorPtr; const A_output_type:TF_DataType; const D_input:boolean=false; const D_dimension:boolean=false):TF_TensorPtr;
function ExecAsString(const I_input:TF_TensorPtr; const A_precision:cint64; const A_scientific:boolean; const A_shortest:boolean; const A_width:cint64; const A_fill:string; const D_input:boolean=false):TF_TensorPtr;
function ExecAsin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAsinh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAssign(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_validate_shape:boolean; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecAssignAdd(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecAssignSub(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecAtan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAtan2(const I_y:TF_TensorPtr; const I_x:TF_TensorPtr; const D_y:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecAtanh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAudioSpectrogram(const I_input:TF_TensorPtr; const A_window_size:cint64; const A_stride:cint64; const A_magnitude_squared:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecAudioSummary(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const A_sample_rate:real; const A_max_outputs:cint64; const D_tag:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
function ExecAudioSummaryV2(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const A_max_outputs:cint64; const D_tag:boolean=false; const D_tensor:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
function ExecAvgPool(const I_value:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_value:boolean=false):TF_TensorPtr;
function ExecAvgPool3D(const I_input:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
function ExecAvgPool3DGrad(const I_orig_input_shape:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input_shape:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecAvgPoolGrad(const I_orig_input_shape:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input_shape:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecBarrier(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecBarrierIncompleteSize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecBarrierReadySize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecBatchCholesky(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchCholeskyGrad(const I_l:TF_TensorPtr; const I_grad:TF_TensorPtr; const D_l:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_batch_size:boolean=false):TF_TensorPtr;
function ExecBatchFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchIFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchIFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchIFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchMatMul(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_adj_x:boolean; const A_adj_y:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBatchMatrixBandPart(const I_input:TF_TensorPtr; const I_num_lower:TF_TensorPtr; const I_num_upper:TF_TensorPtr; const D_input:boolean=false; const D_num_lower:boolean=false; const D_num_upper:boolean=false):TF_TensorPtr;
function ExecBatchMatrixDeterminant(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchMatrixDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecBatchMatrixDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchMatrixInverse(const I_input:TF_TensorPtr; const A_adjoint:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchMatrixSetDiag(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecBatchMatrixSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecBatchMatrixSolveLs(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const I_l2_regularizer:TF_TensorPtr; const A_fast:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false; const D_l2_regularizer:boolean=false):TF_TensorPtr;
function ExecBatchMatrixTriangularSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_lower:boolean; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecBatchNormWithGlobalNormalization(const I_t:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta:TF_TensorPtr; const I_gamma:TF_TensorPtr; const A_variance_epsilon:real; const A_scale_after_normalization:boolean; const D_t:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta:boolean=false; const D_gamma:boolean=false):TF_TensorPtr;
function ExecBatchSelfAdjointEig(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchToSpace(const I_input:TF_TensorPtr; const I_crops:TF_TensorPtr; const A_block_size:cint64; const D_input:boolean=false; const D_crops:boolean=false):TF_TensorPtr;
function ExecBatchToSpaceND(const I_input:TF_TensorPtr; const I_block_shape:TF_TensorPtr; const I_crops:TF_TensorPtr; const D_input:boolean=false; const D_block_shape:boolean=false; const D_crops:boolean=false):TF_TensorPtr;
function ExecBetainc(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecBiasAdd(const I_value:TF_TensorPtr; const I_bias:TF_TensorPtr; const A_data_format:string; const D_value:boolean=false; const D_bias:boolean=false):TF_TensorPtr;
function ExecBiasAddGrad(const I_out_backprop:TF_TensorPtr; const A_data_format:string; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecBiasAddV1(const I_value:TF_TensorPtr; const I_bias:TF_TensorPtr; const D_value:boolean=false; const D_bias:boolean=false):TF_TensorPtr;
function ExecBincount(const I_arr:TF_TensorPtr; const I_size:TF_TensorPtr; const I_weights:TF_TensorPtr; const D_arr:boolean=false; const D_size:boolean=false; const D_weights:boolean=false):TF_TensorPtr;
function ExecBitcast(const I_input:TF_TensorPtr; const A_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecBitwiseAnd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBitwiseOr(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBitwiseXor(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBroadcastArgs(const I_s0:TF_TensorPtr; const I_s1:TF_TensorPtr; const D_s0:boolean=false; const D_s1:boolean=false):TF_TensorPtr;
function ExecBucketize(const I_input:TF_TensorPtr; const A_boundaries:TF_FloatList; const D_input:boolean=false):TF_TensorPtr;
function ExecCacheDataset(const I_input_dataset:TF_TensorPtr; const I_filename:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_filename:boolean=false):TF_TensorPtr;
function ExecCast(const I_x:TF_TensorPtr; const A_DstT:TF_DataType; const D_x:boolean=false):TF_TensorPtr;
function ExecCeil(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecCheckNumerics(const I_tensor:TF_TensorPtr; const A_message:string; const D_tensor:boolean=false):TF_TensorPtr;
function ExecCholesky(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecCholeskyGrad(const I_l:TF_TensorPtr; const I_grad:TF_TensorPtr; const D_l:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecComplex(const I_real:TF_TensorPtr; const I_imag:TF_TensorPtr; const A_Tout:TF_DataType; const D_real:boolean=false; const D_imag:boolean=false):TF_TensorPtr;
function ExecComplexAbs(const I_x:TF_TensorPtr; const A_Tout:TF_DataType; const D_x:boolean=false):TF_TensorPtr;
function ExecConcatenateDataset(const I_input_dataset:TF_TensorPtr; const I_another_dataset:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_another_dataset:boolean=false):TF_TensorPtr;
function ExecConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecConj(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecConst(const A_value:TF_TensorPtr; const A_dtype:TF_DataType):TF_TensorPtr;
function ExecConv2D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecConv2DBackpropFilter(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv2DBackpropInput(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv3D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecConv3DBackpropFilter(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv3DBackpropFilterV2(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv3DBackpropInput(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv3DBackpropInputV2(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecCopy(const I_input:TF_TensorPtr; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList; const D_input:boolean=false):TF_TensorPtr;
function ExecCopyHost(const I_input:TF_TensorPtr; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList; const D_input:boolean=false):TF_TensorPtr;
function ExecCos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecCosh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecCountUpTo(const I_ref:TF_TensorPtr; const A_limit:cint64; const D_ref:boolean=false):TF_TensorPtr;
function ExecCropAndResize(const I_image:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const I_crop_size:TF_TensorPtr; const A_method:string; const A_extrapolation_value:real; const D_image:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false; const D_crop_size:boolean=false):TF_TensorPtr;
function ExecCropAndResizeGradBoxes(const I_grads:TF_TensorPtr; const I_image:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const A_method:string; const D_grads:boolean=false; const D_image:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false):TF_TensorPtr;
function ExecCropAndResizeGradImage(const I_grads:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const I_image_size:TF_TensorPtr; const A_T:TF_DataType; const A_method:string; const D_grads:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false; const D_image_size:boolean=false):TF_TensorPtr;
function ExecCross(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecCumprod(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecCumsum(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecDebugIdentity(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecDebugNanCount(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecDebugNumericSummary(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_lower_bound:real; const A_upper_bound:real; const A_mute_if_healthy:boolean; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecDecodeBase64(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecDecodeBmp(const I_contents:TF_TensorPtr; const A_channels:cint64; const D_contents:boolean=false):TF_TensorPtr;
function ExecDecodeGif(const I_contents:TF_TensorPtr; const D_contents:boolean=false):TF_TensorPtr;
function ExecDecodeJSONExample(const I_json_examples:TF_TensorPtr; const D_json_examples:boolean=false):TF_TensorPtr;
function ExecDecodeJpeg(const I_contents:TF_TensorPtr; const A_channels:cint64; const A_ratio:cint64; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string; const D_contents:boolean=false):TF_TensorPtr;
function ExecDecodePng(const I_contents:TF_TensorPtr; const A_channels:cint64; const A_dtype:TF_DataType; const D_contents:boolean=false):TF_TensorPtr;
function ExecDecodeRaw(const I_bytes:TF_TensorPtr; const A_out_type:TF_DataType; const A_little_endian:boolean; const D_bytes:boolean=false):TF_TensorPtr;
function ExecDenseToSparseBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const I_row_shape:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_batch_size:boolean=false; const D_row_shape:boolean=false):TF_TensorPtr;
function ExecDepthToSpace(const I_input:TF_TensorPtr; const A_block_size:cint64; const D_input:boolean=false):TF_TensorPtr;
function ExecDepthwiseConv2dNative(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecDepthwiseConv2dNativeBackpropFilter(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecDepthwiseConv2dNativeBackpropInput(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecDequantize(const I_input:TF_TensorPtr; const I_min_range:TF_TensorPtr; const I_max_range:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_min_range:boolean=false; const D_max_range:boolean=false):TF_TensorPtr;
function ExecDestroyTemporaryVariable(const I_ref:TF_TensorPtr; const A_var_name:string; const D_ref:boolean=false):TF_TensorPtr;
function ExecDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecDigamma(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecDilation2D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecDilation2DBackpropFilter(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecDilation2DBackpropInput(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecDrawBoundingBoxes(const I_images:TF_TensorPtr; const I_boxes:TF_TensorPtr; const D_images:boolean=false; const D_boxes:boolean=false):TF_TensorPtr;
function ExecEditDistance(const I_hypothesis_indices:TF_TensorPtr; const I_hypothesis_values:TF_TensorPtr; const I_hypothesis_shape:TF_TensorPtr; const I_truth_indices:TF_TensorPtr; const I_truth_values:TF_TensorPtr; const I_truth_shape:TF_TensorPtr; const A_normalize:boolean; const D_hypothesis_indices:boolean=false; const D_hypothesis_values:boolean=false; const D_hypothesis_shape:boolean=false; const D_truth_indices:boolean=false; const D_truth_values:boolean=false; const D_truth_shape:boolean=false):TF_TensorPtr;
function ExecElu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecEluGrad(const I_gradients:TF_TensorPtr; const I_outputs:TF_TensorPtr; const D_gradients:boolean=false; const D_outputs:boolean=false):TF_TensorPtr;
function ExecEncodeBase64(const I_input:TF_TensorPtr; const A_pad:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecEncodeJpeg(const I_image:TF_TensorPtr; const A_format:string; const A_quality:cint64; const A_progressive:boolean; const A_optimize_size:boolean; const A_chroma_downsampling:boolean; const A_density_unit:string; const A_x_density:cint64; const A_y_density:cint64; const A_xmp_metadata:string; const D_image:boolean=false):TF_TensorPtr;
function ExecEncodePng(const I_image:TF_TensorPtr; const A_compression:cint64; const D_image:boolean=false):TF_TensorPtr;
function ExecEncodeWav(const I_audio:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const D_audio:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
function ExecEnter(const I_data:TF_TensorPtr; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64; const D_data:boolean=false):TF_TensorPtr;
function ExecEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecErf(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecErfc(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecExit(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
function ExecExp(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecExpandDims(const I_input:TF_TensorPtr; const I_dim:TF_TensorPtr; const D_input:boolean=false; const D_dim:boolean=false):TF_TensorPtr;
function ExecExpm1(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecExtractGlimpse(const I_input:TF_TensorPtr; const I_size:TF_TensorPtr; const I_offsets:TF_TensorPtr; const A_centered:boolean; const A_normalized:boolean; const A_uniform_noise:boolean; const D_input:boolean=false; const D_size:boolean=false; const D_offsets:boolean=false):TF_TensorPtr;
function ExecExtractImagePatches(const I_images:TF_TensorPtr; const A_ksizes:TF_IntList; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string; const D_images:boolean=false):TF_TensorPtr;
function ExecFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecFIFOQueue(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecFIFOQueueV2(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecFact():TF_TensorPtr;
function ExecFakeQuantWithMinMaxArgs(const I_inputs:TF_TensorPtr; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean; const D_inputs:boolean=false):TF_TensorPtr;
function ExecFakeQuantWithMinMaxArgsGradient(const I_gradients:TF_TensorPtr; const I_inputs:TF_TensorPtr; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean; const D_gradients:boolean=false; const D_inputs:boolean=false):TF_TensorPtr;
function ExecFakeQuantWithMinMaxVars(const I_inputs:TF_TensorPtr; const I_min:TF_TensorPtr; const I_max:TF_TensorPtr; const A_num_bits:cint64; const A_narrow_range:boolean; const D_inputs:boolean=false; const D_min:boolean=false; const D_max:boolean=false):TF_TensorPtr;
function ExecFakeQuantWithMinMaxVarsPerChannel(const I_inputs:TF_TensorPtr; const I_min:TF_TensorPtr; const I_max:TF_TensorPtr; const A_num_bits:cint64; const A_narrow_range:boolean; const D_inputs:boolean=false; const D_min:boolean=false; const D_max:boolean=false):TF_TensorPtr;
function ExecFakeQueue(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
function ExecFill(const I_dims:TF_TensorPtr; const I_value:TF_TensorPtr; const D_dims:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecFixedLengthRecordDataset(const I_filenames:TF_TensorPtr; const I_header_bytes:TF_TensorPtr; const I_record_bytes:TF_TensorPtr; const I_footer_bytes:TF_TensorPtr; const D_filenames:boolean=false; const D_header_bytes:boolean=false; const D_record_bytes:boolean=false; const D_footer_bytes:boolean=false):TF_TensorPtr;
function ExecFixedLengthRecordReader(const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecFixedLengthRecordReaderV2(const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string; const A_encoding:string):TF_TensorPtr;
function ExecFloor(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecFloorDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecFloorMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecFractionalAvgPoolGrad(const I_orig_input_tensor_shape:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const I_row_pooling_sequence:TF_TensorPtr; const I_col_pooling_sequence:TF_TensorPtr; const A_overlapping:boolean; const D_orig_input_tensor_shape:boolean=false; const D_out_backprop:boolean=false; const D_row_pooling_sequence:boolean=false; const D_col_pooling_sequence:boolean=false):TF_TensorPtr;
function ExecFractionalMaxPoolGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const I_row_pooling_sequence:TF_TensorPtr; const I_col_pooling_sequence:TF_TensorPtr; const A_overlapping:boolean; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_out_backprop:boolean=false; const D_row_pooling_sequence:boolean=false; const D_col_pooling_sequence:boolean=false):TF_TensorPtr;
function ExecFusedPadConv2D(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_mode:string; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_paddings:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecFusedResizeAndPadConv2D(const I_input:TF_TensorPtr; const I_size:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_resize_align_corners:boolean; const A_mode:string; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_size:boolean=false; const D_paddings:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecGather(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_validate_indices:boolean; const D_params:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecGatherNd(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const D_params:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecGatherV2(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_axis:TF_TensorPtr; const D_params:boolean=false; const D_indices:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecGetSessionHandle(const I_value:TF_TensorPtr; const D_value:boolean=false):TF_TensorPtr;
function ExecGetSessionHandleV2(const I_value:TF_TensorPtr; const D_value:boolean=false):TF_TensorPtr;
function ExecGetSessionTensor(const I_handle:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
function ExecGreater(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecGreaterEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecHSVToRGB(const I_images:TF_TensorPtr; const D_images:boolean=false):TF_TensorPtr;
function ExecHashTable(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
function ExecHashTableV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
function ExecHistogramSummary(const I_tag:TF_TensorPtr; const I_values:TF_TensorPtr; const D_tag:boolean=false; const D_values:boolean=false):TF_TensorPtr;
function ExecIFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecIFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecIFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecIRFFT(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecIRFFT2D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecIRFFT3D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecIdentityReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecIdentityReaderV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecIgamma(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecIgammac(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecIgnoreErrorsDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecImag(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecImageSummary(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const A_max_images:cint64; const A_bad_color:TF_TensorPtr; const D_tag:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
function ExecImmutableConst(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_memory_region_name:string):TF_TensorPtr;
function ExecInTopK(const I_predictions:TF_TensorPtr; const I_targets:TF_TensorPtr; const A_k:cint64; const D_predictions:boolean=false; const D_targets:boolean=false):TF_TensorPtr;
function ExecInv(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecInvGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecInvert(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecInvertPermutation(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecIsFinite(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecIsInf(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecIsNan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecIsVariableInitialized(const I_ref:TF_TensorPtr; const D_ref:boolean=false):TF_TensorPtr;
function ExecIterator(const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):TF_TensorPtr;
function ExecIteratorFromStringHandle(const I_string_handle:TF_TensorPtr; const D_string_handle:boolean=false):TF_TensorPtr;
function ExecIteratorToStringHandle(const I_resource_handle:TF_TensorPtr; const D_resource_handle:boolean=false):TF_TensorPtr;
function ExecL2Loss(const I_t:TF_TensorPtr; const D_t:boolean=false):TF_TensorPtr;
function ExecLMDBReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecLRN(const I_input:TF_TensorPtr; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const D_input:boolean=false):TF_TensorPtr;
function ExecLRNGrad(const I_input_grads:TF_TensorPtr; const I_input_image:TF_TensorPtr; const I_output_image:TF_TensorPtr; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const D_input_grads:boolean=false; const D_input_image:boolean=false; const D_output_image:boolean=false):TF_TensorPtr;
function ExecLess(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLessEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLgamma(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecLinSpace(const I_start:TF_TensorPtr; const I_stop:TF_TensorPtr; const I_num:TF_TensorPtr; const D_start:boolean=false; const D_stop:boolean=false; const D_num:boolean=false):TF_TensorPtr;
function ExecLog(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecLog1p(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecLogSoftmax(const I_logits:TF_TensorPtr; const D_logits:boolean=false):TF_TensorPtr;
function ExecLogicalAnd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLogicalNot(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecLogicalOr(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLookupTableFind(const I_table_handle:TF_TensorPtr; const I_keys:TF_TensorPtr; const I_default_value:TF_TensorPtr; const D_table_handle:boolean=false; const D_keys:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
function ExecLookupTableFindV2(const I_table_handle:TF_TensorPtr; const I_keys:TF_TensorPtr; const I_default_value:TF_TensorPtr; const D_table_handle:boolean=false; const D_keys:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
function ExecLookupTableSize(const I_table_handle:TF_TensorPtr; const D_table_handle:boolean=false):TF_TensorPtr;
function ExecLookupTableSizeV2(const I_table_handle:TF_TensorPtr; const D_table_handle:boolean=false):TF_TensorPtr;
function ExecLoopCond(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecMapIncompleteSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecMapSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecMatchingFiles(const I_pattern:TF_TensorPtr; const D_pattern:boolean=false):TF_TensorPtr;
function ExecMatrixBandPart(const I_input:TF_TensorPtr; const I_num_lower:TF_TensorPtr; const I_num_upper:TF_TensorPtr; const D_input:boolean=false; const D_num_lower:boolean=false; const D_num_upper:boolean=false):TF_TensorPtr;
function ExecMatrixDeterminant(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecMatrixDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixInverse(const I_input:TF_TensorPtr; const A_adjoint:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixSetDiag(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecMatrixSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecMatrixSolveLs(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const I_l2_regularizer:TF_TensorPtr; const A_fast:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false; const D_l2_regularizer:boolean=false):TF_TensorPtr;
function ExecMatrixTriangularSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_lower:boolean; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecMax(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecMaxPool(const I_input:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
function ExecMaxPool3D(const I_input:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
function ExecMaxPool3DGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecMaxPool3DGradGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecMaxPoolGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecMaxPoolGradGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecMaxPoolGradGradWithArgmax(const I_input:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_argmax:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_grad:boolean=false; const D_argmax:boolean=false):TF_TensorPtr;
function ExecMaxPoolGradWithArgmax(const I_input:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_argmax:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_grad:boolean=false; const D_argmax:boolean=false):TF_TensorPtr;
function ExecMaximum(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecMean(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecMfcc(const I_spectrogram:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const A_upper_frequency_limit:real; const A_lower_frequency_limit:real; const A_filterbank_channel_count:cint64; const A_dct_coefficient_count:cint64; const D_spectrogram:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
function ExecMin(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecMinimum(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecMirrorPad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecMirrorPadGrad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecMul(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecMultinomial(const I_logits:TF_TensorPtr; const I_num_samples:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_logits:boolean=false; const D_num_samples:boolean=false):TF_TensorPtr;
function ExecMutableDenseHashTable(const I_empty_key:TF_TensorPtr; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real; const D_empty_key:boolean=false):TF_TensorPtr;
function ExecMutableDenseHashTableV2(const I_empty_key:TF_TensorPtr; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real; const D_empty_key:boolean=false):TF_TensorPtr;
function ExecMutableHashTable(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
function ExecMutableHashTableOfTensors(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):TF_TensorPtr;
function ExecMutableHashTableOfTensorsV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):TF_TensorPtr;
function ExecMutableHashTableV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
function ExecNeg(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecNextIteration(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
function ExecNonMaxSuppression(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const A_iou_threshold:real; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false):TF_TensorPtr;
function ExecNonMaxSuppressionV2(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const I_iou_threshold:TF_TensorPtr; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false; const D_iou_threshold:boolean=false):TF_TensorPtr;
function ExecNotEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecOneHot(const I_indices:TF_TensorPtr; const I_depth:TF_TensorPtr; const I_on_value:TF_TensorPtr; const I_off_value:TF_TensorPtr; const A_axis:cint64; const D_indices:boolean=false; const D_depth:boolean=false; const D_on_value:boolean=false; const D_off_value:boolean=false):TF_TensorPtr;
function ExecOneShotIterator(const A_dataset_factory:TF_Function; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecOnesLike(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecOrderedMapIncompleteSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecOrderedMapSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecPad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecPadV2(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_constant_values:TF_TensorPtr; const D_input:boolean=false; const D_paddings:boolean=false; const D_constant_values:boolean=false):TF_TensorPtr;
function ExecPaddingFIFOQueue(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecPaddingFIFOQueueV2(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecParameterizedTruncatedNormal(const I_shape:TF_TensorPtr; const I_means:TF_TensorPtr; const I_stdevs:TF_TensorPtr; const I_minvals:TF_TensorPtr; const I_maxvals:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_shape:boolean=false; const D_means:boolean=false; const D_stdevs:boolean=false; const D_minvals:boolean=false; const D_maxvals:boolean=false):TF_TensorPtr;
function ExecParseTensor(const I_serialized:TF_TensorPtr; const A_out_type:TF_DataType; const D_serialized:boolean=false):TF_TensorPtr;
function ExecPlaceholder(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
function ExecPlaceholderV2(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
function ExecPlaceholderWithDefault(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const D_input:boolean=false):TF_TensorPtr;
function ExecPolygamma(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecPow(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecPreventGradient(const I_input:TF_TensorPtr; const A_message:string; const D_input:boolean=false):TF_TensorPtr;
function ExecPriorityQueue(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecPriorityQueueV2(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecProd(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecQuantizeAndDequantize(const I_input:TF_TensorPtr; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_input_min:real; const A_input_max:real; const D_input:boolean=false):TF_TensorPtr;
function ExecQuantizeAndDequantizeV2(const I_input:TF_TensorPtr; const I_input_min:TF_TensorPtr; const I_input_max:TF_TensorPtr; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const D_input:boolean=false; const D_input_min:boolean=false; const D_input_max:boolean=false):TF_TensorPtr;
function ExecQuantizeAndDequantizeV3(const I_input:TF_TensorPtr; const I_input_min:TF_TensorPtr; const I_input_max:TF_TensorPtr; const I_num_bits:TF_TensorPtr; const A_signed_input:boolean; const A_range_given:boolean; const D_input:boolean=false; const D_input_min:boolean=false; const D_input_max:boolean=false; const D_num_bits:boolean=false):TF_TensorPtr;
function ExecQueueIsClosed(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecQueueIsClosedV2(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecQueueSize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecQueueSizeV2(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecRFFT(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecRFFT2D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecRFFT3D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecRGBToHSV(const I_images:TF_TensorPtr; const D_images:boolean=false):TF_TensorPtr;
function ExecRandomCrop(const I_image:TF_TensorPtr; const I_size:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_image:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecRandomGamma(const I_shape:TF_TensorPtr; const I_alpha:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_shape:boolean=false; const D_alpha:boolean=false):TF_TensorPtr;
function ExecRandomPoisson(const I_shape:TF_TensorPtr; const I_rate:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_shape:boolean=false; const D_rate:boolean=false):TF_TensorPtr;
function ExecRandomShuffle(const I_value:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_value:boolean=false):TF_TensorPtr;
function ExecRandomShuffleQueue(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecRandomShuffleQueueV2(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecRandomStandardNormal(const I_shape:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
function ExecRandomUniform(const I_shape:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
function ExecRandomUniformInt(const I_shape:TF_TensorPtr; const I_minval:TF_TensorPtr; const I_maxval:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_shape:boolean=false; const D_minval:boolean=false; const D_maxval:boolean=false):TF_TensorPtr;
function ExecRange(const I_start:TF_TensorPtr; const I_limit:TF_TensorPtr; const I_delta:TF_TensorPtr; const D_start:boolean=false; const D_limit:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
function ExecRangeDataset(const I_start:TF_TensorPtr; const I_stop:TF_TensorPtr; const I_step:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_start:boolean=false; const D_stop:boolean=false; const D_step:boolean=false):TF_TensorPtr;
function ExecRank(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecReadFile(const I_filename:TF_TensorPtr; const D_filename:boolean=false):TF_TensorPtr;
function ExecReaderNumRecordsProduced(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderNumRecordsProducedV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderNumWorkUnitsCompleted(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderNumWorkUnitsCompletedV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderSerializeState(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderSerializeStateV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReal(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecRealDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecReciprocal(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecReciprocalGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecRecordInput(const A_file_pattern:string; const A_file_random_seed:cint64; const A_file_shuffle_shift_ratio:real; const A_file_buffer_size:cint64; const A_file_parallelism:cint64; const A_batch_size:cint64):TF_TensorPtr;
function ExecReduceJoin(const I_inputs:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const A_separator:string; const D_inputs:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecRefEnter(const I_data:TF_TensorPtr; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64; const D_data:boolean=false):TF_TensorPtr;
function ExecRefExit(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
function ExecRefIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecRefNextIteration(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
function ExecRelu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecRelu6(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecRelu6Grad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecReluGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecRepeatDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
function ExecReshape(const I_tensor:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_tensor:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecResizeArea(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResizeBicubic(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResizeBilinear(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResizeBilinearGrad(const I_grads:TF_TensorPtr; const I_original_image:TF_TensorPtr; const A_align_corners:boolean; const D_grads:boolean=false; const D_original_image:boolean=false):TF_TensorPtr;
function ExecResizeNearestNeighbor(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResizeNearestNeighborGrad(const I_grads:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_grads:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecRestore(const I_file_pattern:TF_TensorPtr; const I_tensor_name:TF_TensorPtr; const A_dt:TF_DataType; const A_preferred_shard:cint64; const D_file_pattern:boolean=false; const D_tensor_name:boolean=false):TF_TensorPtr;
function ExecRestoreSlice(const I_file_pattern:TF_TensorPtr; const I_tensor_name:TF_TensorPtr; const I_shape_and_slice:TF_TensorPtr; const A_dt:TF_DataType; const A_preferred_shard:cint64; const D_file_pattern:boolean=false; const D_tensor_name:boolean=false; const D_shape_and_slice:boolean=false):TF_TensorPtr;
function ExecReverse(const I_tensor:TF_TensorPtr; const I_dims:TF_TensorPtr; const D_tensor:boolean=false; const D_dims:boolean=false):TF_TensorPtr;
function ExecReverseSequence(const I_input:TF_TensorPtr; const I_seq_lengths:TF_TensorPtr; const A_seq_dim:cint64; const A_batch_dim:cint64; const D_input:boolean=false; const D_seq_lengths:boolean=false):TF_TensorPtr;
function ExecReverseV2(const I_tensor:TF_TensorPtr; const I_axis:TF_TensorPtr; const D_tensor:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecRint(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecRound(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecRsqrt(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecRsqrtGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecScalarSummary(const I_tags:TF_TensorPtr; const I_values:TF_TensorPtr; const D_tags:boolean=false; const D_values:boolean=false):TF_TensorPtr;
function ExecScatterAdd(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterDiv(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterMul(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterNd(const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_indices:boolean=false; const D_updates:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecScatterNdAdd(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterNdNonAliasingAdd(const I_input:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_input:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterNdSub(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterNdUpdate(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterSub(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterUpdate(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecSdcaFprint(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecSegmentMax(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSegmentMean(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSegmentMin(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSegmentProd(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSegmentSum(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSelect(const I_condition:TF_TensorPtr; const I_t:TF_TensorPtr; const I_e:TF_TensorPtr; const D_condition:boolean=false; const D_t:boolean=false; const D_e:boolean=false):TF_TensorPtr;
function ExecSelfAdjointEig(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecSerializeManySparse(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
function ExecSerializeSparse(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
function ExecSetSize(const I_set_indices:TF_TensorPtr; const I_set_values:TF_TensorPtr; const I_set_shape:TF_TensorPtr; const A_validate_indices:boolean; const D_set_indices:boolean=false; const D_set_values:boolean=false; const D_set_shape:boolean=false):TF_TensorPtr;
function ExecShape(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecShardedFilename(const I_basename:TF_TensorPtr; const I_shard:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const D_basename:boolean=false; const D_shard:boolean=false; const D_num_shards:boolean=false):TF_TensorPtr;
function ExecShardedFilespec(const I_basename:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const D_basename:boolean=false; const D_num_shards:boolean=false):TF_TensorPtr;
function ExecShuffleDataset(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
function ExecSigmoid(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSigmoidGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecSign(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSinh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSize(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecSkipDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
function ExecSlice(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_size:TF_TensorPtr; const D_input:boolean=false; const D_begin:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecSoftmax(const I_logits:TF_TensorPtr; const D_logits:boolean=false):TF_TensorPtr;
function ExecSoftplus(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecSoftplusGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecSoftsign(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecSoftsignGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecSpaceToBatch(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_block_size:cint64; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecSpaceToBatchND(const I_input:TF_TensorPtr; const I_block_shape:TF_TensorPtr; const I_paddings:TF_TensorPtr; const D_input:boolean=false; const D_block_shape:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecSpaceToDepth(const I_input:TF_TensorPtr; const A_block_size:cint64; const D_input:boolean=false):TF_TensorPtr;
function ExecSparseApplyAdadelta(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_accum_update:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_accum_update:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyAdagradDA(const I_var:TF_TensorPtr; const I_gradient_accumulator:TF_TensorPtr; const I_gradient_squared_accumulator:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_global_step:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_gradient_accumulator:boolean=false; const D_gradient_squared_accumulator:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_global_step:boolean=false):TF_TensorPtr;
function ExecSparseApplyCenteredRMSProp(const I_var:TF_TensorPtr; const I_mg:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_mg:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyFtrl(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
function ExecSparseApplyFtrlV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_l2_shrinkage:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_l2_shrinkage:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
function ExecSparseApplyMomentum(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_momentum:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_momentum:boolean=false):TF_TensorPtr;
function ExecSparseApplyProximalAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyProximalGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyRMSProp(const I_var:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecSparseDenseCwiseAdd(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
function ExecSparseDenseCwiseDiv(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
function ExecSparseDenseCwiseMul(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
function ExecSparseMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_a_is_sparse:boolean; const A_b_is_sparse:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseReduceMax(const I_input_indices:TF_TensorPtr; const I_input_values:TF_TensorPtr; const I_input_shape:TF_TensorPtr; const I_reduction_axes:TF_TensorPtr; const A_keep_dims:boolean; const D_input_indices:boolean=false; const D_input_values:boolean=false; const D_input_shape:boolean=false; const D_reduction_axes:boolean=false):TF_TensorPtr;
function ExecSparseReduceSum(const I_input_indices:TF_TensorPtr; const I_input_values:TF_TensorPtr; const I_input_shape:TF_TensorPtr; const I_reduction_axes:TF_TensorPtr; const A_keep_dims:boolean; const D_input_indices:boolean=false; const D_input_values:boolean=false; const D_input_shape:boolean=false; const D_reduction_axes:boolean=false):TF_TensorPtr;
function ExecSparseSegmentMean(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSparseSegmentMeanGrad(const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_output_dim0:TF_TensorPtr; const D_grad:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_output_dim0:boolean=false):TF_TensorPtr;
function ExecSparseSegmentSqrtN(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSparseSegmentSqrtNGrad(const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_output_dim0:TF_TensorPtr; const D_grad:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_output_dim0:boolean=false):TF_TensorPtr;
function ExecSparseSegmentSum(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSparseSoftmax(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false):TF_TensorPtr;
function ExecSparseTensorDenseAdd(const I_a_indices:TF_TensorPtr; const I_a_values:TF_TensorPtr; const I_a_shape:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a_indices:boolean=false; const D_a_values:boolean=false; const D_a_shape:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseTensorDenseMatMul(const I_a_indices:TF_TensorPtr; const I_a_values:TF_TensorPtr; const I_a_shape:TF_TensorPtr; const I_b:TF_TensorPtr; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const D_a_indices:boolean=false; const D_a_values:boolean=false; const D_a_shape:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseTensorSliceDataset(const I_indices:TF_TensorPtr; const I_values:TF_TensorPtr; const I_dense_shape:TF_TensorPtr; const D_indices:boolean=false; const D_values:boolean=false; const D_dense_shape:boolean=false):TF_TensorPtr;
function ExecSparseToDense(const I_sparse_indices:TF_TensorPtr; const I_output_shape:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_default_value:TF_TensorPtr; const A_validate_indices:boolean; const D_sparse_indices:boolean=false; const D_output_shape:boolean=false; const D_sparse_values:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
function ExecSqrt(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSqrtGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecSquare(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSquaredDifference(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecSqueeze(const I_input:TF_TensorPtr; const A_squeeze_dims:TF_IntList; const D_input:boolean=false):TF_TensorPtr;
function ExecStack(const A_elem_type:TF_DataType; const A_stack_name:string):TF_TensorPtr;
function ExecStackPop(const I_handle:TF_TensorPtr; const A_elem_type:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
function ExecStackPopV2(const I_handle:TF_TensorPtr; const A_elem_type:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
function ExecStackPush(const I_handle:TF_TensorPtr; const I_elem:TF_TensorPtr; const A_swap_memory:boolean; const D_handle:boolean=false; const D_elem:boolean=false):TF_TensorPtr;
function ExecStackPushV2(const I_handle:TF_TensorPtr; const I_elem:TF_TensorPtr; const A_swap_memory:boolean; const D_handle:boolean=false; const D_elem:boolean=false):TF_TensorPtr;
function ExecStackV2(const I_max_size:TF_TensorPtr; const A_elem_type:TF_DataType; const A_stack_name:string; const D_max_size:boolean=false):TF_TensorPtr;
function ExecStageSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecStatelessRandomNormal(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
function ExecStatelessRandomUniform(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
function ExecStatelessTruncatedNormal(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
function ExecStopGradient(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecStridedSlice(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64; const D_input:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
function ExecStridedSliceAssign(const I_ref:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_value:TF_TensorPtr; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64; const D_ref:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecStridedSliceGrad(const I_shape:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_dy:TF_TensorPtr; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64; const D_shape:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
function ExecStringToHashBucket(const I_string_tensor:TF_TensorPtr; const A_num_buckets:cint64; const D_string_tensor:boolean=false):TF_TensorPtr;
function ExecStringToHashBucketFast(const I_input:TF_TensorPtr; const A_num_buckets:cint64; const D_input:boolean=false):TF_TensorPtr;
function ExecStringToHashBucketStrong(const I_input:TF_TensorPtr; const A_num_buckets:cint64; const A_key:TF_IntList; const D_input:boolean=false):TF_TensorPtr;
function ExecStringToNumber(const I_string_tensor:TF_TensorPtr; const A_out_type:TF_DataType; const D_string_tensor:boolean=false):TF_TensorPtr;
function ExecSub(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecSubstr(const I_input:TF_TensorPtr; const I_pos:TF_TensorPtr; const I_len:TF_TensorPtr; const D_input:boolean=false; const D_pos:boolean=false; const D_len:boolean=false):TF_TensorPtr;
function ExecSum(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecTFRecordDataset(const I_filenames:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const D_filenames:boolean=false; const D_compression_type:boolean=false):TF_TensorPtr;
function ExecTFRecordReader(const A_container:string; const A_shared_name:string; const A_compression_type:string):TF_TensorPtr;
function ExecTFRecordReaderV2(const A_container:string; const A_shared_name:string; const A_compression_type:string):TF_TensorPtr;
function ExecTakeDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
function ExecTan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecTanh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecTanhGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecTemporaryVariable(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_var_name:string):TF_TensorPtr;
function ExecTensorArray(const I_size:TF_TensorPtr; const A_dtype:TF_DataType; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const A_element_shape:TF_Shape; const D_size:boolean=false):TF_TensorPtr;
function ExecTensorArrayGather(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayGatherV2(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayGatherV3(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayGrad(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_source:string; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayGradV2(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_source:string; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayPack(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayRead(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayReadV2(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayReadV3(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayScatter(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayScatterV2(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayScatterV3(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySize(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySizeV2(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySizeV3(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySplit(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySplitV2(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySplitV3(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayUnpack(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayV2(const I_size:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const D_size:boolean=false):TF_TensorPtr;
function ExecTensorArrayWrite(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayWriteV2(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayWriteV3(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorSummary(const I_tensor:TF_TensorPtr; const A_description:string; const A_labels:TF_StringList; const A_display_name:string; const D_tensor:boolean=false):TF_TensorPtr;
function ExecTensorSummaryV2(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_serialized_summary_metadata:TF_TensorPtr; const D_tag:boolean=false; const D_tensor:boolean=false; const D_serialized_summary_metadata:boolean=false):TF_TensorPtr;
function ExecTextLineDataset(const I_filenames:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const D_filenames:boolean=false; const D_compression_type:boolean=false):TF_TensorPtr;
function ExecTextLineReader(const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecTextLineReaderV2(const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecTile(const I_input:TF_TensorPtr; const I_multiples:TF_TensorPtr; const D_input:boolean=false; const D_multiples:boolean=false):TF_TensorPtr;
function ExecTileGrad(const I_input:TF_TensorPtr; const I_multiples:TF_TensorPtr; const D_input:boolean=false; const D_multiples:boolean=false):TF_TensorPtr;
function ExecTranspose(const I_x:TF_TensorPtr; const I_perm:TF_TensorPtr; const D_x:boolean=false; const D_perm:boolean=false):TF_TensorPtr;
function ExecTruncateDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecTruncateMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecTruncatedNormal(const I_shape:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
function ExecUnsortedSegmentMax(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecUnsortedSegmentSum(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecVariable(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecVariableV2(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecWhere(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecWholeFileReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecWholeFileReaderV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecZerosLike(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecZeta(const I_x:TF_TensorPtr; const I_q:TF_TensorPtr; const D_x:boolean=false; const D_q:boolean=false):TF_TensorPtr;


implementation

//  The TGraphExt methods
function TGraphExt.AddAbort(const A_error_msg:string; const A_exit_without_error:boolean):string;
  begin
  result:=AddOper('Abort',[],[],[],['error_msg','exit_without_error'],['string','bool'],[@A_error_msg,@A_exit_without_error])
  end;
function TGraphExt.AddAbs(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Abs',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('AccumulatorApplyGradient',[I_handle,I_local_step,I_gradient],[],[],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddAccumulatorNumAccumulated(const I_handle:string; const O_num_accumulated:string):string;
  begin
  result:=AddOper('AccumulatorNumAccumulated',[I_handle],[],[O_num_accumulated],[],[],[])
  end;
function TGraphExt.AddAccumulatorSetGlobalStep(const I_handle:string; const I_new_global_step:string):string;
  begin
  result:=AddOper('AccumulatorSetGlobalStep',[I_handle,I_new_global_step],[],[],[],[],[])
  end;
function TGraphExt.AddAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_average:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('AccumulatorTakeGradient',[I_handle,I_num_required],[],[O_average],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddAcos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Acos',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAcosh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Acosh',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAdd(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Add',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAddManySparseToTensorsMap(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_sparse_handles:string; const A_T:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('AddManySparseToTensorsMap',[I_sparse_indices,I_sparse_values,I_sparse_shape],[],[O_sparse_handles],['T','container','shared_name'],['type','string','string'],[@A_T,@A_container,@A_shared_name])
  end;
function TGraphExt.AddAddN(const IL_inputs:TF_StringList; const O_sum:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AddN',[],[IL_inputs],[O_sum],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddAddSparseToTensorsMap(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_sparse_handle:string; const A_T:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('AddSparseToTensorsMap',[I_sparse_indices,I_sparse_values,I_sparse_shape],[],[O_sparse_handle],['T','container','shared_name'],['type','string','string'],[@A_T,@A_container,@A_shared_name])
  end;
function TGraphExt.AddAdjustContrast(const I_images:string; const I_contrast_factor:string; const I_min_value:string; const I_max_value:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AdjustContrast',[I_images,I_contrast_factor,I_min_value,I_max_value],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAdjustContrastv2(const I_images:string; const I_contrast_factor:string; const O_output:string):string;
  begin
  result:=AddOper('AdjustContrastv2',[I_images,I_contrast_factor],[],[O_output],[],[],[])
  end;
function TGraphExt.AddAdjustHue(const I_images:string; const I_delta:string; const O_output:string):string;
  begin
  result:=AddOper('AdjustHue',[I_images,I_delta],[],[O_output],[],[],[])
  end;
function TGraphExt.AddAdjustSaturation(const I_images:string; const I_scale:string; const O_output:string):string;
  begin
  result:=AddOper('AdjustSaturation',[I_images,I_scale],[],[O_output],[],[],[])
  end;
function TGraphExt.AddAll(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('All',[I_input,I_reduction_indices],[],[O_output],['keep_dims','Tidx'],['bool','type'],[@A_keep_dims,@A_Tidx])
  end;
function TGraphExt.AddAllCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('AllCandidateSampler',[I_true_classes],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','seed','seed2'],['int','int','bool','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_seed,@A_seed2])
  end;
function TGraphExt.AddAny(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Any',[I_input,I_reduction_indices],[],[O_output],['keep_dims','Tidx'],['bool','type'],[@A_keep_dims,@A_Tidx])
  end;
function TGraphExt.AddApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyAdagrad',[I_var,I_accum,I_lr,I_grad],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_lr,I_l1,I_l2,I_global_step],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyAdam(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ApplyAdam',[I_var,I_m,I_v,I_beta1_power,I_beta2_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],[],[O_out],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyDelayCompensatedGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const I_lambda:string; const I_shadow:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyDelayCompensatedGradientDescent',[I_var,I_alpha,I_delta,I_lambda,I_shadow],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_lr_power],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyGradientDescent',[I_var,I_alpha,I_delta],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_momentum],[],[O_out],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_delta:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_delta],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApproximateEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType; const A_tolerance:real):string;
  begin
  result:=AddOper('ApproximateEqual',[I_x,I_y],[],[O_z],['T','tolerance'],['type','float'],[@A_T,@A_tolerance])
  end;
function TGraphExt.AddArgMax(const I_input:string; const I_dimension:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_output_type:TF_DataType):string;
  begin
  result:=AddOper('ArgMax',[I_input,I_dimension],[],[O_output],['T','Tidx','output_type'],['type','type','type'],[@A_T,@A_Tidx,@A_output_type])
  end;
function TGraphExt.AddArgMin(const I_input:string; const I_dimension:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_output_type:TF_DataType):string;
  begin
  result:=AddOper('ArgMin',[I_input,I_dimension],[],[O_output],['T','Tidx','output_type'],['type','type','type'],[@A_T,@A_Tidx,@A_output_type])
  end;
function TGraphExt.AddAsString(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_precision:cint64; const A_scientific:boolean; const A_shortest:boolean; const A_width:cint64; const A_fill:string):string;
  begin
  result:=AddOper('AsString',[I_input],[],[O_output],['T','precision','scientific','shortest','width','fill'],['type','int','bool','bool','int','string'],[@A_T,@A_precision,@A_scientific,@A_shortest,@A_width,@A_fill])
  end;
function TGraphExt.AddAsin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Asin',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAsinh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Asinh',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAssert(const I_condition:string; const IL_data:TF_StringList; const A_T:TF_TypeList; const A_summarize:cint64):string;
  begin
  result:=AddOper('Assert',[I_condition],[IL_data],[],['T','summarize'],['list(type)','int'],[@A_T,@A_summarize])
  end;
function TGraphExt.AddAssign(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_validate_shape:boolean; const A_use_locking:boolean):string;
  begin
  result:=AddOper('Assign',[I_ref,I_value],[],[O_output_ref],['T','validate_shape','use_locking'],['type','bool','bool'],[@A_T,@A_validate_shape,@A_use_locking])
  end;
function TGraphExt.AddAssignAdd(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('AssignAdd',[I_ref,I_value],[],[O_output_ref],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddAssignSub(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('AssignSub',[I_ref,I_value],[],[O_output_ref],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddAtan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Atan',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAtan2(const I_y:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Atan2',[I_y,I_x],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAtanh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Atanh',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAudioSpectrogram(const I_input:string; const O_spectrogram:string; const A_window_size:cint64; const A_stride:cint64; const A_magnitude_squared:boolean):string;
  begin
  result:=AddOper('AudioSpectrogram',[I_input],[],[O_spectrogram],['window_size','stride','magnitude_squared'],['int','int','bool'],[@A_window_size,@A_stride,@A_magnitude_squared])
  end;
function TGraphExt.AddAudioSummary(const I_tag:string; const I_tensor:string; const O_summary:string; const A_sample_rate:real; const A_max_outputs:cint64):string;
  begin
  result:=AddOper('AudioSummary',[I_tag,I_tensor],[],[O_summary],['sample_rate','max_outputs'],['float','int'],[@A_sample_rate,@A_max_outputs])
  end;
function TGraphExt.AddAudioSummaryV2(const I_tag:string; const I_tensor:string; const I_sample_rate:string; const O_summary:string; const A_max_outputs:cint64):string;
  begin
  result:=AddOper('AudioSummaryV2',[I_tag,I_tensor,I_sample_rate],[],[O_summary],['max_outputs'],['int'],[@A_max_outputs])
  end;
function TGraphExt.AddAvgPool(const I_value:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AvgPool',[I_value],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddAvgPool3D(const I_input:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AvgPool3D',[I_input],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddAvgPool3DGrad(const I_orig_input_shape:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AvgPool3DGrad',[I_orig_input_shape,I_grad],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddAvgPoolGrad(const I_orig_input_shape:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AvgPoolGrad',[I_orig_input_shape,I_grad],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddBarrier(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('Barrier',[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddBarrierClose(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
  begin
  result:=AddOper('BarrierClose',[I_handle],[],[],['cancel_pending_enqueues'],['bool'],[@A_cancel_pending_enqueues])
  end;
function TGraphExt.AddBarrierIncompleteSize(const I_handle:string; const O_size:string):string;
  begin
  result:=AddOper('BarrierIncompleteSize',[I_handle],[],[O_size],[],[],[])
  end;
function TGraphExt.AddBarrierInsertMany(const I_handle:string; const I_keys:string; const I_values:string; const A_T:TF_DataType; const A_component_index:cint64):string;
  begin
  result:=AddOper('BarrierInsertMany',[I_handle,I_keys,I_values],[],[],['T','component_index'],['type','int'],[@A_T,@A_component_index])
  end;
function TGraphExt.AddBarrierReadySize(const I_handle:string; const O_size:string):string;
  begin
  result:=AddOper('BarrierReadySize',[I_handle],[],[O_size],[],[],[])
  end;
function TGraphExt.AddBarrierTakeMany(const I_handle:string; const I_num_elements:string; const O_indices:string; const O_keys:string; const OL_values:TF_StringList; const A_component_types:TF_TypeList; const A_allow_small_batch:boolean; const A_wait_for_incomplete:boolean; const A_timeout_ms:cint64):string;
  var
    OutputNames : TF_StringList=nil;
    Index       : integer;
    Counter     : integer;
  begin
  SetLength(OutputNames,2+Length(OL_values));
  Outputnames[0]:=O_indices;
  Outputnames[1]:=O_keys;
  Counter:=2;
  for Index:=0 to Length(OL_values)-1 do
    OutputNames[Counter+Index]:=OL_values[Index];
  result:=AddOper('BarrierTakeMany',[I_handle,I_num_elements],[],OutputNames,['component_types','allow_small_batch','wait_for_incomplete','timeout_ms'],['list(type)','bool','bool','int'],[@A_component_types,@A_allow_small_batch,@A_wait_for_incomplete,@A_timeout_ms])
  end;
function TGraphExt.AddBatchCholesky(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchCholesky',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchCholeskyGrad(const I_l:string; const I_grad:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchCholeskyGrad',[I_l,I_grad],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchDataset(const I_input_dataset:string; const I_batch_size:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('BatchDataset',[I_input_dataset,I_batch_size],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddBatchFFT(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchFFT',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchFFT2D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchFFT2D',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchFFT3D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchFFT3D',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchIFFT(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchIFFT',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchIFFT2D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchIFFT2D',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchIFFT3D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchIFFT3D',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchMatMul(const I_x:string; const I_y:string; const O_output:string; const A_T:TF_DataType; const A_adj_x:boolean; const A_adj_y:boolean):string;
  begin
  result:=AddOper('BatchMatMul',[I_x,I_y],[],[O_output],['T','adj_x','adj_y'],['type','bool','bool'],[@A_T,@A_adj_x,@A_adj_y])
  end;
function TGraphExt.AddBatchMatrixBandPart(const I_input:string; const I_num_lower:string; const I_num_upper:string; const O_band:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixBandPart',[I_input,I_num_lower,I_num_upper],[],[O_band],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixDeterminant(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixDeterminant',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixDiag',[I_diagonal],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixDiagPart',[I_input],[],[O_diagonal],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixInverse(const I_input:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixInverse',[I_input],[],[O_output],['adjoint','T'],['bool','type'],[@A_adjoint,@A_T])
  end;
function TGraphExt.AddBatchMatrixSetDiag(const I_input:string; const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixSetDiag',[I_input,I_diagonal],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixSolve',[I_matrix,I_rhs],[],[O_output],['adjoint','T'],['bool','type'],[@A_adjoint,@A_T])
  end;
function TGraphExt.AddBatchMatrixSolveLs(const I_matrix:string; const I_rhs:string; const I_l2_regularizer:string; const O_output:string; const A_T:TF_DataType; const A_fast:boolean):string;
  begin
  result:=AddOper('BatchMatrixSolveLs',[I_matrix,I_rhs,I_l2_regularizer],[],[O_output],['T','fast'],['type','bool'],[@A_T,@A_fast])
  end;
function TGraphExt.AddBatchMatrixTriangularSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_lower:boolean; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixTriangularSolve',[I_matrix,I_rhs],[],[O_output],['lower','adjoint','T'],['bool','bool','type'],[@A_lower,@A_adjoint,@A_T])
  end;
function TGraphExt.AddBatchNormWithGlobalNormalization(const I_t:string; const I_m:string; const I_v:string; const I_beta:string; const I_gamma:string; const O_result:string; const A_T:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
  begin
  result:=AddOper('BatchNormWithGlobalNormalization',[I_t,I_m,I_v,I_beta,I_gamma],[],[O_result],['T','variance_epsilon','scale_after_normalization'],['type','float','bool'],[@A_T,@A_variance_epsilon,@A_scale_after_normalization])
  end;
function TGraphExt.AddBatchNormWithGlobalNormalizationGrad(const I_t:string; const I_m:string; const I_v:string; const I_gamma:string; const I_backprop:string; const O_dx:string; const O_dm:string; const O_dv:string; const O_db:string; const O_dg:string; const A_T:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
  begin
  result:=AddOper('BatchNormWithGlobalNormalizationGrad',[I_t,I_m,I_v,I_gamma,I_backprop],[],[O_dx,O_dm,O_dv,O_db,O_dg],['T','variance_epsilon','scale_after_normalization'],['type','float','bool'],[@A_T,@A_variance_epsilon,@A_scale_after_normalization])
  end;
function TGraphExt.AddBatchSelfAdjointEig(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchSelfAdjointEig',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchSelfAdjointEigV2(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchSelfAdjointEigV2',[I_input],[],[O_e,O_v],['compute_v','T'],['bool','type'],[@A_compute_v,@A_T])
  end;
function TGraphExt.AddBatchSvd(const I_input:string; const O_s:string; const O_u:string; const O_v:string; const A_compute_uv:boolean; const A_full_matrices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchSvd',[I_input],[],[O_s,O_u,O_v],['compute_uv','full_matrices','T'],['bool','bool','type'],[@A_compute_uv,@A_full_matrices,@A_T])
  end;
function TGraphExt.AddBatchToSpace(const I_input:string; const I_crops:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('BatchToSpace',[I_input,I_crops],[],[O_output],['T','block_size','Tidx'],['type','int','type'],[@A_T,@A_block_size,@A_Tidx])
  end;
function TGraphExt.AddBatchToSpaceND(const I_input:string; const I_block_shape:string; const I_crops:string; const O_output:string; const A_T:TF_DataType; const A_Tblock_shape:TF_DataType; const A_Tcrops:TF_DataType):string;
  begin
  result:=AddOper('BatchToSpaceND',[I_input,I_block_shape,I_crops],[],[O_output],['T','Tblock_shape','Tcrops'],['type','type','type'],[@A_T,@A_Tblock_shape,@A_Tcrops])
  end;
function TGraphExt.AddBetainc(const I_a:string; const I_b:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Betainc',[I_a,I_b,I_x],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBiasAdd(const I_value:string; const I_bias:string; const O_output:string; const A_T:TF_DataType; const A_data_format:string):string;
  begin
  result:=AddOper('BiasAdd',[I_value,I_bias],[],[O_output],['T','data_format'],['type','string'],[@A_T,@A_data_format])
  end;
function TGraphExt.AddBiasAddGrad(const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_data_format:string):string;
  begin
  result:=AddOper('BiasAddGrad',[I_out_backprop],[],[O_output],['T','data_format'],['type','string'],[@A_T,@A_data_format])
  end;
function TGraphExt.AddBiasAddV1(const I_value:string; const I_bias:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BiasAddV1',[I_value,I_bias],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBincount(const I_arr:string; const I_size:string; const I_weights:string; const O_bins:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Bincount',[I_arr,I_size,I_weights],[],[O_bins],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBitcast(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_type:TF_DataType):string;
  begin
  result:=AddOper('Bitcast',[I_input],[],[O_output],['T','type'],['type','type'],[@A_T,@A_type])
  end;
function TGraphExt.AddBitwiseAnd(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BitwiseAnd',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBitwiseOr(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BitwiseOr',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBitwiseXor(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BitwiseXor',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBroadcastArgs(const I_s0:string; const I_s1:string; const O_r0:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BroadcastArgs',[I_s0,I_s1],[],[O_r0],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBroadcastGradientArgs(const I_s0:string; const I_s1:string; const O_r0:string; const O_r1:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BroadcastGradientArgs',[I_s0,I_s1],[],[O_r0,O_r1],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBucketize(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_boundaries:TF_FloatList):string;
  begin
  result:=AddOper('Bucketize',[I_input],[],[O_output],['T','boundaries'],['type','list(float)'],[@A_T,@A_boundaries])
  end;
function TGraphExt.AddCTCBeamSearchDecoder(const I_inputs:string; const I_sequence_length:string; const O_log_probability:string; const OL_decoded_indices:TF_StringList; const OL_decoded_values:TF_StringList; const OL_decoded_shape:TF_StringList; const A_beam_width:cint64; const A_top_paths:cint64; const A_merge_repeated:boolean):string;
  var
    OutputNames : TF_StringList=nil;
    Index       : integer;
    Counter     : integer;
  begin
  SetLength(OutputNames,1+Length(OL_decoded_indices)+Length(OL_decoded_values)+Length(OL_decoded_shape));
  Outputnames[0]:=O_log_probability;
  Counter:=1;
  for Index:=0 to Length(OL_decoded_indices)-1 do
    OutputNames[Counter+Index]:=OL_decoded_indices[Index];
  Counter:=Counter+Length(OL_decoded_indices);
  for Index:=0 to Length(OL_decoded_values)-1 do
    OutputNames[Counter+Index]:=OL_decoded_values[Index];
  Counter:=Counter+Length(OL_decoded_values);
  for Index:=0 to Length(OL_decoded_shape)-1 do
    OutputNames[Counter+Index]:=OL_decoded_shape[Index];
  result:=AddOper('CTCBeamSearchDecoder',[I_inputs,I_sequence_length],[],OutputNames,['beam_width','top_paths','merge_repeated'],['int','int','bool'],[@A_beam_width,@A_top_paths,@A_merge_repeated])
  end;
function TGraphExt.AddCTCGreedyDecoder(const I_inputs:string; const I_sequence_length:string; const O_decoded_indices:string; const O_decoded_values:string; const O_decoded_shape:string; const O_log_probability:string; const A_merge_repeated:boolean):string;
  begin
  result:=AddOper('CTCGreedyDecoder',[I_inputs,I_sequence_length],[],[O_decoded_indices,O_decoded_values,O_decoded_shape,O_log_probability],['merge_repeated'],['bool'],[@A_merge_repeated])
  end;
function TGraphExt.AddCTCLoss(const I_inputs:string; const I_labels_indices:string; const I_labels_values:string; const I_sequence_length:string; const O_loss:string; const O_gradient:string; const A_preprocess_collapse_repeated:boolean; const A_ctc_merge_repeated:boolean; const A_ignore_longer_outputs_than_inputs:boolean):string;
  begin
  result:=AddOper('CTCLoss',[I_inputs,I_labels_indices,I_labels_values,I_sequence_length],[],[O_loss,O_gradient],['preprocess_collapse_repeated','ctc_merge_repeated','ignore_longer_outputs_than_inputs'],['bool','bool','bool'],[@A_preprocess_collapse_repeated,@A_ctc_merge_repeated,@A_ignore_longer_outputs_than_inputs])
  end;
function TGraphExt.AddCacheDataset(const I_input_dataset:string; const I_filename:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('CacheDataset',[I_input_dataset,I_filename],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddCast(const I_x:string; const O_y:string; const A_SrcT:TF_DataType; const A_DstT:TF_DataType):string;
  begin
  result:=AddOper('Cast',[I_x],[],[O_y],['SrcT','DstT'],['type','type'],[@A_SrcT,@A_DstT])
  end;
function TGraphExt.AddCeil(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Ceil',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCheckNumerics(const I_tensor:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
  begin
  result:=AddOper('CheckNumerics',[I_tensor],[],[O_output],['T','message'],['type','string'],[@A_T,@A_message])
  end;
function TGraphExt.AddCholesky(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Cholesky',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCholeskyGrad(const I_l:string; const I_grad:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CholeskyGrad',[I_l,I_grad],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddComplex(const I_real:string; const I_imag:string; const O_out:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('Complex',[I_real,I_imag],[],[O_out],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddComplexAbs(const I_x:string; const O_y:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('ComplexAbs',[I_x],[],[O_y],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddComputeAccidentalHits(const I_true_classes:string; const I_sampled_candidates:string; const O_indices:string; const O_ids:string; const O_weights:string; const A_num_true:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('ComputeAccidentalHits',[I_true_classes,I_sampled_candidates],[],[O_indices,O_ids,O_weights],['num_true','seed','seed2'],['int','int','int'],[@A_num_true,@A_seed,@A_seed2])
  end;
function TGraphExt.AddConcat(const I_concat_dim:string; const IL_values:TF_StringList; const O_output:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Concat',[I_concat_dim],[IL_values],[O_output],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddConcatOffset(const I_concat_dim:string; const IL_shape:TF_StringList; const OL_offset:TF_StringList; const A_N:cint64):string;
  begin
  result:=AddOper('ConcatOffset',[I_concat_dim],[IL_shape],OL_offset,['N'],['int'],[@A_N])
  end;
function TGraphExt.AddConcatV2(const I_axis:string; const IL_values:TF_StringList; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('ConcatV2',[I_axis],[IL_values],[O_output],['N','T','Tidx'],['int','type','type'],[@A_N,@A_T,@A_Tidx])
  end;
function TGraphExt.AddConcatenateDataset(const I_input_dataset:string; const I_another_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ConcatenateDataset',[I_input_dataset,I_another_dataset],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('ConditionalAccumulator',[],[],[O_handle],['dtype','shape','container','shared_name'],['type','shape','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name])
  end;
function TGraphExt.AddConj(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Conj',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddConst(const O_output:string; const A_value:TF_TensorPtr; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('Const',[],[],[O_output],['value','dtype'],['tensor','type'],[@A_value,@A_dtype])
  end;
function TGraphExt.AddControlTrigger():string;
  begin
  result:=AddOper('ControlTrigger',[],[],[],[],[],[])
  end;
function TGraphExt.AddConv2D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('Conv2D',[I_input,I_filter],[],[O_output],['T','strides','use_cudnn_on_gpu','padding','data_format'],['type','list(int)','bool','string','string'],[@A_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_data_format])
  end;
function TGraphExt.AddConv2DBackpropFilter(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('Conv2DBackpropFilter',[I_input,I_filter_sizes,I_out_backprop],[],[O_output],['T','strides','use_cudnn_on_gpu','padding','data_format'],['type','list(int)','bool','string','string'],[@A_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_data_format])
  end;
function TGraphExt.AddConv2DBackpropInput(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('Conv2DBackpropInput',[I_input_sizes,I_filter,I_out_backprop],[],[O_output],['T','strides','use_cudnn_on_gpu','padding','data_format'],['type','list(int)','bool','string','string'],[@A_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_data_format])
  end;
function TGraphExt.AddConv3D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('Conv3D',[I_input,I_filter],[],[O_output],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@A_T,@A_strides,@A_padding,@A_data_format])
  end;
function TGraphExt.AddConv3DBackpropFilter(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('Conv3DBackpropFilter',[I_input,I_filter,I_out_backprop],[],[O_output],['T','strides','padding'],['type','list(int)','string'],[@A_T,@A_strides,@A_padding])
  end;
function TGraphExt.AddConv3DBackpropFilterV2(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('Conv3DBackpropFilterV2',[I_input,I_filter_sizes,I_out_backprop],[],[O_output],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@A_T,@A_strides,@A_padding,@A_data_format])
  end;
function TGraphExt.AddConv3DBackpropInput(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('Conv3DBackpropInput',[I_input,I_filter,I_out_backprop],[],[O_output],['T','strides','padding'],['type','list(int)','string'],[@A_T,@A_strides,@A_padding])
  end;
function TGraphExt.AddConv3DBackpropInputV2(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('Conv3DBackpropInputV2',[I_input_sizes,I_filter,I_out_backprop],[],[O_output],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@A_T,@A_strides,@A_padding,@A_data_format])
  end;
function TGraphExt.AddCopy(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList):string;
  begin
  result:=AddOper('Copy',[I_input],[],[O_output],['T','tensor_name','debug_ops_spec'],['type','string','list(string)'],[@A_T,@A_tensor_name,@A_debug_ops_spec])
  end;
function TGraphExt.AddCopyHost(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList):string;
  begin
  result:=AddOper('CopyHost',[I_input],[],[O_output],['T','tensor_name','debug_ops_spec'],['type','string','list(string)'],[@A_T,@A_tensor_name,@A_debug_ops_spec])
  end;
function TGraphExt.AddCos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Cos',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCosh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Cosh',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCountUpTo(const I_ref:string; const O_output:string; const A_limit:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CountUpTo',[I_ref],[],[O_output],['limit','T'],['int','type'],[@A_limit,@A_T])
  end;
function TGraphExt.AddCropAndResize(const I_image:string; const I_boxes:string; const I_box_ind:string; const I_crop_size:string; const O_crops:string; const A_T:TF_DataType; const A_method:string; const A_extrapolation_value:real):string;
  begin
  result:=AddOper('CropAndResize',[I_image,I_boxes,I_box_ind,I_crop_size],[],[O_crops],['T','method','extrapolation_value'],['type','string','float'],[@A_T,@A_method,@A_extrapolation_value])
  end;
function TGraphExt.AddCropAndResizeGradBoxes(const I_grads:string; const I_image:string; const I_boxes:string; const I_box_ind:string; const O_output:string; const A_T:TF_DataType; const A_method:string):string;
  begin
  result:=AddOper('CropAndResizeGradBoxes',[I_grads,I_image,I_boxes,I_box_ind],[],[O_output],['T','method'],['type','string'],[@A_T,@A_method])
  end;
function TGraphExt.AddCropAndResizeGradImage(const I_grads:string; const I_boxes:string; const I_box_ind:string; const I_image_size:string; const O_output:string; const A_T:TF_DataType; const A_method:string):string;
  begin
  result:=AddOper('CropAndResizeGradImage',[I_grads,I_boxes,I_box_ind,I_image_size],[],[O_output],['T','method'],['type','string'],[@A_T,@A_method])
  end;
function TGraphExt.AddCross(const I_a:string; const I_b:string; const O_product:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Cross',[I_a,I_b],[],[O_product],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCumprod(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Cumprod',[I_x,I_axis],[],[O_out],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@A_T,@A_Tidx])
  end;
function TGraphExt.AddCumsum(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Cumsum',[I_x,I_axis],[],[O_out],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@A_T,@A_Tidx])
  end;
function TGraphExt.AddDebugIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean):string;
  begin
  result:=AddOper('DebugIdentity',[I_input],[],[O_output],['T','device_name','tensor_name','debug_urls','gated_grpc'],['type','string','string','list(string)','bool'],[@A_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_gated_grpc])
  end;
function TGraphExt.AddDebugNanCount(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean):string;
  begin
  result:=AddOper('DebugNanCount',[I_input],[],[O_output],['T','device_name','tensor_name','debug_urls','gated_grpc'],['type','string','string','list(string)','bool'],[@A_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_gated_grpc])
  end;
function TGraphExt.AddDebugNumericSummary(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_lower_bound:real; const A_upper_bound:real; const A_mute_if_healthy:boolean; const A_gated_grpc:boolean):string;
  begin
  result:=AddOper('DebugNumericSummary',[I_input],[],[O_output],['T','device_name','tensor_name','debug_urls','lower_bound','upper_bound','mute_if_healthy','gated_grpc'],['type','string','string','list(string)','float','float','bool','bool'],[@A_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_lower_bound,@A_upper_bound,@A_mute_if_healthy,@A_gated_grpc])
  end;
function TGraphExt.AddDecodeBase64(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('DecodeBase64',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddDecodeBmp(const I_contents:string; const O_image:string; const A_channels:cint64):string;
  begin
  result:=AddOper('DecodeBmp',[I_contents],[],[O_image],['channels'],['int'],[@A_channels])
  end;
function TGraphExt.AddDecodeCSV(const I_records:string; const IL_record_defaults:TF_StringList; const OL_output:TF_StringList; const A_OUT_TYPE:TF_TypeList; const A_field_delim:string; const A_use_quote_delim:boolean):string;
  begin
  result:=AddOper('DecodeCSV',[I_records],[IL_record_defaults],OL_output,['OUT_TYPE','field_delim','use_quote_delim'],['list(type)','string','bool'],[@A_OUT_TYPE,@A_field_delim,@A_use_quote_delim])
  end;
function TGraphExt.AddDecodeGif(const I_contents:string; const O_image:string):string;
  begin
  result:=AddOper('DecodeGif',[I_contents],[],[O_image],[],[],[])
  end;
function TGraphExt.AddDecodeJSONExample(const I_json_examples:string; const O_binary_examples:string):string;
  begin
  result:=AddOper('DecodeJSONExample',[I_json_examples],[],[O_binary_examples],[],[],[])
  end;
function TGraphExt.AddDecodeJpeg(const I_contents:string; const O_image:string; const A_channels:cint64; const A_ratio:cint64; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string):string;
  begin
  result:=AddOper('DecodeJpeg',[I_contents],[],[O_image],['channels','ratio','fancy_upscaling','try_recover_truncated','acceptable_fraction','dct_method'],['int','int','bool','bool','float','string'],[@A_channels,@A_ratio,@A_fancy_upscaling,@A_try_recover_truncated,@A_acceptable_fraction,@A_dct_method])
  end;
function TGraphExt.AddDecodePng(const I_contents:string; const O_image:string; const A_channels:cint64; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('DecodePng',[I_contents],[],[O_image],['channels','dtype'],['int','type'],[@A_channels,@A_dtype])
  end;
function TGraphExt.AddDecodeRaw(const I_bytes:string; const O_output:string; const A_out_type:TF_DataType; const A_little_endian:boolean):string;
  begin
  result:=AddOper('DecodeRaw',[I_bytes],[],[O_output],['out_type','little_endian'],['type','bool'],[@A_out_type,@A_little_endian])
  end;
function TGraphExt.AddDecodeWav(const I_contents:string; const O_audio:string; const O_sample_rate:string; const A_desired_channels:cint64; const A_desired_samples:cint64):string;
  begin
  result:=AddOper('DecodeWav',[I_contents],[],[O_audio,O_sample_rate],['desired_channels','desired_samples'],['int','int'],[@A_desired_channels,@A_desired_samples])
  end;
function TGraphExt.AddDeleteSessionTensor(const I_handle:string):string;
  begin
  result:=AddOper('DeleteSessionTensor',[I_handle],[],[],[],[],[])
  end;
function TGraphExt.AddDenseToDenseSetOperation(const I_set1:string; const I_set2:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DenseToDenseSetOperation',[I_set1,I_set2],[],[O_result_indices,O_result_values,O_result_shape],['set_operation','validate_indices','T'],['string','bool','type'],[@A_set_operation,@A_validate_indices,@A_T])
  end;
function TGraphExt.AddDenseToSparseBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_row_shape:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('DenseToSparseBatchDataset',[I_input_dataset,I_batch_size,I_row_shape],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddDenseToSparseSetOperation(const I_set1:string; const I_set2_indices:string; const I_set2_values:string; const I_set2_shape:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DenseToSparseSetOperation',[I_set1,I_set2_indices,I_set2_values,I_set2_shape],[],[O_result_indices,O_result_values,O_result_shape],['set_operation','validate_indices','T'],['string','bool','type'],[@A_set_operation,@A_validate_indices,@A_T])
  end;
function TGraphExt.AddDepthToSpace(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64):string;
  begin
  result:=AddOper('DepthToSpace',[I_input],[],[O_output],['T','block_size'],['type','int'],[@A_T,@A_block_size])
  end;
function TGraphExt.AddDepthwiseConv2dNative(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('DepthwiseConv2dNative',[I_input,I_filter],[],[O_output],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@A_T,@A_strides,@A_padding,@A_data_format])
  end;
function TGraphExt.AddDepthwiseConv2dNativeBackpropFilter(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('DepthwiseConv2dNativeBackpropFilter',[I_input,I_filter_sizes,I_out_backprop],[],[O_output],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@A_T,@A_strides,@A_padding,@A_data_format])
  end;
function TGraphExt.AddDepthwiseConv2dNativeBackpropInput(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('DepthwiseConv2dNativeBackpropInput',[I_input_sizes,I_filter,I_out_backprop],[],[O_output],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@A_T,@A_strides,@A_padding,@A_data_format])
  end;
function TGraphExt.AddDequantize(const I_input:string; const I_min_range:string; const I_max_range:string; const O_output:string; const A_T:TF_DataType; const A_mode:string):string;
  begin
  result:=AddOper('Dequantize',[I_input,I_min_range,I_max_range],[],[O_output],['T','mode'],['type','string'],[@A_T,@A_mode])
  end;
function TGraphExt.AddDeserializeManySparse(const I_serialized_sparse:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('DeserializeManySparse',[I_serialized_sparse],[],[O_sparse_indices,O_sparse_values,O_sparse_shape],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddDestroyTemporaryVariable(const I_ref:string; const O_value:string; const A_T:TF_DataType; const A_var_name:string):string;
  begin
  result:=AddOper('DestroyTemporaryVariable',[I_ref],[],[O_value],['T','var_name'],['type','string'],[@A_T,@A_var_name])
  end;
function TGraphExt.AddDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Diag',[I_diagonal],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DiagPart',[I_input],[],[O_diagonal],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDigamma(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Digamma',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDilation2D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('Dilation2D',[I_input,I_filter],[],[O_output],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_strides,@A_rates,@A_padding])
  end;
function TGraphExt.AddDilation2DBackpropFilter(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_filter_backprop:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('Dilation2DBackpropFilter',[I_input,I_filter,I_out_backprop],[],[O_filter_backprop],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_strides,@A_rates,@A_padding])
  end;
function TGraphExt.AddDilation2DBackpropInput(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_in_backprop:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('Dilation2DBackpropInput',[I_input,I_filter,I_out_backprop],[],[O_in_backprop],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_strides,@A_rates,@A_padding])
  end;
function TGraphExt.AddDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Div',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDrawBoundingBoxes(const I_images:string; const I_boxes:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DrawBoundingBoxes',[I_images,I_boxes],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDynamicPartition(const I_data:string; const I_partitions:string; const OL_outputs:TF_StringList; const A_num_partitions:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DynamicPartition',[I_data,I_partitions],[],OL_outputs,['num_partitions','T'],['int','type'],[@A_num_partitions,@A_T])
  end;
function TGraphExt.AddDynamicStitch(const IL_indices:TF_StringList; const IL_data:TF_StringList; const O_merged:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DynamicStitch',[],[IL_indices,IL_data],[O_merged],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddEditDistance(const I_hypothesis_indices:string; const I_hypothesis_values:string; const I_hypothesis_shape:string; const I_truth_indices:string; const I_truth_values:string; const I_truth_shape:string; const O_output:string; const A_normalize:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('EditDistance',[I_hypothesis_indices,I_hypothesis_values,I_hypothesis_shape,I_truth_indices,I_truth_values,I_truth_shape],[],[O_output],['normalize','T'],['bool','type'],[@A_normalize,@A_T])
  end;
function TGraphExt.AddElu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Elu',[I_features],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddEluGrad(const I_gradients:string; const I_outputs:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('EluGrad',[I_gradients,I_outputs],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddEncodeBase64(const I_input:string; const O_output:string; const A_pad:boolean):string;
  begin
  result:=AddOper('EncodeBase64',[I_input],[],[O_output],['pad'],['bool'],[@A_pad])
  end;
function TGraphExt.AddEncodeJpeg(const I_image:string; const O_contents:string; const A_format:string; const A_quality:cint64; const A_progressive:boolean; const A_optimize_size:boolean; const A_chroma_downsampling:boolean; const A_density_unit:string; const A_x_density:cint64; const A_y_density:cint64; const A_xmp_metadata:string):string;
  begin
  result:=AddOper('EncodeJpeg',[I_image],[],[O_contents],['format','quality','progressive','optimize_size','chroma_downsampling','density_unit','x_density','y_density','xmp_metadata'],['string','int','bool','bool','bool','string','int','int','string'],[@A_format,@A_quality,@A_progressive,@A_optimize_size,@A_chroma_downsampling,@A_density_unit,@A_x_density,@A_y_density,@A_xmp_metadata])
  end;
function TGraphExt.AddEncodePng(const I_image:string; const O_contents:string; const A_compression:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('EncodePng',[I_image],[],[O_contents],['compression','T'],['int','type'],[@A_compression,@A_T])
  end;
function TGraphExt.AddEncodeWav(const I_audio:string; const I_sample_rate:string; const O_contents:string):string;
  begin
  result:=AddOper('EncodeWav',[I_audio,I_sample_rate],[],[O_contents],[],[],[])
  end;
function TGraphExt.AddEnter(const I_data:string; const O_output:string; const A_T:TF_DataType; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64):string;
  begin
  result:=AddOper('Enter',[I_data],[],[O_output],['T','frame_name','is_constant','parallel_iterations'],['type','string','bool','int'],[@A_T,@A_frame_name,@A_is_constant,@A_parallel_iterations])
  end;
function TGraphExt.AddEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Equal',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddErf(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Erf',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddErfc(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Erfc',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddExit(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Exit',[I_data],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddExp(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Exp',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddExpandDims(const I_input:string; const I_dim:string; const O_output:string; const A_T:TF_DataType; const A_Tdim:TF_DataType):string;
  begin
  result:=AddOper('ExpandDims',[I_input,I_dim],[],[O_output],['T','Tdim'],['type','type'],[@A_T,@A_Tdim])
  end;
function TGraphExt.AddExpm1(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Expm1',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddExtractGlimpse(const I_input:string; const I_size:string; const I_offsets:string; const O_glimpse:string; const A_centered:boolean; const A_normalized:boolean; const A_uniform_noise:boolean):string;
  begin
  result:=AddOper('ExtractGlimpse',[I_input,I_size,I_offsets],[],[O_glimpse],['centered','normalized','uniform_noise'],['bool','bool','bool'],[@A_centered,@A_normalized,@A_uniform_noise])
  end;
function TGraphExt.AddExtractImagePatches(const I_images:string; const O_patches:string; const A_ksizes:TF_IntList; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_T:TF_DataType; const A_padding:string):string;
  begin
  result:=AddOper('ExtractImagePatches',[I_images],[],[O_patches],['ksizes','strides','rates','T','padding'],['list(int)','list(int)','list(int)','type','string'],[@A_ksizes,@A_strides,@A_rates,@A_T,@A_padding])
  end;
function TGraphExt.AddFFT(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('FFT',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddFFT2D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('FFT2D',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddFFT3D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('FFT3D',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddFIFOQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('FIFOQueue',[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddFIFOQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('FIFOQueueV2',[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddFact(const O_fact:string):string;
  begin
  result:=AddOper('Fact',[],[],[O_fact],[],[],[])
  end;
function TGraphExt.AddFakeQuantWithMinMaxArgs(const I_inputs:string; const O_outputs:string; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxArgs',[I_inputs],[],[O_outputs],['min','max','num_bits','narrow_range'],['float','float','int','bool'],[@A_min,@A_max,@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxArgsGradient(const I_gradients:string; const I_inputs:string; const O_backprops:string; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxArgsGradient',[I_gradients,I_inputs],[],[O_backprops],['min','max','num_bits','narrow_range'],['float','float','int','bool'],[@A_min,@A_max,@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxVars(const I_inputs:string; const I_min:string; const I_max:string; const O_outputs:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxVars',[I_inputs,I_min,I_max],[],[O_outputs],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxVarsGradient(const I_gradients:string; const I_inputs:string; const I_min:string; const I_max:string; const O_backprops_wrt_input:string; const O_backprop_wrt_min:string; const O_backprop_wrt_max:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxVarsGradient',[I_gradients,I_inputs,I_min,I_max],[],[O_backprops_wrt_input,O_backprop_wrt_min,O_backprop_wrt_max],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxVarsPerChannel(const I_inputs:string; const I_min:string; const I_max:string; const O_outputs:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxVarsPerChannel',[I_inputs,I_min,I_max],[],[O_outputs],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxVarsPerChannelGradient(const I_gradients:string; const I_inputs:string; const I_min:string; const I_max:string; const O_backprops_wrt_input:string; const O_backprop_wrt_min:string; const O_backprop_wrt_max:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxVarsPerChannelGradient',[I_gradients,I_inputs,I_min,I_max],[],[O_backprops_wrt_input,O_backprop_wrt_min,O_backprop_wrt_max],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQueue(const I_resource:string; const O_handle:string):string;
  begin
  result:=AddOper('FakeQueue',[I_resource],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddFill(const I_dims:string; const I_value:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Fill',[I_dims,I_value],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFilterDataset(const I_input_dataset:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_predicate:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('FilterDataset',[I_input_dataset],[IL_other_arguments],[O_handle],['predicate','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_predicate,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddFixedLengthRecordDataset(const I_filenames:string; const I_header_bytes:string; const I_record_bytes:string; const I_footer_bytes:string; const O_handle:string):string;
  begin
  result:=AddOper('FixedLengthRecordDataset',[I_filenames,I_header_bytes,I_record_bytes,I_footer_bytes],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddFixedLengthRecordReader(const O_reader_handle:string; const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('FixedLengthRecordReader',[],[],[O_reader_handle],['header_bytes','record_bytes','footer_bytes','hop_bytes','container','shared_name'],['int','int','int','int','string','string'],[@A_header_bytes,@A_record_bytes,@A_footer_bytes,@A_hop_bytes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddFixedLengthRecordReaderV2(const O_reader_handle:string; const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string; const A_encoding:string):string;
  begin
  result:=AddOper('FixedLengthRecordReaderV2',[],[],[O_reader_handle],['header_bytes','record_bytes','footer_bytes','hop_bytes','container','shared_name','encoding'],['int','int','int','int','string','string','string'],[@A_header_bytes,@A_record_bytes,@A_footer_bytes,@A_hop_bytes,@A_container,@A_shared_name,@A_encoding])
  end;
function TGraphExt.AddFixedUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_vocab_file:string; const A_distortion:real; const A_num_reserved_ids:cint64; const A_num_shards:cint64; const A_shard:cint64; const A_unigrams:TF_FloatList; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('FixedUnigramCandidateSampler',[I_true_classes],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','vocab_file','distortion','num_reserved_ids','num_shards','shard','unigrams','seed','seed2'],['int','int','bool','int','string','float','int','int','int','list(float)','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_vocab_file,@A_distortion,@A_num_reserved_ids,@A_num_shards,@A_shard,@A_unigrams,@A_seed,@A_seed2])
  end;
function TGraphExt.AddFlatMapDataset(const I_input_dataset:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('FlatMapDataset',[I_input_dataset],[IL_other_arguments],[O_handle],['f','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddFloor(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Floor',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFloorDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FloorDiv',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFloorMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FloorMod',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFractionalAvgPool(const I_value:string; const O_output:string; const O_row_pooling_sequence:string; const O_col_pooling_sequence:string; const A_pooling_ratio:TF_FloatList; const A_pseudo_random:boolean; const A_overlapping:boolean; const A_deterministic:boolean; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FractionalAvgPool',[I_value],[],[O_output,O_row_pooling_sequence,O_col_pooling_sequence],['pooling_ratio','pseudo_random','overlapping','deterministic','seed','seed2','T'],['list(float)','bool','bool','bool','int','int','type'],[@A_pooling_ratio,@A_pseudo_random,@A_overlapping,@A_deterministic,@A_seed,@A_seed2,@A_T])
  end;
function TGraphExt.AddFractionalAvgPoolGrad(const I_orig_input_tensor_shape:string; const I_out_backprop:string; const I_row_pooling_sequence:string; const I_col_pooling_sequence:string; const O_output:string; const A_overlapping:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FractionalAvgPoolGrad',[I_orig_input_tensor_shape,I_out_backprop,I_row_pooling_sequence,I_col_pooling_sequence],[],[O_output],['overlapping','T'],['bool','type'],[@A_overlapping,@A_T])
  end;
function TGraphExt.AddFractionalMaxPool(const I_value:string; const O_output:string; const O_row_pooling_sequence:string; const O_col_pooling_sequence:string; const A_pooling_ratio:TF_FloatList; const A_pseudo_random:boolean; const A_overlapping:boolean; const A_deterministic:boolean; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FractionalMaxPool',[I_value],[],[O_output,O_row_pooling_sequence,O_col_pooling_sequence],['pooling_ratio','pseudo_random','overlapping','deterministic','seed','seed2','T'],['list(float)','bool','bool','bool','int','int','type'],[@A_pooling_ratio,@A_pseudo_random,@A_overlapping,@A_deterministic,@A_seed,@A_seed2,@A_T])
  end;
function TGraphExt.AddFractionalMaxPoolGrad(const I_orig_input:string; const I_orig_output:string; const I_out_backprop:string; const I_row_pooling_sequence:string; const I_col_pooling_sequence:string; const O_output:string; const A_overlapping:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FractionalMaxPoolGrad',[I_orig_input,I_orig_output,I_out_backprop,I_row_pooling_sequence,I_col_pooling_sequence],[],[O_output],['overlapping','T'],['bool','type'],[@A_overlapping,@A_T])
  end;
function TGraphExt.AddFusedBatchNorm(const I_x:string; const I_scale:string; const I_offset:string; const I_mean:string; const I_variance:string; const O_y:string; const O_batch_mean:string; const O_batch_variance:string; const O_reserve_space_1:string; const O_reserve_space_2:string; const A_T:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
  begin
  result:=AddOper('FusedBatchNorm',[I_x,I_scale,I_offset,I_mean,I_variance],[],[O_y,O_batch_mean,O_batch_variance,O_reserve_space_1,O_reserve_space_2],['T','epsilon','data_format','is_training'],['type','float','string','bool'],[@A_T,@A_epsilon,@A_data_format,@A_is_training])
  end;
function TGraphExt.AddFusedBatchNormGrad(const I_y_backprop:string; const I_x:string; const I_scale:string; const I_reserve_space_1:string; const I_reserve_space_2:string; const O_x_backprop:string; const O_scale_backprop:string; const O_offset_backprop:string; const O_reserve_space_3:string; const O_reserve_space_4:string; const A_T:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
  begin
  result:=AddOper('FusedBatchNormGrad',[I_y_backprop,I_x,I_scale,I_reserve_space_1,I_reserve_space_2],[],[O_x_backprop,O_scale_backprop,O_offset_backprop,O_reserve_space_3,O_reserve_space_4],['T','epsilon','data_format','is_training'],['type','float','string','bool'],[@A_T,@A_epsilon,@A_data_format,@A_is_training])
  end;
function TGraphExt.AddFusedPadConv2D(const I_input:string; const I_paddings:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_mode:string; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('FusedPadConv2D',[I_input,I_paddings,I_filter],[],[O_output],['T','mode','strides','padding'],['type','string','list(int)','string'],[@A_T,@A_mode,@A_strides,@A_padding])
  end;
function TGraphExt.AddFusedResizeAndPadConv2D(const I_input:string; const I_size:string; const I_paddings:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_resize_align_corners:boolean; const A_mode:string; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('FusedResizeAndPadConv2D',[I_input,I_size,I_paddings,I_filter],[],[O_output],['T','resize_align_corners','mode','strides','padding'],['type','bool','string','list(int)','string'],[@A_T,@A_resize_align_corners,@A_mode,@A_strides,@A_padding])
  end;
function TGraphExt.AddGather(const I_params:string; const I_indices:string; const O_output:string; const A_validate_indices:boolean; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('Gather',[I_params,I_indices],[],[O_output],['validate_indices','Tparams','Tindices'],['bool','type','type'],[@A_validate_indices,@A_Tparams,@A_Tindices])
  end;
function TGraphExt.AddGatherNd(const I_params:string; const I_indices:string; const O_output:string; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('GatherNd',[I_params,I_indices],[],[O_output],['Tparams','Tindices'],['type','type'],[@A_Tparams,@A_Tindices])
  end;
function TGraphExt.AddGatherV2(const I_params:string; const I_indices:string; const I_axis:string; const O_output:string; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType; const A_Taxis:TF_DataType):string;
  begin
  result:=AddOper('GatherV2',[I_params,I_indices,I_axis],[],[O_output],['Tparams','Tindices','Taxis'],['type','type','type'],[@A_Tparams,@A_Tindices,@A_Taxis])
  end;
function TGraphExt.AddGetSessionHandle(const I_value:string; const O_handle:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GetSessionHandle',[I_value],[],[O_handle],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGetSessionHandleV2(const I_value:string; const O_handle:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GetSessionHandleV2',[I_value],[],[O_handle],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGetSessionTensor(const I_handle:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('GetSessionTensor',[I_handle],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddGreater(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Greater',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGreaterEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GreaterEqual',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGroupByWindowDataset(const I_input_dataset:string; const I_window_size:string; const IL_key_func_other_arguments:TF_StringList; const IL_reduce_func_other_arguments:TF_StringList; const O_handle:string; const A_key_func:TF_Function; const A_reduce_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('GroupByWindowDataset',[I_input_dataset,I_window_size],[IL_key_func_other_arguments,IL_reduce_func_other_arguments],[O_handle],['key_func','reduce_func','Tkey_func_other_arguments','Treduce_func_other_arguments','output_types','output_shapes'],['func','func','list(type)','list(type)','list(type)','list(shape)'],[@A_key_func,@A_reduce_func,@A_Tkey_func_other_arguments,@A_Treduce_func_other_arguments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddHSVToRGB(const I_images:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('HSVToRGB',[I_images],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddHashTable(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
  begin
  result:=AddOper('HashTable',[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype])
  end;
function TGraphExt.AddHashTableV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
  begin
  result:=AddOper('HashTableV2',[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype])
  end;
function TGraphExt.AddHistogramSummary(const I_tag:string; const I_values:string; const O_summary:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('HistogramSummary',[I_tag,I_values],[],[O_summary],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIFFT(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('IFFT',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddIFFT2D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('IFFT2D',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddIFFT3D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('IFFT3D',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddIRFFT(const I_input:string; const I_fft_length:string; const O_output:string):string;
  begin
  result:=AddOper('IRFFT',[I_input,I_fft_length],[],[O_output],[],[],[])
  end;
function TGraphExt.AddIRFFT2D(const I_input:string; const I_fft_length:string; const O_output:string):string;
  begin
  result:=AddOper('IRFFT2D',[I_input,I_fft_length],[],[O_output],[],[],[])
  end;
function TGraphExt.AddIRFFT3D(const I_input:string; const I_fft_length:string; const O_output:string):string;
  begin
  result:=AddOper('IRFFT3D',[I_input,I_fft_length],[],[O_output],[],[],[])
  end;
function TGraphExt.AddIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Identity',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIdentityReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('IdentityReader',[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddIdentityReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('IdentityReaderV2',[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddIgamma(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Igamma',[I_a,I_x],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIgammac(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Igammac',[I_a,I_x],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIgnoreErrorsDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IgnoreErrorsDataset',[I_input_dataset],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddImag(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('Imag',[I_input],[],[O_output],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddImageSummary(const I_tag:string; const I_tensor:string; const O_summary:string; const A_max_images:cint64; const A_T:TF_DataType; const A_bad_color:TF_TensorPtr):string;
  begin
  result:=AddOper('ImageSummary',[I_tag,I_tensor],[],[O_summary],['max_images','T','bad_color'],['int','type','tensor'],[@A_max_images,@A_T,@A_bad_color])
  end;
function TGraphExt.AddImmutableConst(const O_tensor:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_memory_region_name:string):string;
  begin
  result:=AddOper('ImmutableConst',[],[],[O_tensor],['dtype','shape','memory_region_name'],['type','shape','string'],[@A_dtype,@A_shape,@A_memory_region_name])
  end;
function TGraphExt.AddInTopK(const I_predictions:string; const I_targets:string; const O_precision:string; const A_k:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InTopK',[I_predictions,I_targets],[],[O_precision],['k','T'],['int','type'],[@A_k,@A_T])
  end;
function TGraphExt.AddInitializeTable(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tkey:TF_DataType; const A_Tval:TF_DataType):string;
  begin
  result:=AddOper('InitializeTable',[I_table_handle,I_keys,I_values],[],[],['Tkey','Tval'],['type','type'],[@A_Tkey,@A_Tval])
  end;
function TGraphExt.AddInitializeTableFromTextFile(const I_table_handle:string; const I_filename:string; const A_key_index:cint64; const A_value_index:cint64; const A_vocab_size:cint64; const A_delimiter:string):string;
  begin
  result:=AddOper('InitializeTableFromTextFile',[I_table_handle,I_filename],[],[],['key_index','value_index','vocab_size','delimiter'],['int','int','int','string'],[@A_key_index,@A_value_index,@A_vocab_size,@A_delimiter])
  end;
function TGraphExt.AddInitializeTableFromTextFileV2(const I_table_handle:string; const I_filename:string; const A_key_index:cint64; const A_value_index:cint64; const A_vocab_size:cint64; const A_delimiter:string):string;
  begin
  result:=AddOper('InitializeTableFromTextFileV2',[I_table_handle,I_filename],[],[],['key_index','value_index','vocab_size','delimiter'],['int','int','int','string'],[@A_key_index,@A_value_index,@A_vocab_size,@A_delimiter])
  end;
function TGraphExt.AddInitializeTableV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tkey:TF_DataType; const A_Tval:TF_DataType):string;
  begin
  result:=AddOper('InitializeTableV2',[I_table_handle,I_keys,I_values],[],[],['Tkey','Tval'],['type','type'],[@A_Tkey,@A_Tval])
  end;
function TGraphExt.AddInterleaveDataset(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('InterleaveDataset',[I_input_dataset,I_cycle_length,I_block_length],[IL_other_arguments],[O_handle],['f','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddInv(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Inv',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInvGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InvGrad',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInvert(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Invert',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInvertPermutation(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InvertPermutation',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIsFinite(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('IsFinite',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIsInf(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('IsInf',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIsNan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('IsNan',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIsVariableInitialized(const I_ref:string; const O_is_initialized:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('IsVariableInitialized',[I_ref],[],[O_is_initialized],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddIterator(const O_handle:string; const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('Iterator',[],[],[O_handle],['shared_name','container','output_types','output_shapes'],['string','string','list(type)','list(shape)'],[@A_shared_name,@A_container,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddIteratorDispose(const I_iterator:string):string;
  begin
  result:=AddOper('IteratorDispose',[I_iterator],[],[],[],[],[])
  end;
function TGraphExt.AddIteratorFromStringHandle(const I_string_handle:string; const O_resource_handle:string):string;
  begin
  result:=AddOper('IteratorFromStringHandle',[I_string_handle],[],[O_resource_handle],[],[],[])
  end;
function TGraphExt.AddIteratorGetNext(const I_iterator:string; const OL_components:TF_StringList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IteratorGetNext',[I_iterator],[],OL_components,['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddIteratorToStringHandle(const I_resource_handle:string; const O_string_handle:string):string;
  begin
  result:=AddOper('IteratorToStringHandle',[I_resource_handle],[],[O_string_handle],[],[],[])
  end;
function TGraphExt.AddL2Loss(const I_t:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('L2Loss',[I_t],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLMDBReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('LMDBReader',[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddLRN(const I_input:string; const O_output:string; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LRN',[I_input],[],[O_output],['depth_radius','bias','alpha','beta','T'],['int','float','float','float','type'],[@A_depth_radius,@A_bias,@A_alpha,@A_beta,@A_T])
  end;
function TGraphExt.AddLRNGrad(const I_input_grads:string; const I_input_image:string; const I_output_image:string; const O_output:string; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LRNGrad',[I_input_grads,I_input_image,I_output_image],[],[O_output],['depth_radius','bias','alpha','beta','T'],['int','float','float','float','type'],[@A_depth_radius,@A_bias,@A_alpha,@A_beta,@A_T])
  end;
function TGraphExt.AddLearnedUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('LearnedUnigramCandidateSampler',[I_true_classes],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','seed','seed2'],['int','int','bool','int','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_seed,@A_seed2])
  end;
function TGraphExt.AddLess(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Less',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLessEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LessEqual',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLgamma(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Lgamma',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLinSpace(const I_start:string; const I_stop:string; const I_num:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('LinSpace',[I_start,I_stop,I_num],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddListDiff(const I_x:string; const I_y:string; const O_out:string; const O_idx:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
  begin
  result:=AddOper('ListDiff',[I_x,I_y],[],[O_out,O_idx],['T','out_idx'],['type','type'],[@A_T,@A_out_idx])
  end;
function TGraphExt.AddLog(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Log',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLog1p(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Log1p',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLogSoftmax(const I_logits:string; const O_logsoftmax:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LogSoftmax',[I_logits],[],[O_logsoftmax],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLogUniformCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('LogUniformCandidateSampler',[I_true_classes],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','seed','seed2'],['int','int','bool','int','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_seed,@A_seed2])
  end;
function TGraphExt.AddLogicalAnd(const I_x:string; const I_y:string; const O_z:string):string;
  begin
  result:=AddOper('LogicalAnd',[I_x,I_y],[],[O_z],[],[],[])
  end;
function TGraphExt.AddLogicalNot(const I_x:string; const O_y:string):string;
  begin
  result:=AddOper('LogicalNot',[I_x],[],[O_y],[],[],[])
  end;
function TGraphExt.AddLogicalOr(const I_x:string; const I_y:string; const O_z:string):string;
  begin
  result:=AddOper('LogicalOr',[I_x,I_y],[],[O_z],[],[],[])
  end;
function TGraphExt.AddLookupTableExport(const I_table_handle:string; const O_keys:string; const O_values:string; const A_Tkeys:TF_DataType; const A_Tvalues:TF_DataType):string;
  begin
  result:=AddOper('LookupTableExport',[I_table_handle],[],[O_keys,O_values],['Tkeys','Tvalues'],['type','type'],[@A_Tkeys,@A_Tvalues])
  end;
function TGraphExt.AddLookupTableExportV2(const I_table_handle:string; const O_keys:string; const O_values:string; const A_Tkeys:TF_DataType; const A_Tvalues:TF_DataType):string;
  begin
  result:=AddOper('LookupTableExportV2',[I_table_handle],[],[O_keys,O_values],['Tkeys','Tvalues'],['type','type'],[@A_Tkeys,@A_Tvalues])
  end;
function TGraphExt.AddLookupTableFind(const I_table_handle:string; const I_keys:string; const I_default_value:string; const O_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableFind',[I_table_handle,I_keys,I_default_value],[],[O_values],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableFindV2(const I_table_handle:string; const I_keys:string; const I_default_value:string; const O_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableFindV2',[I_table_handle,I_keys,I_default_value],[],[O_values],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableImport(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableImport',[I_table_handle,I_keys,I_values],[],[],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableImportV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableImportV2',[I_table_handle,I_keys,I_values],[],[],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableInsert(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableInsert',[I_table_handle,I_keys,I_values],[],[],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableInsertV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableInsertV2',[I_table_handle,I_keys,I_values],[],[],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableSize(const I_table_handle:string; const O_size:string):string;
  begin
  result:=AddOper('LookupTableSize',[I_table_handle],[],[O_size],[],[],[])
  end;
function TGraphExt.AddLookupTableSizeV2(const I_table_handle:string; const O_size:string):string;
  begin
  result:=AddOper('LookupTableSizeV2',[I_table_handle],[],[O_size],[],[],[])
  end;
function TGraphExt.AddLoopCond(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('LoopCond',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddMakeIterator(const I_dataset:string; const I_iterator:string):string;
  begin
  result:=AddOper('MakeIterator',[I_dataset,I_iterator],[],[],[],[],[])
  end;
function TGraphExt.AddMapClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapClear',[],[],[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapDataset(const I_input_dataset:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('MapDataset',[I_input_dataset],[IL_other_arguments],[O_handle],['f','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddMapIncompleteSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapIncompleteSize',[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapPeek(const I_key:string; const I_indices:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapPeek',[I_key,I_indices],[],OL_values,['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapSize',[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapStage(const I_key:string; const I_indices:string; const IL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_fake_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapStage',[I_key,I_indices],[IL_values],[],['capacity','memory_limit','dtypes','fake_dtypes','container','shared_name'],['int','int','list(type)','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_fake_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapUnstage(const I_key:string; const I_indices:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapUnstage',[I_key,I_indices],[],OL_values,['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapUnstageNoKey(const I_indices:string; const O_key:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  var
    OutputNames : TF_StringList=nil;
    Index       : integer;
    Counter     : integer;
  begin
  SetLength(OutputNames,1+Length(OL_values));
  Outputnames[0]:=O_key;
  Counter:=1;
  for Index:=0 to Length(OL_values)-1 do
    OutputNames[Counter+Index]:=OL_values[Index];
  result:=AddOper('MapUnstageNoKey',[I_indices],[],OutputNames,['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMatMul(const I_a:string; const I_b:string; const O_product:string; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatMul',[I_a,I_b],[],[O_product],['transpose_a','transpose_b','T'],['bool','bool','type'],[@A_transpose_a,@A_transpose_b,@A_T])
  end;
function TGraphExt.AddMatchingFiles(const I_pattern:string; const O_filenames:string):string;
  begin
  result:=AddOper('MatchingFiles',[I_pattern],[],[O_filenames],[],[],[])
  end;
function TGraphExt.AddMatrixBandPart(const I_input:string; const I_num_lower:string; const I_num_upper:string; const O_band:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixBandPart',[I_input,I_num_lower,I_num_upper],[],[O_band],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixDeterminant(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixDeterminant',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixDiag',[I_diagonal],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixDiagPart',[I_input],[],[O_diagonal],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixInverse(const I_input:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixInverse',[I_input],[],[O_output],['adjoint','T'],['bool','type'],[@A_adjoint,@A_T])
  end;
function TGraphExt.AddMatrixSetDiag(const I_input:string; const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixSetDiag',[I_input,I_diagonal],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixSolve',[I_matrix,I_rhs],[],[O_output],['adjoint','T'],['bool','type'],[@A_adjoint,@A_T])
  end;
function TGraphExt.AddMatrixSolveLs(const I_matrix:string; const I_rhs:string; const I_l2_regularizer:string; const O_output:string; const A_T:TF_DataType; const A_fast:boolean):string;
  begin
  result:=AddOper('MatrixSolveLs',[I_matrix,I_rhs,I_l2_regularizer],[],[O_output],['T','fast'],['type','bool'],[@A_T,@A_fast])
  end;
function TGraphExt.AddMatrixTriangularSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_lower:boolean; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixTriangularSolve',[I_matrix,I_rhs],[],[O_output],['lower','adjoint','T'],['bool','bool','type'],[@A_lower,@A_adjoint,@A_T])
  end;
function TGraphExt.AddMax(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Max',[I_input,I_reduction_indices],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddMaxPool(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('MaxPool',[I_input],[],[O_output],['T','ksize','strides','padding','data_format'],['type','list(int)','list(int)','string','string'],[@A_T,@A_ksize,@A_strides,@A_padding,@A_data_format])
  end;
function TGraphExt.AddMaxPool3D(const I_input:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPool3D',[I_input],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPool3DGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType; const A_TInput:TF_DataType):string;
  begin
  result:=AddOper('MaxPool3DGrad',[I_orig_input,I_orig_output,I_grad],[],[O_output],['ksize','strides','padding','data_format','T','TInput'],['list(int)','list(int)','string','string','type','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T,@A_TInput])
  end;
function TGraphExt.AddMaxPool3DGradGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPool3DGradGrad',[I_orig_input,I_orig_output,I_grad],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPoolGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGrad',[I_orig_input,I_orig_output,I_grad],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPoolGradGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGradGrad',[I_orig_input,I_orig_output,I_grad],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPoolGradGradWithArgmax(const I_input:string; const I_grad:string; const I_argmax:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_Targmax:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGradGradWithArgmax',[I_input,I_grad,I_argmax],[],[O_output],['ksize','strides','padding','Targmax','T'],['list(int)','list(int)','string','type','type'],[@A_ksize,@A_strides,@A_padding,@A_Targmax,@A_T])
  end;
function TGraphExt.AddMaxPoolGradWithArgmax(const I_input:string; const I_grad:string; const I_argmax:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_Targmax:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGradWithArgmax',[I_input,I_grad,I_argmax],[],[O_output],['ksize','strides','padding','Targmax','T'],['list(int)','list(int)','string','type','type'],[@A_ksize,@A_strides,@A_padding,@A_Targmax,@A_T])
  end;
function TGraphExt.AddMaxPoolWithArgmax(const I_input:string; const O_output:string; const O_argmax:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_Targmax:TF_DataType; const A_padding:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolWithArgmax',[I_input],[],[O_output,O_argmax],['ksize','strides','Targmax','padding','T'],['list(int)','list(int)','type','string','type'],[@A_ksize,@A_strides,@A_Targmax,@A_padding,@A_T])
  end;
function TGraphExt.AddMaximum(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Maximum',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMean(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Mean',[I_input,I_reduction_indices],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddMerge(const IL_inputs:TF_StringList; const O_output:string; const O_value_index:string; const A_T:TF_DataType; const A_N:cint64):string;
  begin
  result:=AddOper('Merge',[],[IL_inputs],[O_output,O_value_index],['T','N'],['type','int'],[@A_T,@A_N])
  end;
function TGraphExt.AddMergeSummary(const IL_inputs:TF_StringList; const O_summary:string; const A_N:cint64):string;
  begin
  result:=AddOper('MergeSummary',[],[IL_inputs],[O_summary],['N'],['int'],[@A_N])
  end;
function TGraphExt.AddMergeV2Checkpoints(const I_checkpoint_prefixes:string; const I_destination_prefix:string; const A_delete_old_dirs:boolean):string;
  begin
  result:=AddOper('MergeV2Checkpoints',[I_checkpoint_prefixes,I_destination_prefix],[],[],['delete_old_dirs'],['bool'],[@A_delete_old_dirs])
  end;
function TGraphExt.AddMfcc(const I_spectrogram:string; const I_sample_rate:string; const O_output:string; const A_upper_frequency_limit:real; const A_lower_frequency_limit:real; const A_filterbank_channel_count:cint64; const A_dct_coefficient_count:cint64):string;
  begin
  result:=AddOper('Mfcc',[I_spectrogram,I_sample_rate],[],[O_output],['upper_frequency_limit','lower_frequency_limit','filterbank_channel_count','dct_coefficient_count'],['float','float','int','int'],[@A_upper_frequency_limit,@A_lower_frequency_limit,@A_filterbank_channel_count,@A_dct_coefficient_count])
  end;
function TGraphExt.AddMin(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Min',[I_input,I_reduction_indices],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddMinimum(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Minimum',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMirrorPad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_mode:string):string;
  begin
  result:=AddOper('MirrorPad',[I_input,I_paddings],[],[O_output],['T','Tpaddings','mode'],['type','type','string'],[@A_T,@A_Tpaddings,@A_mode])
  end;
function TGraphExt.AddMirrorPadGrad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_mode:string):string;
  begin
  result:=AddOper('MirrorPadGrad',[I_input,I_paddings],[],[O_output],['T','Tpaddings','mode'],['type','type','string'],[@A_T,@A_Tpaddings,@A_mode])
  end;
function TGraphExt.AddMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Mod',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMul(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Mul',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMultinomial(const I_logits:string; const I_num_samples:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Multinomial',[I_logits,I_num_samples],[],[O_output],['seed','seed2','T'],['int','int','type'],[@A_seed,@A_seed2,@A_T])
  end;
function TGraphExt.AddMutableDenseHashTable(const I_empty_key:string; const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real):string;
  begin
  result:=AddOper('MutableDenseHashTable',[I_empty_key],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape','initial_num_buckets','max_load_factor'],['string','string','bool','type','type','shape','int','float'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape,@A_initial_num_buckets,@A_max_load_factor])
  end;
function TGraphExt.AddMutableDenseHashTableV2(const I_empty_key:string; const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real):string;
  begin
  result:=AddOper('MutableDenseHashTableV2',[I_empty_key],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape','initial_num_buckets','max_load_factor'],['string','string','bool','type','type','shape','int','float'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape,@A_initial_num_buckets,@A_max_load_factor])
  end;
function TGraphExt.AddMutableHashTable(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
  begin
  result:=AddOper('MutableHashTable',[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype])
  end;
function TGraphExt.AddMutableHashTableOfTensors(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):string;
  begin
  result:=AddOper('MutableHashTableOfTensors',[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape'],['string','string','bool','type','type','shape'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape])
  end;
function TGraphExt.AddMutableHashTableOfTensorsV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):string;
  begin
  result:=AddOper('MutableHashTableOfTensorsV2',[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape'],['string','string','bool','type','type','shape'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape])
  end;
function TGraphExt.AddMutableHashTableV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
  begin
  result:=AddOper('MutableHashTableV2',[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype])
  end;
function TGraphExt.AddNeg(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Neg',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddNegTrain(const I_w_in:string; const I_w_out:string; const I_examples:string; const I_labels:string; const I_lr:string; const A_vocab_count:TF_IntList; const A_num_negative_samples:cint64):string;
  begin
  result:=AddOper('NegTrain',[I_w_in,I_w_out,I_examples,I_labels,I_lr],[],[],['vocab_count','num_negative_samples'],['list(int)','int'],[@A_vocab_count,@A_num_negative_samples])
  end;
function TGraphExt.AddNextIteration(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('NextIteration',[I_data],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddNoOp():string;
  begin
  result:=AddOper('NoOp',[],[],[],[],[],[])
  end;
function TGraphExt.AddNonMaxSuppression(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const O_selected_indices:string; const A_iou_threshold:real):string;
  begin
  result:=AddOper('NonMaxSuppression',[I_boxes,I_scores,I_max_output_size],[],[O_selected_indices],['iou_threshold'],['float'],[@A_iou_threshold])
  end;
function TGraphExt.AddNonMaxSuppressionV2(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const O_selected_indices:string):string;
  begin
  result:=AddOper('NonMaxSuppressionV2',[I_boxes,I_scores,I_max_output_size,I_iou_threshold],[],[O_selected_indices],[],[],[])
  end;
function TGraphExt.AddNotEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('NotEqual',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddOneHot(const I_indices:string; const I_depth:string; const I_on_value:string; const I_off_value:string; const O_output:string; const A_axis:cint64; const A_T:TF_DataType; const A_TI:TF_DataType):string;
  begin
  result:=AddOper('OneHot',[I_indices,I_depth,I_on_value,I_off_value],[],[O_output],['axis','T','TI'],['int','type','type'],[@A_axis,@A_T,@A_TI])
  end;
function TGraphExt.AddOneShotIterator(const O_handle:string; const A_dataset_factory:TF_Function; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OneShotIterator',[],[],[O_handle],['dataset_factory','output_types','output_shapes','container','shared_name'],['func','list(type)','list(shape)','string','string'],[@A_dataset_factory,@A_output_types,@A_output_shapes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOnesLike(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('OnesLike',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddOrderedMapClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapClear',[],[],[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapIncompleteSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapIncompleteSize',[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapPeek(const I_key:string; const I_indices:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapPeek',[I_key,I_indices],[],OL_values,['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapSize',[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapStage(const I_key:string; const I_indices:string; const IL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_fake_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapStage',[I_key,I_indices],[IL_values],[],['capacity','memory_limit','dtypes','fake_dtypes','container','shared_name'],['int','int','list(type)','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_fake_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapUnstage(const I_key:string; const I_indices:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapUnstage',[I_key,I_indices],[],OL_values,['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapUnstageNoKey(const I_indices:string; const O_key:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  var
    OutputNames : TF_StringList=nil;
    Index       : integer;
    Counter     : integer;
  begin
  SetLength(OutputNames,1+Length(OL_values));
  Outputnames[0]:=O_key;
  Counter:=1;
  for Index:=0 to Length(OL_values)-1 do
    OutputNames[Counter+Index]:=OL_values[Index];
  result:=AddOper('OrderedMapUnstageNoKey',[I_indices],[],OutputNames,['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddPack(const IL_values:TF_StringList; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_axis:cint64):string;
  begin
  result:=AddOper('Pack',[],[IL_values],[O_output],['N','T','axis'],['int','type','int'],[@A_N,@A_T,@A_axis])
  end;
function TGraphExt.AddPad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType):string;
  begin
  result:=AddOper('Pad',[I_input,I_paddings],[],[O_output],['T','Tpaddings'],['type','type'],[@A_T,@A_Tpaddings])
  end;
function TGraphExt.AddPadV2(const I_input:string; const I_paddings:string; const I_constant_values:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType):string;
  begin
  result:=AddOper('PadV2',[I_input,I_paddings,I_constant_values],[],[O_output],['T','Tpaddings'],['type','type'],[@A_T,@A_Tpaddings])
  end;
function TGraphExt.AddPaddedBatchDataset(const I_input_dataset:string; const I_batch_size:string; const IL_padded_shapes:TF_StringList; const IL_padding_values:TF_StringList; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
  begin
  result:=AddOper('PaddedBatchDataset',[I_input_dataset,I_batch_size],[IL_padded_shapes,IL_padding_values],[O_handle],['Toutput_types','output_shapes','N'],['list(type)','list(shape)','int'],[@A_Toutput_types,@A_output_shapes,@A_N])
  end;
function TGraphExt.AddPaddingFIFOQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('PaddingFIFOQueue',[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddPaddingFIFOQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('PaddingFIFOQueueV2',[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddParallelConcat(const IL_values:TF_StringList; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('ParallelConcat',[],[IL_values],[O_output],['N','T','shape'],['int','type','shape'],[@A_N,@A_T,@A_shape])
  end;
function TGraphExt.AddParallelMapDataset(const I_input_dataset:string; const I_num_threads:string; const I_output_buffer_size:string; const IL_other_arguments:TF_StringList; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParallelMapDataset',[I_input_dataset,I_num_threads,I_output_buffer_size],[IL_other_arguments],[O_handle],['f','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddParameterizedTruncatedNormal(const I_shape:string; const I_means:string; const I_stdevs:string; const I_minvals:string; const I_maxvals:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ParameterizedTruncatedNormal',[I_shape,I_means,I_stdevs,I_minvals,I_maxvals],[],[O_output],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@A_T])
  end;
function TGraphExt.AddParseExample(const I_serialized:string; const I_names:string; const IL_sparse_keys:TF_StringList; const IL_dense_keys:TF_StringList; const IL_dense_defaults:TF_StringList; const OL_sparse_indices:TF_StringList; const OL_sparse_values:TF_StringList; const OL_sparse_shapes:TF_StringList; const OL_dense_values:TF_StringList; const A_Nsparse:cint64; const A_Ndense:cint64; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList):string;
  var
    OutputNames : TF_StringList=nil;
    Index       : integer;
    Counter     : integer;
  begin
  SetLength(OutputNames,Length(OL_sparse_indices)+Length(OL_sparse_values)+Length(OL_sparse_shapes)+Length(OL_dense_values));
  Counter:=0;
  for Index:=0 to Length(OL_sparse_indices)-1 do
    OutputNames[Counter+Index]:=OL_sparse_indices[Index];
  Counter:=Counter+Length(OL_sparse_indices);
  for Index:=0 to Length(OL_sparse_values)-1 do
    OutputNames[Counter+Index]:=OL_sparse_values[Index];
  Counter:=Counter+Length(OL_sparse_values);
  for Index:=0 to Length(OL_sparse_shapes)-1 do
    OutputNames[Counter+Index]:=OL_sparse_shapes[Index];
  Counter:=Counter+Length(OL_sparse_shapes);
  for Index:=0 to Length(OL_dense_values)-1 do
    OutputNames[Counter+Index]:=OL_dense_values[Index];
  result:=AddOper('ParseExample',[I_serialized,I_names],[IL_sparse_keys,IL_dense_keys,IL_dense_defaults],OutputNames,['Nsparse','Ndense','sparse_types','Tdense','dense_shapes'],['int','int','list(type)','list(type)','list(shape)'],[@A_Nsparse,@A_Ndense,@A_sparse_types,@A_Tdense,@A_dense_shapes])
  end;
function TGraphExt.AddParseSingleSequenceExample(const I_serialized:string; const I_feature_list_dense_missing_assumed_empty:string; const I_debug_name:string; const IL_context_sparse_keys:TF_StringList; const IL_context_dense_keys:TF_StringList; const IL_feature_list_sparse_keys:TF_StringList; const IL_feature_list_dense_keys:TF_StringList; const IL_context_dense_defaults:TF_StringList; const OL_context_sparse_indices:TF_StringList; const OL_context_sparse_values:TF_StringList; const OL_context_sparse_shapes:TF_StringList; const OL_context_dense_values:TF_StringList; const OL_feature_list_sparse_indices:TF_StringList; const OL_feature_list_sparse_values:TF_StringList; const OL_feature_list_sparse_shapes:TF_StringList; const OL_feature_list_dense_values:TF_StringList; const A_Ncontext_sparse:cint64; const A_Ncontext_dense:cint64; const A_Nfeature_list_sparse:cint64; const A_Nfeature_list_dense:cint64; const A_context_sparse_types:TF_TypeList; const A_Tcontext_dense:TF_TypeList; const A_feature_list_dense_types:TF_TypeList; const A_context_dense_shapes:TF_ShapeList; const A_feature_list_sparse_types:TF_TypeList; const A_feature_list_dense_shapes:TF_ShapeList):string;
  var
    OutputNames : TF_StringList=nil;
    Index       : integer;
    Counter     : integer;
  begin
  SetLength(OutputNames,Length(OL_context_sparse_indices)+Length(OL_context_sparse_values)+Length(OL_context_sparse_shapes)+Length(OL_context_dense_values)+Length(OL_feature_list_sparse_indices)+Length(OL_feature_list_sparse_values)+Length(OL_feature_list_sparse_shapes)+Length(OL_feature_list_dense_values));
  Counter:=0;
  for Index:=0 to Length(OL_context_sparse_indices)-1 do
    OutputNames[Counter+Index]:=OL_context_sparse_indices[Index];
  Counter:=Counter+Length(OL_context_sparse_indices);
  for Index:=0 to Length(OL_context_sparse_values)-1 do
    OutputNames[Counter+Index]:=OL_context_sparse_values[Index];
  Counter:=Counter+Length(OL_context_sparse_values);
  for Index:=0 to Length(OL_context_sparse_shapes)-1 do
    OutputNames[Counter+Index]:=OL_context_sparse_shapes[Index];
  Counter:=Counter+Length(OL_context_sparse_shapes);
  for Index:=0 to Length(OL_context_dense_values)-1 do
    OutputNames[Counter+Index]:=OL_context_dense_values[Index];
  Counter:=Counter+Length(OL_context_dense_values);
  for Index:=0 to Length(OL_feature_list_sparse_indices)-1 do
    OutputNames[Counter+Index]:=OL_feature_list_sparse_indices[Index];
  Counter:=Counter+Length(OL_feature_list_sparse_indices);
  for Index:=0 to Length(OL_feature_list_sparse_values)-1 do
    OutputNames[Counter+Index]:=OL_feature_list_sparse_values[Index];
  Counter:=Counter+Length(OL_feature_list_sparse_values);
  for Index:=0 to Length(OL_feature_list_sparse_shapes)-1 do
    OutputNames[Counter+Index]:=OL_feature_list_sparse_shapes[Index];
  Counter:=Counter+Length(OL_feature_list_sparse_shapes);
  for Index:=0 to Length(OL_feature_list_dense_values)-1 do
    OutputNames[Counter+Index]:=OL_feature_list_dense_values[Index];
  result:=AddOper('ParseSingleSequenceExample',[I_serialized,I_feature_list_dense_missing_assumed_empty,I_debug_name],[IL_context_sparse_keys,IL_context_dense_keys,IL_feature_list_sparse_keys,IL_feature_list_dense_keys,IL_context_dense_defaults],OutputNames,['Ncontext_sparse','Ncontext_dense','Nfeature_list_sparse','Nfeature_list_dense','context_sparse_types','Tcontext_dense','feature_list_dense_types','context_dense_shapes','feature_list_sparse_types','feature_list_dense_shapes'],['int','int','int','int','list(type)','list(type)','list(type)','list(shape)','list(type)','list(shape)'],[@A_Ncontext_sparse,@A_Ncontext_dense,@A_Nfeature_list_sparse,@A_Nfeature_list_dense,@A_context_sparse_types,@A_Tcontext_dense,@A_feature_list_dense_types,@A_context_dense_shapes,@A_feature_list_sparse_types,@A_feature_list_dense_shapes])
  end;
function TGraphExt.AddParseTensor(const I_serialized:string; const O_output:string; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('ParseTensor',[I_serialized],[],[O_output],['out_type'],['type'],[@A_out_type])
  end;
function TGraphExt.AddPlaceholder(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('Placeholder',[],[],[O_output],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape])
  end;
function TGraphExt.AddPlaceholderV2(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('PlaceholderV2',[],[],[O_output],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape])
  end;
function TGraphExt.AddPlaceholderWithDefault(const I_input:string; const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('PlaceholderWithDefault',[I_input],[],[O_output],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape])
  end;
function TGraphExt.AddPolygamma(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Polygamma',[I_a,I_x],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddPow(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Pow',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddPreventGradient(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
  begin
  result:=AddOper('PreventGradient',[I_input],[],[O_output],['T','message'],['type','string'],[@A_T,@A_message])
  end;
function TGraphExt.AddPrint(const I_input:string; const IL_data:TF_StringList; const O_output:string; const A_T:TF_DataType; const A_U:TF_TypeList; const A_message:string; const A_first_n:cint64; const A_summarize:cint64):string;
  begin
  result:=AddOper('Print',[I_input],[IL_data],[O_output],['T','U','message','first_n','summarize'],['type','list(type)','string','int','int'],[@A_T,@A_U,@A_message,@A_first_n,@A_summarize])
  end;
function TGraphExt.AddPriorityQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('PriorityQueue',[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddPriorityQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('PriorityQueueV2',[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddProd(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Prod',[I_input,I_reduction_indices],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddPyFunc(const IL_input:TF_StringList; const OL_output:TF_StringList; const A_token:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
  begin
  result:=AddOper('PyFunc',[],[IL_input],OL_output,['token','Tin','Tout'],['string','list(type)','list(type)'],[@A_token,@A_Tin,@A_Tout])
  end;
function TGraphExt.AddPyFuncStateless(const IL_input:TF_StringList; const OL_output:TF_StringList; const A_token:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
  begin
  result:=AddOper('PyFuncStateless',[],[IL_input],OL_output,['token','Tin','Tout'],['string','list(type)','list(type)'],[@A_token,@A_Tin,@A_Tout])
  end;
function TGraphExt.AddQr(const I_input:string; const O_q:string; const O_r:string; const A_full_matrices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Qr',[I_input],[],[O_q,O_r],['full_matrices','T'],['bool','type'],[@A_full_matrices,@A_T])
  end;
function TGraphExt.AddQuantizeAndDequantize(const I_input:string; const O_output:string; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_input_min:real; const A_input_max:real; const A_T:TF_DataType):string;
  begin
  result:=AddOper('QuantizeAndDequantize',[I_input],[],[O_output],['signed_input','num_bits','range_given','input_min','input_max','T'],['bool','int','bool','float','float','type'],[@A_signed_input,@A_num_bits,@A_range_given,@A_input_min,@A_input_max,@A_T])
  end;
function TGraphExt.AddQuantizeAndDequantizeV2(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output:string; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('QuantizeAndDequantizeV2',[I_input,I_input_min,I_input_max],[],[O_output],['signed_input','num_bits','range_given','T'],['bool','int','bool','type'],[@A_signed_input,@A_num_bits,@A_range_given,@A_T])
  end;
function TGraphExt.AddQuantizeAndDequantizeV3(const I_input:string; const I_input_min:string; const I_input_max:string; const I_num_bits:string; const O_output:string; const A_signed_input:boolean; const A_range_given:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('QuantizeAndDequantizeV3',[I_input,I_input_min,I_input_max,I_num_bits],[],[O_output],['signed_input','range_given','T'],['bool','bool','type'],[@A_signed_input,@A_range_given,@A_T])
  end;
function TGraphExt.AddQuantizeDownAndShrinkRange(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizeDownAndShrinkRange',[I_input,I_input_min,I_input_max],[],[O_output,O_output_min,O_output_max],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddQuantizeV2(const I_input:string; const I_min_range:string; const I_max_range:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_mode:string):string;
  begin
  result:=AddOper('QuantizeV2',[I_input,I_min_range,I_max_range],[],[O_output,O_output_min,O_output_max],['T','mode'],['type','string'],[@A_T,@A_mode])
  end;
function TGraphExt.AddQuantizedAdd(const I_x:string; const I_y:string; const I_min_x:string; const I_max_x:string; const I_min_y:string; const I_max_y:string; const O_z:string; const O_min_z:string; const O_max_z:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType):string;
  begin
  result:=AddOper('QuantizedAdd',[I_x,I_y,I_min_x,I_max_x,I_min_y,I_max_y],[],[O_z,O_min_z,O_max_z],['T1','T2','Toutput'],['type','type','type'],[@A_T1,@A_T2,@A_Toutput])
  end;
function TGraphExt.AddQuantizedAvgPool(const I_input:string; const I_min_input:string; const I_max_input:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('QuantizedAvgPool',[I_input,I_min_input,I_max_input],[],[O_output,O_min_output,O_max_output],['T','ksize','strides','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_ksize,@A_strides,@A_padding])
  end;
function TGraphExt.AddQuantizedBatchNormWithGlobalNormalization(const I_t:string; const I_t_min:string; const I_t_max:string; const I_m:string; const I_m_min:string; const I_m_max:string; const I_v:string; const I_v_min:string; const I_v_max:string; const I_beta:string; const I_beta_min:string; const I_beta_max:string; const I_gamma:string; const I_gamma_min:string; const I_gamma_max:string; const O_result:string; const O_result_min:string; const O_result_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
  begin
  result:=AddOper('QuantizedBatchNormWithGlobalNormalization',[I_t,I_t_min,I_t_max,I_m,I_m_min,I_m_max,I_v,I_v_min,I_v_max,I_beta,I_beta_min,I_beta_max,I_gamma,I_gamma_min,I_gamma_max],[],[O_result,O_result_min,O_result_max],['Tinput','out_type','variance_epsilon','scale_after_normalization'],['type','type','float','bool'],[@A_Tinput,@A_out_type,@A_variance_epsilon,@A_scale_after_normalization])
  end;
function TGraphExt.AddQuantizedBiasAdd(const I_input:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_bias:string; const I_max_bias:string; const O_output:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizedBiasAdd',[I_input,I_bias,I_min_input,I_max_input,I_min_bias,I_max_bias],[],[O_output,O_min_out,O_max_out],['T1','T2','out_type'],['type','type','type'],[@A_T1,@A_T2,@A_out_type])
  end;
function TGraphExt.AddQuantizedConcat(const I_concat_dim:string; const IL_values:TF_StringList; const IL_input_mins:TF_StringList; const IL_input_maxes:TF_StringList; const O_output:string; const O_output_min:string; const O_output_max:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('QuantizedConcat',[I_concat_dim],[IL_values,IL_input_mins,IL_input_maxes],[O_output,O_output_min,O_output_max],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddQuantizedConv2D(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('QuantizedConv2D',[I_input,I_filter,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding'],['type','type','type','list(int)','string'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding])
  end;
function TGraphExt.AddQuantizedInstanceNorm(const I_x:string; const I_x_min:string; const I_x_max:string; const O_y:string; const O_y_min:string; const O_y_max:string; const A_T:TF_DataType; const A_output_range_given:boolean; const A_given_y_min:real; const A_given_y_max:real; const A_variance_epsilon:real; const A_min_separation:real):string;
  begin
  result:=AddOper('QuantizedInstanceNorm',[I_x,I_x_min,I_x_max],[],[O_y,O_y_min,O_y_max],['T','output_range_given','given_y_min','given_y_max','variance_epsilon','min_separation'],['type','bool','float','float','float','float'],[@A_T,@A_output_range_given,@A_given_y_min,@A_given_y_max,@A_variance_epsilon,@A_min_separation])
  end;
function TGraphExt.AddQuantizedMatMul(const I_a:string; const I_b:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_Tactivation:TF_DataType):string;
  begin
  result:=AddOper('QuantizedMatMul',[I_a,I_b,I_min_a,I_max_a,I_min_b,I_max_b],[],[O_out,O_min_out,O_max_out],['T1','T2','Toutput','transpose_a','transpose_b','Tactivation'],['type','type','type','bool','bool','type'],[@A_T1,@A_T2,@A_Toutput,@A_transpose_a,@A_transpose_b,@A_Tactivation])
  end;
function TGraphExt.AddQuantizedMaxPool(const I_input:string; const I_min_input:string; const I_max_input:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('QuantizedMaxPool',[I_input,I_min_input,I_max_input],[],[O_output,O_min_output,O_max_output],['T','ksize','strides','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_ksize,@A_strides,@A_padding])
  end;
function TGraphExt.AddQuantizedMul(const I_x:string; const I_y:string; const I_min_x:string; const I_max_x:string; const I_min_y:string; const I_max_y:string; const O_z:string; const O_min_z:string; const O_max_z:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType):string;
  begin
  result:=AddOper('QuantizedMul',[I_x,I_y,I_min_x,I_max_x,I_min_y,I_max_y],[],[O_z,O_min_z,O_max_z],['T1','T2','Toutput'],['type','type','type'],[@A_T1,@A_T2,@A_Toutput])
  end;
function TGraphExt.AddQuantizedRelu(const I_features:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizedRelu',[I_features,I_min_features,I_max_features],[],[O_activations,O_min_activations,O_max_activations],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddQuantizedRelu6(const I_features:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizedRelu6',[I_features,I_min_features,I_max_features],[],[O_activations,O_min_activations,O_max_activations],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddQuantizedReluX(const I_features:string; const I_max_value:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizedReluX',[I_features,I_max_value,I_min_features,I_max_features],[],[O_activations,O_min_activations,O_max_activations],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddQuantizedReshape(const I_tensor:string; const I_shape:string; const I_input_min:string; const I_input_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_Tshape:TF_DataType):string;
  begin
  result:=AddOper('QuantizedReshape',[I_tensor,I_shape,I_input_min,I_input_max],[],[O_output,O_output_min,O_output_max],['T','Tshape'],['type','type'],[@A_T,@A_Tshape])
  end;
function TGraphExt.AddQuantizedResizeBilinear(const I_images:string; const I_size:string; const I_min:string; const I_max:string; const O_resized_images:string; const O_out_min:string; const O_out_max:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
  begin
  result:=AddOper('QuantizedResizeBilinear',[I_images,I_size,I_min,I_max],[],[O_resized_images,O_out_min,O_out_max],['T','align_corners'],['type','bool'],[@A_T,@A_align_corners])
  end;
function TGraphExt.AddQueueClose(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
  begin
  result:=AddOper('QueueClose',[I_handle],[],[],['cancel_pending_enqueues'],['bool'],[@A_cancel_pending_enqueues])
  end;
function TGraphExt.AddQueueCloseV2(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
  begin
  result:=AddOper('QueueCloseV2',[I_handle],[],[],['cancel_pending_enqueues'],['bool'],[@A_cancel_pending_enqueues])
  end;
function TGraphExt.AddQueueDequeue(const I_handle:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeue',[I_handle],[],OL_components,['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueMany(const I_handle:string; const I_n:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueMany',[I_handle,I_n],[],OL_components,['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueManyV2(const I_handle:string; const I_n:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueManyV2',[I_handle,I_n],[],OL_components,['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueUpTo(const I_handle:string; const I_n:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueUpTo',[I_handle,I_n],[],OL_components,['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueUpToV2(const I_handle:string; const I_n:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueUpToV2',[I_handle,I_n],[],OL_components,['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueV2(const I_handle:string; const OL_components:TF_StringList; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueV2',[I_handle],[],OL_components,['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueEnqueue(const I_handle:string; const IL_components:TF_StringList; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueEnqueue',[I_handle],[IL_components],[],['Tcomponents','timeout_ms'],['list(type)','int'],[@A_Tcomponents,@A_timeout_ms])
  end;
function TGraphExt.AddQueueEnqueueMany(const I_handle:string; const IL_components:TF_StringList; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueEnqueueMany',[I_handle],[IL_components],[],['Tcomponents','timeout_ms'],['list(type)','int'],[@A_Tcomponents,@A_timeout_ms])
  end;
function TGraphExt.AddQueueEnqueueManyV2(const I_handle:string; const IL_components:TF_StringList; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueEnqueueManyV2',[I_handle],[IL_components],[],['Tcomponents','timeout_ms'],['list(type)','int'],[@A_Tcomponents,@A_timeout_ms])
  end;
function TGraphExt.AddQueueEnqueueV2(const I_handle:string; const IL_components:TF_StringList; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueEnqueueV2',[I_handle],[IL_components],[],['Tcomponents','timeout_ms'],['list(type)','int'],[@A_Tcomponents,@A_timeout_ms])
  end;
function TGraphExt.AddQueueIsClosed(const I_handle:string; const O_is_closed:string):string;
  begin
  result:=AddOper('QueueIsClosed',[I_handle],[],[O_is_closed],[],[],[])
  end;
function TGraphExt.AddQueueIsClosedV2(const I_handle:string; const O_is_closed:string):string;
  begin
  result:=AddOper('QueueIsClosedV2',[I_handle],[],[O_is_closed],[],[],[])
  end;
function TGraphExt.AddQueueSize(const I_handle:string; const O_size:string):string;
  begin
  result:=AddOper('QueueSize',[I_handle],[],[O_size],[],[],[])
  end;
function TGraphExt.AddQueueSizeV2(const I_handle:string; const O_size:string):string;
  begin
  result:=AddOper('QueueSizeV2',[I_handle],[],[O_size],[],[],[])
  end;
function TGraphExt.AddRFFT(const I_input:string; const I_fft_length:string; const O_output:string):string;
  begin
  result:=AddOper('RFFT',[I_input,I_fft_length],[],[O_output],[],[],[])
  end;
function TGraphExt.AddRFFT2D(const I_input:string; const I_fft_length:string; const O_output:string):string;
  begin
  result:=AddOper('RFFT2D',[I_input,I_fft_length],[],[O_output],[],[],[])
  end;
function TGraphExt.AddRFFT3D(const I_input:string; const I_fft_length:string; const O_output:string):string;
  begin
  result:=AddOper('RFFT3D',[I_input,I_fft_length],[],[O_output],[],[],[])
  end;
function TGraphExt.AddRGBToHSV(const I_images:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RGBToHSV',[I_images],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRandomCrop(const I_image:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('RandomCrop',[I_image,I_size],[],[O_output],['T','seed','seed2'],['type','int','int'],[@A_T,@A_seed,@A_seed2])
  end;
function TGraphExt.AddRandomGamma(const I_shape:string; const I_alpha:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomGamma',[I_shape,I_alpha],[],[O_output],['seed','seed2','S','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_S,@A_T])
  end;
function TGraphExt.AddRandomPoisson(const I_shape:string; const I_rate:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('RandomPoisson',[I_shape,I_rate],[],[O_output],['seed','seed2','S','dtype'],['int','int','type','type'],[@A_seed,@A_seed2,@A_S,@A_dtype])
  end;
function TGraphExt.AddRandomShuffle(const I_value:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomShuffle',[I_value],[],[O_output],['seed','seed2','T'],['int','int','type'],[@A_seed,@A_seed2,@A_T])
  end;
function TGraphExt.AddRandomShuffleQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('RandomShuffleQueue',[],[],[O_handle],['component_types','shapes','capacity','min_after_dequeue','seed','seed2','container','shared_name'],['list(type)','list(shape)','int','int','int','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_min_after_dequeue,@A_seed,@A_seed2,@A_container,@A_shared_name])
  end;
function TGraphExt.AddRandomShuffleQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('RandomShuffleQueueV2',[],[],[O_handle],['component_types','shapes','capacity','min_after_dequeue','seed','seed2','container','shared_name'],['list(type)','list(shape)','int','int','int','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_min_after_dequeue,@A_seed,@A_seed2,@A_container,@A_shared_name])
  end;
function TGraphExt.AddRandomStandardNormal(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomStandardNormal',[I_shape],[],[O_output],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@A_T])
  end;
function TGraphExt.AddRandomUniform(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomUniform',[I_shape],[],[O_output],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@A_T])
  end;
function TGraphExt.AddRandomUniformInt(const I_shape:string; const I_minval:string; const I_maxval:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_Tout:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomUniformInt',[I_shape,I_minval,I_maxval],[],[O_output],['seed','seed2','Tout','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_Tout,@A_T])
  end;
function TGraphExt.AddRange(const I_start:string; const I_limit:string; const I_delta:string; const O_output:string; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Range',[I_start,I_limit,I_delta],[],[O_output],['Tidx'],['type'],[@A_Tidx])
  end;
function TGraphExt.AddRangeDataset(const I_start:string; const I_stop:string; const I_step:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('RangeDataset',[I_start,I_stop,I_step],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddRank(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Rank',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReadFile(const I_filename:string; const O_contents:string):string;
  begin
  result:=AddOper('ReadFile',[I_filename],[],[O_contents],[],[],[])
  end;
function TGraphExt.AddReaderNumRecordsProduced(const I_reader_handle:string; const O_records_produced:string):string;
  begin
  result:=AddOper('ReaderNumRecordsProduced',[I_reader_handle],[],[O_records_produced],[],[],[])
  end;
function TGraphExt.AddReaderNumRecordsProducedV2(const I_reader_handle:string; const O_records_produced:string):string;
  begin
  result:=AddOper('ReaderNumRecordsProducedV2',[I_reader_handle],[],[O_records_produced],[],[],[])
  end;
function TGraphExt.AddReaderNumWorkUnitsCompleted(const I_reader_handle:string; const O_units_completed:string):string;
  begin
  result:=AddOper('ReaderNumWorkUnitsCompleted',[I_reader_handle],[],[O_units_completed],[],[],[])
  end;
function TGraphExt.AddReaderNumWorkUnitsCompletedV2(const I_reader_handle:string; const O_units_completed:string):string;
  begin
  result:=AddOper('ReaderNumWorkUnitsCompletedV2',[I_reader_handle],[],[O_units_completed],[],[],[])
  end;
function TGraphExt.AddReaderRead(const I_reader_handle:string; const I_queue_handle:string; const O_key:string; const O_value:string):string;
  begin
  result:=AddOper('ReaderRead',[I_reader_handle,I_queue_handle],[],[O_key,O_value],[],[],[])
  end;
function TGraphExt.AddReaderReadUpTo(const I_reader_handle:string; const I_queue_handle:string; const I_num_records:string; const O_keys:string; const O_values:string):string;
  begin
  result:=AddOper('ReaderReadUpTo',[I_reader_handle,I_queue_handle,I_num_records],[],[O_keys,O_values],[],[],[])
  end;
function TGraphExt.AddReaderReadUpToV2(const I_reader_handle:string; const I_queue_handle:string; const I_num_records:string; const O_keys:string; const O_values:string):string;
  begin
  result:=AddOper('ReaderReadUpToV2',[I_reader_handle,I_queue_handle,I_num_records],[],[O_keys,O_values],[],[],[])
  end;
function TGraphExt.AddReaderReadV2(const I_reader_handle:string; const I_queue_handle:string; const O_key:string; const O_value:string):string;
  begin
  result:=AddOper('ReaderReadV2',[I_reader_handle,I_queue_handle],[],[O_key,O_value],[],[],[])
  end;
function TGraphExt.AddReaderReset(const I_reader_handle:string):string;
  begin
  result:=AddOper('ReaderReset',[I_reader_handle],[],[],[],[],[])
  end;
function TGraphExt.AddReaderResetV2(const I_reader_handle:string):string;
  begin
  result:=AddOper('ReaderResetV2',[I_reader_handle],[],[],[],[],[])
  end;
function TGraphExt.AddReaderRestoreState(const I_reader_handle:string; const I_state:string):string;
  begin
  result:=AddOper('ReaderRestoreState',[I_reader_handle,I_state],[],[],[],[],[])
  end;
function TGraphExt.AddReaderRestoreStateV2(const I_reader_handle:string; const I_state:string):string;
  begin
  result:=AddOper('ReaderRestoreStateV2',[I_reader_handle,I_state],[],[],[],[],[])
  end;
function TGraphExt.AddReaderSerializeState(const I_reader_handle:string; const O_state:string):string;
  begin
  result:=AddOper('ReaderSerializeState',[I_reader_handle],[],[O_state],[],[],[])
  end;
function TGraphExt.AddReaderSerializeStateV2(const I_reader_handle:string; const O_state:string):string;
  begin
  result:=AddOper('ReaderSerializeStateV2',[I_reader_handle],[],[O_state],[],[],[])
  end;
function TGraphExt.AddReal(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('Real',[I_input],[],[O_output],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddRealDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RealDiv',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReciprocal(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Reciprocal',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReciprocalGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ReciprocalGrad',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRecordInput(const O_records:string; const A_file_pattern:string; const A_file_random_seed:cint64; const A_file_shuffle_shift_ratio:real; const A_file_buffer_size:cint64; const A_file_parallelism:cint64; const A_batch_size:cint64):string;
  begin
  result:=AddOper('RecordInput',[],[],[O_records],['file_pattern','file_random_seed','file_shuffle_shift_ratio','file_buffer_size','file_parallelism','batch_size'],['string','int','float','int','int','int'],[@A_file_pattern,@A_file_random_seed,@A_file_shuffle_shift_ratio,@A_file_buffer_size,@A_file_parallelism,@A_batch_size])
  end;
function TGraphExt.AddReduceJoin(const I_inputs:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_separator:string):string;
  begin
  result:=AddOper('ReduceJoin',[I_inputs,I_reduction_indices],[],[O_output],['keep_dims','separator'],['bool','string'],[@A_keep_dims,@A_separator])
  end;
function TGraphExt.AddRefEnter(const I_data:string; const O_output:string; const A_T:TF_DataType; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64):string;
  begin
  result:=AddOper('RefEnter',[I_data],[],[O_output],['T','frame_name','is_constant','parallel_iterations'],['type','string','bool','int'],[@A_T,@A_frame_name,@A_is_constant,@A_parallel_iterations])
  end;
function TGraphExt.AddRefExit(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RefExit',[I_data],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRefIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RefIdentity',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRefMerge(const IL_inputs:TF_StringList; const O_output:string; const O_value_index:string; const A_T:TF_DataType; const A_N:cint64):string;
  begin
  result:=AddOper('RefMerge',[],[IL_inputs],[O_output,O_value_index],['T','N'],['type','int'],[@A_T,@A_N])
  end;
function TGraphExt.AddRefNextIteration(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RefNextIteration',[I_data],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRefSelect(const I_index:string; const IL_inputs:TF_StringList; const O_output:string; const A_T:TF_DataType; const A_N:cint64):string;
  begin
  result:=AddOper('RefSelect',[I_index],[IL_inputs],[O_output],['T','N'],['type','int'],[@A_T,@A_N])
  end;
function TGraphExt.AddRefSwitch(const I_data:string; const I_pred:string; const O_output_false:string; const O_output_true:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RefSwitch',[I_data,I_pred],[],[O_output_false,O_output_true],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRelu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Relu',[I_features],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRelu6(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Relu6',[I_features],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRelu6Grad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Relu6Grad',[I_gradients,I_features],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReluGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ReluGrad',[I_gradients,I_features],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRemoteFusedGraphExecute(const IL_inputs:TF_StringList; const OL_outputs:TF_StringList; const A_Tinputs:TF_TypeList; const A_Toutputs:TF_TypeList; const A_serialized_remote_fused_graph_execute_info:string):string;
  begin
  result:=AddOper('RemoteFusedGraphExecute',[],[IL_inputs],OL_outputs,['Tinputs','Toutputs','serialized_remote_fused_graph_execute_info'],['list(type)','list(type)','string'],[@A_Tinputs,@A_Toutputs,@A_serialized_remote_fused_graph_execute_info])
  end;
function TGraphExt.AddRepeatDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('RepeatDataset',[I_input_dataset,I_count],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddRequantizationRange(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType):string;
  begin
  result:=AddOper('RequantizationRange',[I_input,I_input_min,I_input_max],[],[O_output_min,O_output_max],['Tinput'],['type'],[@A_Tinput])
  end;
function TGraphExt.AddRequantize(const I_input:string; const I_input_min:string; const I_input_max:string; const I_requested_output_min:string; const I_requested_output_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('Requantize',[I_input,I_input_min,I_input_max,I_requested_output_min,I_requested_output_max],[],[O_output,O_output_min,O_output_max],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddReshape(const I_tensor:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tshape:TF_DataType):string;
  begin
  result:=AddOper('Reshape',[I_tensor,I_shape],[],[O_output],['T','Tshape'],['type','type'],[@A_T,@A_Tshape])
  end;
function TGraphExt.AddResizeArea(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
  begin
  result:=AddOper('ResizeArea',[I_images,I_size],[],[O_resized_images],['T','align_corners'],['type','bool'],[@A_T,@A_align_corners])
  end;
function TGraphExt.AddResizeBicubic(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
  begin
  result:=AddOper('ResizeBicubic',[I_images,I_size],[],[O_resized_images],['T','align_corners'],['type','bool'],[@A_T,@A_align_corners])
  end;
function TGraphExt.AddResizeBilinear(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
  begin
  result:=AddOper('ResizeBilinear',[I_images,I_size],[],[O_resized_images],['T','align_corners'],['type','bool'],[@A_T,@A_align_corners])
  end;
function TGraphExt.AddResizeBilinearGrad(const I_grads:string; const I_original_image:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
  begin
  result:=AddOper('ResizeBilinearGrad',[I_grads,I_original_image],[],[O_output],['T','align_corners'],['type','bool'],[@A_T,@A_align_corners])
  end;
function TGraphExt.AddResizeNearestNeighbor(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
  begin
  result:=AddOper('ResizeNearestNeighbor',[I_images,I_size],[],[O_resized_images],['T','align_corners'],['type','bool'],[@A_T,@A_align_corners])
  end;
function TGraphExt.AddResizeNearestNeighborGrad(const I_grads:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
  begin
  result:=AddOper('ResizeNearestNeighborGrad',[I_grads,I_size],[],[O_output],['T','align_corners'],['type','bool'],[@A_T,@A_align_corners])
  end;
function TGraphExt.AddResourceApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdagrad',[I_var,I_accum,I_lr,I_grad],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_lr,I_l1,I_l2,I_global_step],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyAdam(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdam',[I_var,I_m,I_v,I_beta1_power,I_beta2_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],[],[],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddResourceApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_lr_power],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyGradientDescent',[I_var,I_alpha,I_delta],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ResourceApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_momentum],[],[],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddResourceApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_delta:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_delta],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad,I_indices],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyAdagrad',[I_var,I_accum,I_lr,I_grad,I_indices],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_indices,I_lr,I_l1,I_l2,I_global_step],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_lr_power],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_indices,I_momentum],[],[],['T','Tindices','use_locking','use_nesterov'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddResourceSparseApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad,I_indices],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_grad,I_indices],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceStridedSliceAssign(const I_ref:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('ResourceStridedSliceAssign',[I_ref,I_begin,I_end,I_strides,I_value],[],[],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddRestore(const I_file_pattern:string; const I_tensor_name:string; const O_tensor:string; const A_dt:TF_DataType; const A_preferred_shard:cint64):string;
  begin
  result:=AddOper('Restore',[I_file_pattern,I_tensor_name],[],[O_tensor],['dt','preferred_shard'],['type','int'],[@A_dt,@A_preferred_shard])
  end;
function TGraphExt.AddRestoreSlice(const I_file_pattern:string; const I_tensor_name:string; const I_shape_and_slice:string; const O_tensor:string; const A_dt:TF_DataType; const A_preferred_shard:cint64):string;
  begin
  result:=AddOper('RestoreSlice',[I_file_pattern,I_tensor_name,I_shape_and_slice],[],[O_tensor],['dt','preferred_shard'],['type','int'],[@A_dt,@A_preferred_shard])
  end;
function TGraphExt.AddRestoreV2(const I_prefix:string; const I_tensor_names:string; const I_shape_and_slices:string; const OL_tensors:TF_StringList; const A_dtypes:TF_TypeList):string;
  begin
  result:=AddOper('RestoreV2',[I_prefix,I_tensor_names,I_shape_and_slices],[],OL_tensors,['dtypes'],['list(type)'],[@A_dtypes])
  end;
function TGraphExt.AddReverse(const I_tensor:string; const I_dims:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Reverse',[I_tensor,I_dims],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReverseSequence(const I_input:string; const I_seq_lengths:string; const O_output:string; const A_seq_dim:cint64; const A_batch_dim:cint64; const A_T:TF_DataType; const A_Tlen:TF_DataType):string;
  begin
  result:=AddOper('ReverseSequence',[I_input,I_seq_lengths],[],[O_output],['seq_dim','batch_dim','T','Tlen'],['int','int','type','type'],[@A_seq_dim,@A_batch_dim,@A_T,@A_Tlen])
  end;
function TGraphExt.AddReverseV2(const I_tensor:string; const I_axis:string; const O_output:string; const A_Tidx:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ReverseV2',[I_tensor,I_axis],[],[O_output],['Tidx','T'],['type','type'],[@A_Tidx,@A_T])
  end;
function TGraphExt.AddRint(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Rint',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRound(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Round',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRsqrt(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Rsqrt',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRsqrtGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RsqrtGrad',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSampleDistortedBoundingBox(const I_image_size:string; const I_bounding_boxes:string; const O_begin:string; const O_size:string; const O_bboxes:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64; const A_min_object_covered:real; const A_aspect_ratio_range:TF_FloatList; const A_area_range:TF_FloatList; const A_max_attempts:cint64; const A_use_image_if_no_bounding_boxes:boolean):string;
  begin
  result:=AddOper('SampleDistortedBoundingBox',[I_image_size,I_bounding_boxes],[],[O_begin,O_size,O_bboxes],['T','seed','seed2','min_object_covered','aspect_ratio_range','area_range','max_attempts','use_image_if_no_bounding_boxes'],['type','int','int','float','list(float)','list(float)','int','bool'],[@A_T,@A_seed,@A_seed2,@A_min_object_covered,@A_aspect_ratio_range,@A_area_range,@A_max_attempts,@A_use_image_if_no_bounding_boxes])
  end;
function TGraphExt.AddSampleDistortedBoundingBoxV2(const I_image_size:string; const I_bounding_boxes:string; const I_min_object_covered:string; const O_begin:string; const O_size:string; const O_bboxes:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64; const A_aspect_ratio_range:TF_FloatList; const A_area_range:TF_FloatList; const A_max_attempts:cint64; const A_use_image_if_no_bounding_boxes:boolean):string;
  begin
  result:=AddOper('SampleDistortedBoundingBoxV2',[I_image_size,I_bounding_boxes,I_min_object_covered],[],[O_begin,O_size,O_bboxes],['T','seed','seed2','aspect_ratio_range','area_range','max_attempts','use_image_if_no_bounding_boxes'],['type','int','int','list(float)','list(float)','int','bool'],[@A_T,@A_seed,@A_seed2,@A_aspect_ratio_range,@A_area_range,@A_max_attempts,@A_use_image_if_no_bounding_boxes])
  end;
function TGraphExt.AddSave(const I_filename:string; const I_tensor_names:string; const IL_data:TF_StringList; const A_T:TF_TypeList):string;
  begin
  result:=AddOper('Save',[I_filename,I_tensor_names],[IL_data],[],['T'],['list(type)'],[@A_T])
  end;
function TGraphExt.AddSaveSlices(const I_filename:string; const I_tensor_names:string; const I_shapes_and_slices:string; const IL_data:TF_StringList; const A_T:TF_TypeList):string;
  begin
  result:=AddOper('SaveSlices',[I_filename,I_tensor_names,I_shapes_and_slices],[IL_data],[],['T'],['list(type)'],[@A_T])
  end;
function TGraphExt.AddSaveV2(const I_prefix:string; const I_tensor_names:string; const I_shape_and_slices:string; const IL_tensors:TF_StringList; const A_dtypes:TF_TypeList):string;
  begin
  result:=AddOper('SaveV2',[I_prefix,I_tensor_names,I_shape_and_slices],[IL_tensors],[],['dtypes'],['list(type)'],[@A_dtypes])
  end;
function TGraphExt.AddScalarSummary(const I_tags:string; const I_values:string; const O_summary:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ScalarSummary',[I_tags,I_values],[],[O_summary],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddScatterAdd(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterAdd',[I_ref,I_indices,I_updates],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterDiv(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterDiv',[I_ref,I_indices,I_updates],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterMul(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterMul',[I_ref,I_indices,I_updates],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterNd(const I_indices:string; const I_updates:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ScatterNd',[I_indices,I_updates,I_shape],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddScatterNdAdd(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterNdAdd',[I_ref,I_indices,I_updates],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterNdNonAliasingAdd(const I_input:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ScatterNdNonAliasingAdd',[I_input,I_indices,I_updates],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddScatterNdSub(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterNdSub',[I_ref,I_indices,I_updates],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterNdUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterNdUpdate',[I_ref,I_indices,I_updates],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterSub(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterSub',[I_ref,I_indices,I_updates],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterUpdate',[I_ref,I_indices,I_updates],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSdcaFprint(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('SdcaFprint',[I_input],[],[O_output],[],[],[])
  end;
function TGraphExt.AddSdcaOptimizer(const I_example_weights:string; const I_example_labels:string; const I_example_state_data:string; const IL_sparse_example_indices:TF_StringList; const IL_sparse_feature_indices:TF_StringList; const IL_sparse_feature_values:TF_StringList; const IL_dense_features:TF_StringList; const IL_sparse_indices:TF_StringList; const IL_sparse_weights:TF_StringList; const IL_dense_weights:TF_StringList; const O_out_example_state_data:string; const OL_out_delta_sparse_weights:TF_StringList; const OL_out_delta_dense_weights:TF_StringList; const A_loss_type:string; const A_adaptative:boolean; const A_num_sparse_features:cint64; const A_num_sparse_features_with_values:cint64; const A_num_dense_features:cint64; const A_l1:real; const A_l2:real; const A_num_loss_partitions:cint64; const A_num_inner_iterations:cint64):string;
  var
    OutputNames : TF_StringList=nil;
    Index       : integer;
    Counter     : integer;
  begin
  SetLength(OutputNames,1+Length(OL_out_delta_sparse_weights)+Length(OL_out_delta_dense_weights));
  Outputnames[0]:=O_out_example_state_data;
  Counter:=1;
  for Index:=0 to Length(OL_out_delta_sparse_weights)-1 do
    OutputNames[Counter+Index]:=OL_out_delta_sparse_weights[Index];
  Counter:=Counter+Length(OL_out_delta_sparse_weights);
  for Index:=0 to Length(OL_out_delta_dense_weights)-1 do
    OutputNames[Counter+Index]:=OL_out_delta_dense_weights[Index];
  result:=AddOper('SdcaOptimizer',[I_example_weights,I_example_labels,I_example_state_data],[IL_sparse_example_indices,IL_sparse_feature_indices,IL_sparse_feature_values,IL_dense_features,IL_sparse_indices,IL_sparse_weights,IL_dense_weights],OutputNames,['loss_type','adaptative','num_sparse_features','num_sparse_features_with_values','num_dense_features','l1','l2','num_loss_partitions','num_inner_iterations'],['string','bool','int','int','int','float','float','int','int'],[@A_loss_type,@A_adaptative,@A_num_sparse_features,@A_num_sparse_features_with_values,@A_num_dense_features,@A_l1,@A_l2,@A_num_loss_partitions,@A_num_inner_iterations])
  end;
function TGraphExt.AddSdcaShrinkL1(const IL_weights:TF_StringList; const A_num_features:cint64; const A_l1:real; const A_l2:real):string;
  begin
  result:=AddOper('SdcaShrinkL1',[],[IL_weights],[],['num_features','l1','l2'],['int','float','float'],[@A_num_features,@A_l1,@A_l2])
  end;
function TGraphExt.AddSegmentMax(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentMax',[I_data,I_segment_ids],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSegmentMean(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentMean',[I_data,I_segment_ids],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSegmentMin(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentMin',[I_data,I_segment_ids],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSegmentProd(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentProd',[I_data,I_segment_ids],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSegmentSum(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentSum',[I_data,I_segment_ids],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSelect(const I_condition:string; const I_t:string; const I_e:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Select',[I_condition,I_t,I_e],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSelfAdjointEig(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SelfAdjointEig',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSelfAdjointEigV2(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SelfAdjointEigV2',[I_input],[],[O_e,O_v],['compute_v','T'],['bool','type'],[@A_compute_v,@A_T])
  end;
function TGraphExt.AddSerializeManySparse(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_serialized_sparse:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SerializeManySparse',[I_sparse_indices,I_sparse_values,I_sparse_shape],[],[O_serialized_sparse],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSerializeSparse(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_serialized_sparse:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SerializeSparse',[I_sparse_indices,I_sparse_values,I_sparse_shape],[],[O_serialized_sparse],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSetSize(const I_set_indices:string; const I_set_values:string; const I_set_shape:string; const O_size:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SetSize',[I_set_indices,I_set_values,I_set_shape],[],[O_size],['validate_indices','T'],['bool','type'],[@A_validate_indices,@A_T])
  end;
function TGraphExt.AddShape(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('Shape',[I_input],[],[O_output],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddShapeN(const IL_input:TF_StringList; const OL_output:TF_StringList; const A_N:cint64; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('ShapeN',[],[IL_input],OL_output,['N','T','out_type'],['int','type','type'],[@A_N,@A_T,@A_out_type])
  end;
function TGraphExt.AddShardedFilename(const I_basename:string; const I_shard:string; const I_num_shards:string; const O_filename:string):string;
  begin
  result:=AddOper('ShardedFilename',[I_basename,I_shard,I_num_shards],[],[O_filename],[],[],[])
  end;
function TGraphExt.AddShardedFilespec(const I_basename:string; const I_num_shards:string; const O_filename:string):string;
  begin
  result:=AddOper('ShardedFilespec',[I_basename,I_num_shards],[],[O_filename],[],[],[])
  end;
function TGraphExt.AddShuffleDataset(const I_input_dataset:string; const I_buffer_size:string; const I_seed:string; const I_seed2:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ShuffleDataset',[I_input_dataset,I_buffer_size,I_seed,I_seed2],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddSigmoid(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sigmoid',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSigmoidGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SigmoidGrad',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSign(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sign',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sin',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSinh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sinh',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSize(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('Size',[I_input],[],[O_output],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddSkipDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('SkipDataset',[I_input_dataset,I_count],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddSkipgram(const O_vocab_word:string; const O_vocab_freq:string; const O_words_per_epoch:string; const O_current_epoch:string; const O_total_words_processed:string; const O_examples:string; const O_labels:string; const A_filename:string; const A_batch_size:cint64; const A_window_size:cint64; const A_min_count:cint64; const A_subsample:real):string;
  begin
  result:=AddOper('Skipgram',[],[],[O_vocab_word,O_vocab_freq,O_words_per_epoch,O_current_epoch,O_total_words_processed,O_examples,O_labels],['filename','batch_size','window_size','min_count','subsample'],['string','int','int','int','float'],[@A_filename,@A_batch_size,@A_window_size,@A_min_count,@A_subsample])
  end;
function TGraphExt.AddSlice(const I_input:string; const I_begin:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType):string;
  begin
  result:=AddOper('Slice',[I_input,I_begin,I_size],[],[O_output],['T','Index'],['type','type'],[@A_T,@A_Index])
  end;
function TGraphExt.AddSoftmax(const I_logits:string; const O_softmax:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Softmax',[I_logits],[],[O_softmax],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftmaxCrossEntropyWithLogits(const I_features:string; const I_labels:string; const O_loss:string; const O_backprop:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SoftmaxCrossEntropyWithLogits',[I_features,I_labels],[],[O_loss,O_backprop],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftplus(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Softplus',[I_features],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftplusGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SoftplusGrad',[I_gradients,I_features],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftsign(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Softsign',[I_features],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftsignGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SoftsignGrad',[I_gradients,I_features],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSpaceToBatch(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_block_size:cint64):string;
  begin
  result:=AddOper('SpaceToBatch',[I_input,I_paddings],[],[O_output],['T','Tpaddings','block_size'],['type','type','int'],[@A_T,@A_Tpaddings,@A_block_size])
  end;
function TGraphExt.AddSpaceToBatchND(const I_input:string; const I_block_shape:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tblock_shape:TF_DataType; const A_Tpaddings:TF_DataType):string;
  begin
  result:=AddOper('SpaceToBatchND',[I_input,I_block_shape,I_paddings],[],[O_output],['T','Tblock_shape','Tpaddings'],['type','type','type'],[@A_T,@A_Tblock_shape,@A_Tpaddings])
  end;
function TGraphExt.AddSpaceToDepth(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64):string;
  begin
  result:=AddOper('SpaceToDepth',[I_input],[],[O_output],['T','block_size'],['type','int'],[@A_T,@A_block_size])
  end;
function TGraphExt.AddSparseAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient_indices:string; const I_gradient_values:string; const I_gradient_shape:string; const A_dtype:TF_DataType; const A_has_known_shape:boolean):string;
  begin
  result:=AddOper('SparseAccumulatorApplyGradient',[I_handle,I_local_step,I_gradient_indices,I_gradient_values,I_gradient_shape],[],[],['dtype','has_known_shape'],['type','bool'],[@A_dtype,@A_has_known_shape])
  end;
function TGraphExt.AddSparseAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_indices:string; const O_values:string; const O_shape:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('SparseAccumulatorTakeGradient',[I_handle,I_num_required],[],[O_indices,O_values,O_shape],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddSparseAdd(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const I_thresh:string; const O_sum_indices:string; const O_sum_values:string; const O_sum_shape:string; const A_T:TF_DataType; const A_Treal:TF_DataType):string;
  begin
  result:=AddOper('SparseAdd',[I_a_indices,I_a_values,I_a_shape,I_b_indices,I_b_values,I_b_shape,I_thresh],[],[O_sum_indices,O_sum_values,O_sum_shape],['T','Treal'],['type','type'],[@A_T,@A_Treal])
  end;
function TGraphExt.AddSparseAddGrad(const I_backprop_val_grad:string; const I_a_indices:string; const I_b_indices:string; const I_sum_indices:string; const O_a_val_grad:string; const O_b_val_grad:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseAddGrad',[I_backprop_val_grad,I_a_indices,I_b_indices,I_sum_indices],[],[O_a_val_grad,O_b_val_grad],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad,I_indices],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyAdagrad',[I_var,I_accum,I_lr,I_grad,I_indices],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_indices,I_lr,I_l1,I_l2,I_global_step],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_lr_power],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('SparseApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_indices,I_momentum],[],[O_out],['T','Tindices','use_locking','use_nesterov'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddSparseApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad,I_indices],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_grad,I_indices],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseConcat(const IL_indices:TF_StringList; const IL_values:TF_StringList; const IL_shapes:TF_StringList; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_concat_dim:cint64; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseConcat',[],[IL_indices,IL_values,IL_shapes],[O_output_indices,O_output_values,O_output_shape],['concat_dim','N','T'],['int','int','type'],[@A_concat_dim,@A_N,@A_T])
  end;
function TGraphExt.AddSparseConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('SparseConditionalAccumulator',[],[],[O_handle],['dtype','shape','container','shared_name'],['type','shape','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name])
  end;
function TGraphExt.AddSparseCross(const IL_indices:TF_StringList; const IL_values:TF_StringList; const IL_shapes:TF_StringList; const IL_dense_inputs:TF_StringList; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_N:cint64; const A_hashed_output:boolean; const A_num_buckets:cint64; const A_hash_key:cint64; const A_sparse_types:TF_TypeList; const A_dense_types:TF_TypeList; const A_out_type:TF_DataType; const A_internal_type:TF_DataType):string;
  begin
  result:=AddOper('SparseCross',[],[IL_indices,IL_values,IL_shapes,IL_dense_inputs],[O_output_indices,O_output_values,O_output_shape],['N','hashed_output','num_buckets','hash_key','sparse_types','dense_types','out_type','internal_type'],['int','bool','int','int','list(type)','list(type)','type','type'],[@A_N,@A_hashed_output,@A_num_buckets,@A_hash_key,@A_sparse_types,@A_dense_types,@A_out_type,@A_internal_type])
  end;
function TGraphExt.AddSparseDenseCwiseAdd(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseDenseCwiseAdd',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseDenseCwiseDiv(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseDenseCwiseDiv',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseDenseCwiseMul(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseDenseCwiseMul',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseFillEmptyRows(const I_indices:string; const I_values:string; const I_dense_shape:string; const I_default_value:string; const O_output_indices:string; const O_output_values:string; const O_empty_row_indicator:string; const O_reverse_index_map:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseFillEmptyRows',[I_indices,I_values,I_dense_shape,I_default_value],[],[O_output_indices,O_output_values,O_empty_row_indicator,O_reverse_index_map],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseFillEmptyRowsGrad(const I_reverse_index_map:string; const I_grad_values:string; const O_d_values:string; const O_d_default_value:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseFillEmptyRowsGrad',[I_reverse_index_map,I_grad_values],[],[O_d_values,O_d_default_value],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseMatMul(const I_a:string; const I_b:string; const O_product:string; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_a_is_sparse:boolean; const A_b_is_sparse:boolean; const A_Ta:TF_DataType; const A_Tb:TF_DataType):string;
  begin
  result:=AddOper('SparseMatMul',[I_a,I_b],[],[O_product],['transpose_a','transpose_b','a_is_sparse','b_is_sparse','Ta','Tb'],['bool','bool','bool','bool','type','type'],[@A_transpose_a,@A_transpose_b,@A_a_is_sparse,@A_b_is_sparse,@A_Ta,@A_Tb])
  end;
function TGraphExt.AddSparseReduceMax(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReduceMax',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],[],[O_output],['keep_dims','T'],['bool','type'],[@A_keep_dims,@A_T])
  end;
function TGraphExt.AddSparseReduceMaxSparse(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReduceMaxSparse',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],[],[O_output_indices,O_output_values,O_output_shape],['keep_dims','T'],['bool','type'],[@A_keep_dims,@A_T])
  end;
function TGraphExt.AddSparseReduceSum(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReduceSum',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],[],[O_output],['keep_dims','T'],['bool','type'],[@A_keep_dims,@A_T])
  end;
function TGraphExt.AddSparseReduceSumSparse(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReduceSumSparse',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],[],[O_output_indices,O_output_values,O_output_shape],['keep_dims','T'],['bool','type'],[@A_keep_dims,@A_T])
  end;
function TGraphExt.AddSparseReorder(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReorder',[I_input_indices,I_input_values,I_input_shape],[],[O_output_indices,O_output_values],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseReshape(const I_input_indices:string; const I_input_shape:string; const I_new_shape:string; const O_output_indices:string; const O_output_shape:string):string;
  begin
  result:=AddOper('SparseReshape',[I_input_indices,I_input_shape,I_new_shape],[],[O_output_indices,O_output_shape],[],[],[])
  end;
function TGraphExt.AddSparseSegmentMean(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentMean',[I_data,I_indices,I_segment_ids],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentMeanGrad(const I_grad:string; const I_indices:string; const I_segment_ids:string; const I_output_dim0:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentMeanGrad',[I_grad,I_indices,I_segment_ids,I_output_dim0],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentSqrtN(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentSqrtN',[I_data,I_indices,I_segment_ids],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentSqrtNGrad(const I_grad:string; const I_indices:string; const I_segment_ids:string; const I_output_dim0:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentSqrtNGrad',[I_grad,I_indices,I_segment_ids,I_output_dim0],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentSum(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentSum',[I_data,I_indices,I_segment_ids],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSlice(const I_indices:string; const I_values:string; const I_shape:string; const I_start:string; const I_size:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSlice',[I_indices,I_values,I_shape,I_start,I_size],[],[O_output_indices,O_output_values,O_output_shape],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSoftmax(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSoftmax',[I_sp_indices,I_sp_values,I_sp_shape],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSoftmaxCrossEntropyWithLogits(const I_features:string; const I_labels:string; const O_loss:string; const O_backprop:string; const A_T:TF_DataType; const A_Tlabels:TF_DataType):string;
  begin
  result:=AddOper('SparseSoftmaxCrossEntropyWithLogits',[I_features,I_labels],[],[O_loss,O_backprop],['T','Tlabels'],['type','type'],[@A_T,@A_Tlabels])
  end;
function TGraphExt.AddSparseSparseMaximum(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSparseMaximum',[I_a_indices,I_a_values,I_a_shape,I_b_indices,I_b_values,I_b_shape],[],[O_output_indices,O_output_values],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSparseMinimum(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSparseMinimum',[I_a_indices,I_a_values,I_a_shape,I_b_indices,I_b_values,I_b_shape],[],[O_output_indices,O_output_values],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSplit(const I_split_dim:string; const I_indices:string; const I_values:string; const I_shape:string; const OL_output_indices:TF_StringList; const OL_output_values:TF_StringList; const OL_output_shape:TF_StringList; const A_num_split:cint64; const A_T:TF_DataType):string;
  var
    OutputNames : TF_StringList=nil;
    Index       : integer;
    Counter     : integer;
  begin
  SetLength(OutputNames,Length(OL_output_indices)+Length(OL_output_values)+Length(OL_output_shape));
  Counter:=0;
  for Index:=0 to Length(OL_output_indices)-1 do
    OutputNames[Counter+Index]:=OL_output_indices[Index];
  Counter:=Counter+Length(OL_output_indices);
  for Index:=0 to Length(OL_output_values)-1 do
    OutputNames[Counter+Index]:=OL_output_values[Index];
  Counter:=Counter+Length(OL_output_values);
  for Index:=0 to Length(OL_output_shape)-1 do
    OutputNames[Counter+Index]:=OL_output_shape[Index];
  result:=AddOper('SparseSplit',[I_split_dim,I_indices,I_values,I_shape],[],OutputNames,['num_split','T'],['int','type'],[@A_num_split,@A_T])
  end;
function TGraphExt.AddSparseTensorDenseAdd(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SparseTensorDenseAdd',[I_a_indices,I_a_values,I_a_shape,I_b],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSparseTensorDenseMatMul(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b:string; const O_product:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_adjoint_a:boolean; const A_adjoint_b:boolean):string;
  begin
  result:=AddOper('SparseTensorDenseMatMul',[I_a_indices,I_a_values,I_a_shape,I_b],[],[O_product],['T','Tindices','adjoint_a','adjoint_b'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_adjoint_a,@A_adjoint_b])
  end;
function TGraphExt.AddSparseTensorSliceDataset(const I_indices:string; const I_values:string; const I_dense_shape:string; const O_handle:string; const A_Tvalues:TF_DataType):string;
  begin
  result:=AddOper('SparseTensorSliceDataset',[I_indices,I_values,I_dense_shape],[],[O_handle],['Tvalues'],['type'],[@A_Tvalues])
  end;
function TGraphExt.AddSparseToDense(const I_sparse_indices:string; const I_output_shape:string; const I_sparse_values:string; const I_default_value:string; const O_dense:string; const A_validate_indices:boolean; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SparseToDense',[I_sparse_indices,I_output_shape,I_sparse_values,I_default_value],[],[O_dense],['validate_indices','T','Tindices'],['bool','type','type'],[@A_validate_indices,@A_T,@A_Tindices])
  end;
function TGraphExt.AddSparseToSparseSetOperation(const I_set1_indices:string; const I_set1_values:string; const I_set1_shape:string; const I_set2_indices:string; const I_set2_values:string; const I_set2_shape:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseToSparseSetOperation',[I_set1_indices,I_set1_values,I_set1_shape,I_set2_indices,I_set2_values,I_set2_shape],[],[O_result_indices,O_result_values,O_result_shape],['set_operation','validate_indices','T'],['string','bool','type'],[@A_set_operation,@A_validate_indices,@A_T])
  end;
function TGraphExt.AddSplit(const I_split_dim:string; const I_value:string; const OL_output:TF_StringList; const A_num_split:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Split',[I_split_dim,I_value],[],OL_output,['num_split','T'],['int','type'],[@A_num_split,@A_T])
  end;
function TGraphExt.AddSplitV(const I_value:string; const I_size_splits:string; const I_split_dim:string; const OL_output:TF_StringList; const A_num_split:cint64; const A_T:TF_DataType; const A_Tlen:TF_DataType):string;
  begin
  result:=AddOper('SplitV',[I_value,I_size_splits,I_split_dim],[],OL_output,['num_split','T','Tlen'],['int','type','type'],[@A_num_split,@A_T,@A_Tlen])
  end;
function TGraphExt.AddSqrt(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sqrt',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSqrtGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SqrtGrad',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSquare(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Square',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSquaredDifference(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SquaredDifference',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSqueeze(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_squeeze_dims:TF_IntList):string;
  begin
  result:=AddOper('Squeeze',[I_input],[],[O_output],['T','squeeze_dims'],['type','list(int)'],[@A_T,@A_squeeze_dims])
  end;
function TGraphExt.AddStack(const O_handle:string; const A_elem_type:TF_DataType; const A_stack_name:string):string;
  begin
  result:=AddOper('Stack',[],[],[O_handle],['elem_type','stack_name'],['type','string'],[@A_elem_type,@A_stack_name])
  end;
function TGraphExt.AddStackClose(const I_handle:string):string;
  begin
  result:=AddOper('StackClose',[I_handle],[],[],[],[],[])
  end;
function TGraphExt.AddStackCloseV2(const I_handle:string):string;
  begin
  result:=AddOper('StackCloseV2',[I_handle],[],[],[],[],[])
  end;
function TGraphExt.AddStackPop(const I_handle:string; const O_elem:string; const A_elem_type:TF_DataType):string;
  begin
  result:=AddOper('StackPop',[I_handle],[],[O_elem],['elem_type'],['type'],[@A_elem_type])
  end;
function TGraphExt.AddStackPopV2(const I_handle:string; const O_elem:string; const A_elem_type:TF_DataType):string;
  begin
  result:=AddOper('StackPopV2',[I_handle],[],[O_elem],['elem_type'],['type'],[@A_elem_type])
  end;
function TGraphExt.AddStackPush(const I_handle:string; const I_elem:string; const O_output:string; const A_T:TF_DataType; const A_swap_memory:boolean):string;
  begin
  result:=AddOper('StackPush',[I_handle,I_elem],[],[O_output],['T','swap_memory'],['type','bool'],[@A_T,@A_swap_memory])
  end;
function TGraphExt.AddStackPushV2(const I_handle:string; const I_elem:string; const O_output:string; const A_T:TF_DataType; const A_swap_memory:boolean):string;
  begin
  result:=AddOper('StackPushV2',[I_handle,I_elem],[],[O_output],['T','swap_memory'],['type','bool'],[@A_T,@A_swap_memory])
  end;
function TGraphExt.AddStackV2(const I_max_size:string; const O_handle:string; const A_elem_type:TF_DataType; const A_stack_name:string):string;
  begin
  result:=AddOper('StackV2',[I_max_size],[],[O_handle],['elem_type','stack_name'],['type','string'],[@A_elem_type,@A_stack_name])
  end;
function TGraphExt.AddStage(const IL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('Stage',[],[IL_values],[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddStageClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('StageClear',[],[],[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddStagePeek(const I_index:string; const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('StagePeek',[I_index],[],OL_values,['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddStageSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('StageSize',[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddStatelessRandomNormal(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('StatelessRandomNormal',[I_shape,I_seed],[],[O_output],['dtype','T'],['type','type'],[@A_dtype,@A_T])
  end;
function TGraphExt.AddStatelessRandomUniform(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('StatelessRandomUniform',[I_shape,I_seed],[],[O_output],['dtype','T'],['type','type'],[@A_dtype,@A_T])
  end;
function TGraphExt.AddStatelessTruncatedNormal(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('StatelessTruncatedNormal',[I_shape,I_seed],[],[O_output],['dtype','T'],['type','type'],[@A_dtype,@A_T])
  end;
function TGraphExt.AddStopGradient(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('StopGradient',[I_input],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddStridedSlice(const I_input:string; const I_begin:string; const I_end:string; const I_strides:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('StridedSlice',[I_input,I_begin,I_end,I_strides],[],[O_output],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddStridedSliceAssign(const I_ref:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('StridedSliceAssign',[I_ref,I_begin,I_end,I_strides,I_value],[],[O_output_ref],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddStridedSliceGrad(const I_shape:string; const I_begin:string; const I_end:string; const I_strides:string; const I_dy:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('StridedSliceGrad',[I_shape,I_begin,I_end,I_strides,I_dy],[],[O_output],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddStringJoin(const IL_inputs:TF_StringList; const O_output:string; const A_N:cint64; const A_separator:string):string;
  begin
  result:=AddOper('StringJoin',[],[IL_inputs],[O_output],['N','separator'],['int','string'],[@A_N,@A_separator])
  end;
function TGraphExt.AddStringSplit(const I_input:string; const I_delimiter:string; const O_indices:string; const O_values:string; const O_shape:string):string;
  begin
  result:=AddOper('StringSplit',[I_input,I_delimiter],[],[O_indices,O_values,O_shape],[],[],[])
  end;
function TGraphExt.AddStringToHashBucket(const I_string_tensor:string; const O_output:string; const A_num_buckets:cint64):string;
  begin
  result:=AddOper('StringToHashBucket',[I_string_tensor],[],[O_output],['num_buckets'],['int'],[@A_num_buckets])
  end;
function TGraphExt.AddStringToHashBucketFast(const I_input:string; const O_output:string; const A_num_buckets:cint64):string;
  begin
  result:=AddOper('StringToHashBucketFast',[I_input],[],[O_output],['num_buckets'],['int'],[@A_num_buckets])
  end;
function TGraphExt.AddStringToHashBucketStrong(const I_input:string; const O_output:string; const A_num_buckets:cint64; const A_key:TF_IntList):string;
  begin
  result:=AddOper('StringToHashBucketStrong',[I_input],[],[O_output],['num_buckets','key'],['int','list(int)'],[@A_num_buckets,@A_key])
  end;
function TGraphExt.AddStringToNumber(const I_string_tensor:string; const O_output:string; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('StringToNumber',[I_string_tensor],[],[O_output],['out_type'],['type'],[@A_out_type])
  end;
function TGraphExt.AddSub(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sub',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSubstr(const I_input:string; const I_pos:string; const I_len:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Substr',[I_input,I_pos,I_len],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSum(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Sum',[I_input,I_reduction_indices],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddSvd(const I_input:string; const O_s:string; const O_u:string; const O_v:string; const A_compute_uv:boolean; const A_full_matrices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Svd',[I_input],[],[O_s,O_u,O_v],['compute_uv','full_matrices','T'],['bool','bool','type'],[@A_compute_uv,@A_full_matrices,@A_T])
  end;
function TGraphExt.AddSwitch(const I_data:string; const I_pred:string; const O_output_false:string; const O_output_true:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Switch',[I_data,I_pred],[],[O_output_false,O_output_true],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSymbolicGradient(const IL_input:TF_StringList; const OL_output:TF_StringList; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function):string;
  begin
  result:=AddOper('SymbolicGradient',[],[IL_input],OL_output,['Tin','Tout','f'],['list(type)','list(type)','func'],[@A_Tin,@A_Tout,@A_f])
  end;
function TGraphExt.AddTFRecordDataset(const I_filenames:string; const I_compression_type:string; const O_handle:string):string;
  begin
  result:=AddOper('TFRecordDataset',[I_filenames,I_compression_type],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddTFRecordReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string; const A_compression_type:string):string;
  begin
  result:=AddOper('TFRecordReader',[],[],[O_reader_handle],['container','shared_name','compression_type'],['string','string','string'],[@A_container,@A_shared_name,@A_compression_type])
  end;
function TGraphExt.AddTFRecordReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string; const A_compression_type:string):string;
  begin
  result:=AddOper('TFRecordReaderV2',[],[],[O_reader_handle],['container','shared_name','compression_type'],['string','string','string'],[@A_container,@A_shared_name,@A_compression_type])
  end;
function TGraphExt.AddTakeDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('TakeDataset',[I_input_dataset,I_count],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddTakeManySparseFromTensorsMap(const I_sparse_handles:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('TakeManySparseFromTensorsMap',[I_sparse_handles],[],[O_sparse_indices,O_sparse_values,O_sparse_shape],['dtype','container','shared_name'],['type','string','string'],[@A_dtype,@A_container,@A_shared_name])
  end;
function TGraphExt.AddTan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Tan',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTanh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Tanh',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTanhGrad(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TanhGrad',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTemporaryVariable(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_var_name:string):string;
  begin
  result:=AddOper('TemporaryVariable',[],[],[O_ref],['shape','dtype','var_name'],['shape','type','string'],[@A_shape,@A_dtype,@A_var_name])
  end;
function TGraphExt.AddTensorArray(const I_size:string; const O_handle:string; const A_dtype:TF_DataType; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArray',[I_size],[],[O_handle],['dtype','dynamic_size','clear_after_read','tensor_array_name','element_shape'],['type','bool','bool','string','shape'],[@A_dtype,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayClose(const I_handle:string):string;
  begin
  result:=AddOper('TensorArrayClose',[I_handle],[],[],[],[],[])
  end;
function TGraphExt.AddTensorArrayCloseV2(const I_handle:string):string;
  begin
  result:=AddOper('TensorArrayCloseV2',[I_handle],[],[],[],[],[])
  end;
function TGraphExt.AddTensorArrayCloseV3(const I_handle:string):string;
  begin
  result:=AddOper('TensorArrayCloseV3',[I_handle],[],[],[],[],[])
  end;
function TGraphExt.AddTensorArrayConcat(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayConcat',[I_handle,I_flow_in],[],[O_value,O_lengths],['dtype','element_shape_except0'],['type','shape'],[@A_dtype,@A_element_shape_except0])
  end;
function TGraphExt.AddTensorArrayConcatV2(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayConcatV2',[I_handle,I_flow_in],[],[O_value,O_lengths],['dtype','element_shape_except0'],['type','shape'],[@A_dtype,@A_element_shape_except0])
  end;
function TGraphExt.AddTensorArrayConcatV3(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayConcatV3',[I_handle,I_flow_in],[],[O_value,O_lengths],['dtype','element_shape_except0'],['type','shape'],[@A_dtype,@A_element_shape_except0])
  end;
function TGraphExt.AddTensorArrayGather(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayGather',[I_handle,I_indices,I_flow_in],[],[O_value],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayGatherV2(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayGatherV2',[I_handle,I_indices,I_flow_in],[],[O_value],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayGatherV3(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayGatherV3',[I_handle,I_indices,I_flow_in],[],[O_value],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayGrad(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const A_source:string):string;
  begin
  result:=AddOper('TensorArrayGrad',[I_handle,I_flow_in],[],[O_grad_handle],['source'],['string'],[@A_source])
  end;
function TGraphExt.AddTensorArrayGradV2(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const A_source:string):string;
  begin
  result:=AddOper('TensorArrayGradV2',[I_handle,I_flow_in],[],[O_grad_handle],['source'],['string'],[@A_source])
  end;
function TGraphExt.AddTensorArrayGradV3(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const O_flow_out:string; const A_source:string):string;
  begin
  result:=AddOper('TensorArrayGradV3',[I_handle,I_flow_in],[],[O_grad_handle,O_flow_out],['source'],['string'],[@A_source])
  end;
function TGraphExt.AddTensorArrayPack(const I_handle:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayPack',[I_handle,I_flow_in],[],[O_value],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayRead(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayRead',[I_handle,I_index,I_flow_in],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddTensorArrayReadV2(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayReadV2',[I_handle,I_index,I_flow_in],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddTensorArrayReadV3(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayReadV3',[I_handle,I_index,I_flow_in],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddTensorArrayScatter(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayScatter',[I_handle,I_indices,I_value,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayScatterV2(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayScatterV2',[I_handle,I_indices,I_value,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayScatterV3(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayScatterV3',[I_handle,I_indices,I_value,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArraySize(const I_handle:string; const I_flow_in:string; const O_size:string):string;
  begin
  result:=AddOper('TensorArraySize',[I_handle,I_flow_in],[],[O_size],[],[],[])
  end;
function TGraphExt.AddTensorArraySizeV2(const I_handle:string; const I_flow_in:string; const O_size:string):string;
  begin
  result:=AddOper('TensorArraySizeV2',[I_handle,I_flow_in],[],[O_size],[],[],[])
  end;
function TGraphExt.AddTensorArraySizeV3(const I_handle:string; const I_flow_in:string; const O_size:string):string;
  begin
  result:=AddOper('TensorArraySizeV3',[I_handle,I_flow_in],[],[O_size],[],[],[])
  end;
function TGraphExt.AddTensorArraySplit(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArraySplit',[I_handle,I_value,I_lengths,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArraySplitV2(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArraySplitV2',[I_handle,I_value,I_lengths,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArraySplitV3(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArraySplitV3',[I_handle,I_value,I_lengths,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayUnpack(const I_handle:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayUnpack',[I_handle,I_value,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayV2(const I_size:string; const O_handle:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string):string;
  begin
  result:=AddOper('TensorArrayV2',[I_size],[],[O_handle],['dtype','element_shape','dynamic_size','clear_after_read','tensor_array_name'],['type','shape','bool','bool','string'],[@A_dtype,@A_element_shape,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name])
  end;
function TGraphExt.AddTensorArrayV3(const I_size:string; const O_handle:string; const O_flow:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string):string;
  begin
  result:=AddOper('TensorArrayV3',[I_size],[],[O_handle,O_flow],['dtype','element_shape','dynamic_size','clear_after_read','tensor_array_name'],['type','shape','bool','bool','string'],[@A_dtype,@A_element_shape,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name])
  end;
function TGraphExt.AddTensorArrayWrite(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayWrite',[I_handle,I_index,I_value,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayWriteV2(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayWriteV2',[I_handle,I_index,I_value,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayWriteV3(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayWriteV3',[I_handle,I_index,I_value,I_flow_in],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorDataset(const IL_components:TF_StringList; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('TensorDataset',[],[IL_components],[O_handle],['Toutput_types','output_shapes'],['list(type)','list(shape)'],[@A_Toutput_types,@A_output_shapes])
  end;
function TGraphExt.AddTensorSliceDataset(const IL_components:TF_StringList; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('TensorSliceDataset',[],[IL_components],[O_handle],['Toutput_types','output_shapes'],['list(type)','list(shape)'],[@A_Toutput_types,@A_output_shapes])
  end;
function TGraphExt.AddTensorSummary(const I_tensor:string; const O_summary:string; const A_T:TF_DataType; const A_description:string; const A_labels:TF_StringList; const A_display_name:string):string;
  begin
  result:=AddOper('TensorSummary',[I_tensor],[],[O_summary],['T','description','labels','display_name'],['type','string','list(string)','string'],[@A_T,@A_description,@A_labels,@A_display_name])
  end;
function TGraphExt.AddTensorSummaryV2(const I_tag:string; const I_tensor:string; const I_serialized_summary_metadata:string; const O_summary:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorSummaryV2',[I_tag,I_tensor,I_serialized_summary_metadata],[],[O_summary],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTextLineDataset(const I_filenames:string; const I_compression_type:string; const O_handle:string):string;
  begin
  result:=AddOper('TextLineDataset',[I_filenames,I_compression_type],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddTextLineReader(const O_reader_handle:string; const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('TextLineReader',[],[],[O_reader_handle],['skip_header_lines','container','shared_name'],['int','string','string'],[@A_skip_header_lines,@A_container,@A_shared_name])
  end;
function TGraphExt.AddTextLineReaderV2(const O_reader_handle:string; const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('TextLineReaderV2',[],[],[O_reader_handle],['skip_header_lines','container','shared_name'],['int','string','string'],[@A_skip_header_lines,@A_container,@A_shared_name])
  end;
function TGraphExt.AddThreadUnsafeUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('ThreadUnsafeUnigramCandidateSampler',[I_true_classes],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','seed','seed2'],['int','int','bool','int','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_seed,@A_seed2])
  end;
function TGraphExt.AddTile(const I_input:string; const I_multiples:string; const O_output:string; const A_T:TF_DataType; const A_Tmultiples:TF_DataType):string;
  begin
  result:=AddOper('Tile',[I_input,I_multiples],[],[O_output],['T','Tmultiples'],['type','type'],[@A_T,@A_Tmultiples])
  end;
function TGraphExt.AddTileGrad(const I_input:string; const I_multiples:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TileGrad',[I_input,I_multiples],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTopK(const I_input:string; const O_values:string; const O_indices:string; const A_k:cint64; const A_sorted:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TopK',[I_input],[],[O_values,O_indices],['k','sorted','T'],['int','bool','type'],[@A_k,@A_sorted,@A_T])
  end;
function TGraphExt.AddTopKV2(const I_input:string; const I_k:string; const O_values:string; const O_indices:string; const A_sorted:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TopKV2',[I_input,I_k],[],[O_values,O_indices],['sorted','T'],['bool','type'],[@A_sorted,@A_T])
  end;
function TGraphExt.AddTranspose(const I_x:string; const I_perm:string; const O_y:string; const A_T:TF_DataType; const A_Tperm:TF_DataType):string;
  begin
  result:=AddOper('Transpose',[I_x,I_perm],[],[O_y],['T','Tperm'],['type','type'],[@A_T,@A_Tperm])
  end;
function TGraphExt.AddTruncateDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TruncateDiv',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTruncateMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TruncateMod',[I_x,I_y],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTruncatedNormal(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TruncatedNormal',[I_shape],[],[O_output],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@A_T])
  end;
function TGraphExt.AddUniformCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('UniformCandidateSampler',[I_true_classes],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','seed','seed2'],['int','int','bool','int','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_seed,@A_seed2])
  end;
function TGraphExt.AddUnique(const I_x:string; const O_y:string; const O_idx:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
  begin
  result:=AddOper('Unique',[I_x],[],[O_y,O_idx],['T','out_idx'],['type','type'],[@A_T,@A_out_idx])
  end;
function TGraphExt.AddUniqueWithCounts(const I_x:string; const O_y:string; const O_idx:string; const O_count:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
  begin
  result:=AddOper('UniqueWithCounts',[I_x],[],[O_y,O_idx,O_count],['T','out_idx'],['type','type'],[@A_T,@A_out_idx])
  end;
function TGraphExt.AddUnpack(const I_value:string; const OL_output:TF_StringList; const A_num:cint64; const A_T:TF_DataType; const A_axis:cint64):string;
  begin
  result:=AddOper('Unpack',[I_value],[],OL_output,['num','T','axis'],['int','type','int'],[@A_num,@A_T,@A_axis])
  end;
function TGraphExt.AddUnsortedSegmentMax(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('UnsortedSegmentMax',[I_data,I_segment_ids,I_num_segments],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddUnsortedSegmentSum(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('UnsortedSegmentSum',[I_data,I_segment_ids,I_num_segments],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddUnstage(const OL_values:TF_StringList; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('Unstage',[],[],OL_values,['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddVariable(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('Variable',[],[],[O_ref],['shape','dtype','container','shared_name'],['shape','type','string','string'],[@A_shape,@A_dtype,@A_container,@A_shared_name])
  end;
function TGraphExt.AddVariableV2(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('VariableV2',[],[],[O_ref],['shape','dtype','container','shared_name'],['shape','type','string','string'],[@A_shape,@A_dtype,@A_container,@A_shared_name])
  end;
function TGraphExt.AddWhere(const I_input:string; const O_index:string):string;
  begin
  result:=AddOper('Where',[I_input],[],[O_index],[],[],[])
  end;
function TGraphExt.AddWholeFileReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('WholeFileReader',[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddWholeFileReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('WholeFileReaderV2',[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddWriteFile(const I_filename:string; const I_contents:string):string;
  begin
  result:=AddOper('WriteFile',[I_filename,I_contents],[],[],[],[],[])
  end;
function TGraphExt.AddZerosLike(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ZerosLike',[I_x],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddZeta(const I_x:string; const I_q:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Zeta',[I_x,I_q],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddZipDataset(const IL_input_datasets:TF_StringList; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
  begin
  result:=AddOper('ZipDataset',[],[IL_input_datasets],[O_handle],['output_types','output_shapes','N'],['list(type)','list(shape)','int'],[@A_output_types,@A_output_shapes,@A_N])
  end;

//  The Exec<oper> methods
function ExecAbs(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Abs',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAccumulatorNumAccumulated(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AccumulatorNumAccumulated',[I_handle],[],[],[],[D_handle])
  end;
function ExecAccumulatorTakeGradient(const I_handle:TF_TensorPtr; const I_num_required:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_num_required:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AccumulatorTakeGradient',[I_handle,I_num_required],['dtype'],['type'],[@A_dtype],[D_handle,D_num_required])
  end;
function ExecAcos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Acos',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAcosh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Acosh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAdd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Add',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecAddManySparseToTensorsMap(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('AddManySparseToTensorsMap',[I_sparse_indices,I_sparse_values,I_sparse_shape],['T','container','shared_name'],['type','string','string'],[@F_T,@A_container,@A_shared_name],[D_sparse_indices,D_sparse_values,D_sparse_shape])
  end;
function ExecAddSparseToTensorsMap(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('AddSparseToTensorsMap',[I_sparse_indices,I_sparse_values,I_sparse_shape],['T','container','shared_name'],['type','string','string'],[@F_T,@A_container,@A_shared_name],[D_sparse_indices,D_sparse_values,D_sparse_shape])
  end;
function ExecAdjustContrast(const I_images:TF_TensorPtr; const I_contrast_factor:TF_TensorPtr; const I_min_value:TF_TensorPtr; const I_max_value:TF_TensorPtr; const D_images:boolean=false; const D_contrast_factor:boolean=false; const D_min_value:boolean=false; const D_max_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('AdjustContrast',[I_images,I_contrast_factor,I_min_value,I_max_value],['T'],['type'],[@F_T],[D_images,D_contrast_factor,D_min_value,D_max_value])
  end;
function ExecAdjustContrastv2(const I_images:TF_TensorPtr; const I_contrast_factor:TF_TensorPtr; const D_images:boolean=false; const D_contrast_factor:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AdjustContrastv2',[I_images,I_contrast_factor],[],[],[],[D_images,D_contrast_factor])
  end;
function ExecAdjustHue(const I_images:TF_TensorPtr; const I_delta:TF_TensorPtr; const D_images:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AdjustHue',[I_images,I_delta],[],[],[],[D_images,D_delta])
  end;
function ExecAdjustSaturation(const I_images:TF_TensorPtr; const I_scale:TF_TensorPtr; const D_images:boolean=false; const D_scale:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AdjustSaturation',[I_images,I_scale],[],[],[],[D_images,D_scale])
  end;
function ExecAll(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_Tidx:TF_DataType;
  begin
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('All',[I_input,I_reduction_indices],['keep_dims','Tidx'],['bool','type'],[@A_keep_dims,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecAny(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_Tidx:TF_DataType;
  begin
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Any',[I_input,I_reduction_indices],['keep_dims','Tidx'],['bool','type'],[@A_keep_dims,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecApplyAdadelta(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_accum_update:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_accum_update:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_accum_update,D_lr,D_rho,D_epsilon,D_grad])
  end;
function ExecApplyAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdagrad',[I_var,I_accum,I_lr,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_lr,D_grad])
  end;
function ExecApplyAdagradDA(const I_var:TF_TensorPtr; const I_gradient_accumulator:TF_TensorPtr; const I_gradient_squared_accumulator:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_global_step:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_gradient_accumulator:boolean=false; const D_gradient_squared_accumulator:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_global_step:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_lr,I_l1,I_l2,I_global_step],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_gradient_accumulator,D_gradient_squared_accumulator,D_grad,D_lr,D_l1,D_l2,D_global_step])
  end;
function ExecApplyAdam(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta1_power:TF_TensorPtr; const I_beta2_power:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_beta1:TF_TensorPtr; const I_beta2:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta1_power:boolean=false; const D_beta2_power:boolean=false; const D_lr:boolean=false; const D_beta1:boolean=false; const D_beta2:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdam',[I_var,I_m,I_v,I_beta1_power,I_beta2_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],['T','use_locking','use_nesterov'],['type','bool','bool'],[@F_T,@A_use_locking,@A_use_nesterov],[D_var,D_m,D_v,D_beta1_power,D_beta2_power,D_lr,D_beta1,D_beta2,D_epsilon,D_grad])
  end;
function ExecApplyCenteredRMSProp(const I_var:TF_TensorPtr; const I_mg:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_mg:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_mg,D_ms,D_mom,D_lr,D_rho,D_momentum,D_epsilon,D_grad])
  end;
function ExecApplyFtrl(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_lr_power],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_linear,D_grad,D_lr,D_l1,D_l2,D_lr_power])
  end;
function ExecApplyFtrlV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_l2_shrinkage:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_l2_shrinkage:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_linear,D_grad,D_lr,D_l1,D_l2,D_l2_shrinkage,D_lr_power])
  end;
function ExecApplyGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_delta:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyGradientDescent',[I_var,I_alpha,I_delta],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_alpha,D_delta])
  end;
function ExecApplyMomentum(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_momentum:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_momentum:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_momentum],['T','use_locking','use_nesterov'],['type','bool','bool'],[@F_T,@A_use_locking,@A_use_nesterov],[D_var,D_accum,D_lr,D_grad,D_momentum])
  end;
function ExecApplyProximalAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_lr,D_l1,D_l2,D_grad])
  end;
function ExecApplyProximalGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_delta:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_delta],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_alpha,D_l1,D_l2,D_delta])
  end;
function ExecApplyRMSProp(const I_var:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_ms,D_mom,D_lr,D_rho,D_momentum,D_epsilon,D_grad])
  end;
function ExecApproximateEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_tolerance:real; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('ApproximateEqual',[I_x,I_y],['T','tolerance'],['type','float'],[@F_T,@A_tolerance],[D_x,D_y])
  end;
function ExecArgMax(const I_input:TF_TensorPtr; const I_dimension:TF_TensorPtr; const A_output_type:TF_DataType; const D_input:boolean=false; const D_dimension:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_dimension);
  result:=ExecOper('ArgMax',[I_input,I_dimension],['T','Tidx','output_type'],['type','type','type'],[@F_T,@F_Tidx,@A_output_type],[D_input,D_dimension])
  end;
function ExecArgMin(const I_input:TF_TensorPtr; const I_dimension:TF_TensorPtr; const A_output_type:TF_DataType; const D_input:boolean=false; const D_dimension:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_dimension);
  result:=ExecOper('ArgMin',[I_input,I_dimension],['T','Tidx','output_type'],['type','type','type'],[@F_T,@F_Tidx,@A_output_type],[D_input,D_dimension])
  end;
function ExecAsString(const I_input:TF_TensorPtr; const A_precision:cint64; const A_scientific:boolean; const A_shortest:boolean; const A_width:cint64; const A_fill:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('AsString',[I_input],['T','precision','scientific','shortest','width','fill'],['type','int','bool','bool','int','string'],[@F_T,@A_precision,@A_scientific,@A_shortest,@A_width,@A_fill],[D_input])
  end;
function ExecAsin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Asin',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAsinh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Asinh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAssign(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_validate_shape:boolean; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('Assign',[I_ref,I_value],['T','validate_shape','use_locking'],['type','bool','bool'],[@F_T,@A_validate_shape,@A_use_locking],[D_ref,D_value])
  end;
function ExecAssignAdd(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('AssignAdd',[I_ref,I_value],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_ref,D_value])
  end;
function ExecAssignSub(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('AssignSub',[I_ref,I_value],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_ref,D_value])
  end;
function ExecAtan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Atan',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAtan2(const I_y:TF_TensorPtr; const I_x:TF_TensorPtr; const D_y:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_y);
  result:=ExecOper('Atan2',[I_y,I_x],['T'],['type'],[@F_T],[D_y,D_x])
  end;
function ExecAtanh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Atanh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAudioSpectrogram(const I_input:TF_TensorPtr; const A_window_size:cint64; const A_stride:cint64; const A_magnitude_squared:boolean; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AudioSpectrogram',[I_input],['window_size','stride','magnitude_squared'],['int','int','bool'],[@A_window_size,@A_stride,@A_magnitude_squared],[D_input])
  end;
function ExecAudioSummary(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const A_sample_rate:real; const A_max_outputs:cint64; const D_tag:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AudioSummary',[I_tag,I_tensor],['sample_rate','max_outputs'],['float','int'],[@A_sample_rate,@A_max_outputs],[D_tag,D_tensor])
  end;
function ExecAudioSummaryV2(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const A_max_outputs:cint64; const D_tag:boolean=false; const D_tensor:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AudioSummaryV2',[I_tag,I_tensor,I_sample_rate],['max_outputs'],['int'],[@A_max_outputs],[D_tag,D_tensor,D_sample_rate])
  end;
function ExecAvgPool(const I_value:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('AvgPool',[I_value],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_value])
  end;
function ExecAvgPool3D(const I_input:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('AvgPool3D',[I_input],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_input])
  end;
function ExecAvgPool3DGrad(const I_orig_input_shape:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input_shape:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grad);
  result:=ExecOper('AvgPool3DGrad',[I_orig_input_shape,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input_shape,D_grad])
  end;
function ExecAvgPoolGrad(const I_orig_input_shape:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input_shape:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grad);
  result:=ExecOper('AvgPoolGrad',[I_orig_input_shape,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input_shape,D_grad])
  end;
function ExecBarrier(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('Barrier',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecBarrierIncompleteSize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BarrierIncompleteSize',[I_handle],[],[],[],[D_handle])
  end;
function ExecBarrierReadySize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BarrierReadySize',[I_handle],[],[],[],[D_handle])
  end;
function ExecBatchCholesky(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchCholesky',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecBatchCholeskyGrad(const I_l:TF_TensorPtr; const I_grad:TF_TensorPtr; const D_l:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_l);
  result:=ExecOper('BatchCholeskyGrad',[I_l,I_grad],['T'],['type'],[@F_T],[D_l,D_grad])
  end;
function ExecBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_batch_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchDataset',[I_input_dataset,I_batch_size],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_batch_size])
  end;
function ExecBatchFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchFFT',[I_input],[],[],[],[D_input])
  end;
function ExecBatchFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchFFT2D',[I_input],[],[],[],[D_input])
  end;
function ExecBatchFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchFFT3D',[I_input],[],[],[],[D_input])
  end;
function ExecBatchIFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchIFFT',[I_input],[],[],[],[D_input])
  end;
function ExecBatchIFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchIFFT2D',[I_input],[],[],[],[D_input])
  end;
function ExecBatchIFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchIFFT3D',[I_input],[],[],[],[D_input])
  end;
function ExecBatchMatMul(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_adj_x:boolean; const A_adj_y:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BatchMatMul',[I_x,I_y],['T','adj_x','adj_y'],['type','bool','bool'],[@F_T,@A_adj_x,@A_adj_y],[D_x,D_y])
  end;
function ExecBatchMatrixBandPart(const I_input:TF_TensorPtr; const I_num_lower:TF_TensorPtr; const I_num_upper:TF_TensorPtr; const D_input:boolean=false; const D_num_lower:boolean=false; const D_num_upper:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixBandPart',[I_input,I_num_lower,I_num_upper],['T'],['type'],[@F_T],[D_input,D_num_lower,D_num_upper])
  end;
function ExecBatchMatrixDeterminant(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixDeterminant',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecBatchMatrixDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonal);
  result:=ExecOper('BatchMatrixDiag',[I_diagonal],['T'],['type'],[@F_T],[D_diagonal])
  end;
function ExecBatchMatrixDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixDiagPart',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecBatchMatrixInverse(const I_input:TF_TensorPtr; const A_adjoint:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixInverse',[I_input],['adjoint','T'],['bool','type'],[@A_adjoint,@F_T],[D_input])
  end;
function ExecBatchMatrixSetDiag(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixSetDiag',[I_input,I_diagonal],['T'],['type'],[@F_T],[D_input,D_diagonal])
  end;
function ExecBatchMatrixSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('BatchMatrixSolve',[I_matrix,I_rhs],['adjoint','T'],['bool','type'],[@A_adjoint,@F_T],[D_matrix,D_rhs])
  end;
function ExecBatchMatrixSolveLs(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const I_l2_regularizer:TF_TensorPtr; const A_fast:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false; const D_l2_regularizer:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('BatchMatrixSolveLs',[I_matrix,I_rhs,I_l2_regularizer],['T','fast'],['type','bool'],[@F_T,@A_fast],[D_matrix,D_rhs,D_l2_regularizer])
  end;
function ExecBatchMatrixTriangularSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_lower:boolean; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('BatchMatrixTriangularSolve',[I_matrix,I_rhs],['lower','adjoint','T'],['bool','bool','type'],[@A_lower,@A_adjoint,@F_T],[D_matrix,D_rhs])
  end;
function ExecBatchNormWithGlobalNormalization(const I_t:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta:TF_TensorPtr; const I_gamma:TF_TensorPtr; const A_variance_epsilon:real; const A_scale_after_normalization:boolean; const D_t:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta:boolean=false; const D_gamma:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_t);
  result:=ExecOper('BatchNormWithGlobalNormalization',[I_t,I_m,I_v,I_beta,I_gamma],['T','variance_epsilon','scale_after_normalization'],['type','float','bool'],[@F_T,@A_variance_epsilon,@A_scale_after_normalization],[D_t,D_m,D_v,D_beta,D_gamma])
  end;
function ExecBatchSelfAdjointEig(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchSelfAdjointEig',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecBatchToSpace(const I_input:TF_TensorPtr; const I_crops:TF_TensorPtr; const A_block_size:cint64; const D_input:boolean=false; const D_crops:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_crops);
  result:=ExecOper('BatchToSpace',[I_input,I_crops],['T','block_size','Tidx'],['type','int','type'],[@F_T,@A_block_size,@F_Tidx],[D_input,D_crops])
  end;
function ExecBatchToSpaceND(const I_input:TF_TensorPtr; const I_block_shape:TF_TensorPtr; const I_crops:TF_TensorPtr; const D_input:boolean=false; const D_block_shape:boolean=false; const D_crops:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tblock_shape:TF_DataType;
    F_Tcrops:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tblock_shape:=TF_TensorType(I_block_shape);
  F_Tcrops:=TF_TensorType(I_crops);
  result:=ExecOper('BatchToSpaceND',[I_input,I_block_shape,I_crops],['T','Tblock_shape','Tcrops'],['type','type','type'],[@F_T,@F_Tblock_shape,@F_Tcrops],[D_input,D_block_shape,D_crops])
  end;
function ExecBetainc(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Betainc',[I_a,I_b,I_x],['T'],['type'],[@F_T],[D_a,D_b,D_x])
  end;
function ExecBiasAdd(const I_value:TF_TensorPtr; const I_bias:TF_TensorPtr; const A_data_format:string; const D_value:boolean=false; const D_bias:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('BiasAdd',[I_value,I_bias],['T','data_format'],['type','string'],[@F_T,@A_data_format],[D_value,D_bias])
  end;
function ExecBiasAddGrad(const I_out_backprop:TF_TensorPtr; const A_data_format:string; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_out_backprop);
  result:=ExecOper('BiasAddGrad',[I_out_backprop],['T','data_format'],['type','string'],[@F_T,@A_data_format],[D_out_backprop])
  end;
function ExecBiasAddV1(const I_value:TF_TensorPtr; const I_bias:TF_TensorPtr; const D_value:boolean=false; const D_bias:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('BiasAddV1',[I_value,I_bias],['T'],['type'],[@F_T],[D_value,D_bias])
  end;
function ExecBincount(const I_arr:TF_TensorPtr; const I_size:TF_TensorPtr; const I_weights:TF_TensorPtr; const D_arr:boolean=false; const D_size:boolean=false; const D_weights:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_weights);
  result:=ExecOper('Bincount',[I_arr,I_size,I_weights],['T'],['type'],[@F_T],[D_arr,D_size,D_weights])
  end;
function ExecBitcast(const I_input:TF_TensorPtr; const A_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Bitcast',[I_input],['T','type'],['type','type'],[@F_T,@A_type],[D_input])
  end;
function ExecBitwiseAnd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BitwiseAnd',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecBitwiseOr(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BitwiseOr',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecBitwiseXor(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BitwiseXor',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecBroadcastArgs(const I_s0:TF_TensorPtr; const I_s1:TF_TensorPtr; const D_s0:boolean=false; const D_s1:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_s0);
  result:=ExecOper('BroadcastArgs',[I_s0,I_s1],['T'],['type'],[@F_T],[D_s0,D_s1])
  end;
function ExecBucketize(const I_input:TF_TensorPtr; const A_boundaries:TF_FloatList; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Bucketize',[I_input],['T','boundaries'],['type','list(float)'],[@F_T,@A_boundaries],[D_input])
  end;
function ExecCacheDataset(const I_input_dataset:TF_TensorPtr; const I_filename:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_filename:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('CacheDataset',[I_input_dataset,I_filename],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_filename])
  end;
function ExecCast(const I_x:TF_TensorPtr; const A_DstT:TF_DataType; const D_x:boolean=false):TF_TensorPtr;
  var
    F_SrcT:TF_DataType;
  begin
  F_SrcT:=TF_TensorType(I_x);
  result:=ExecOper('Cast',[I_x],['SrcT','DstT'],['type','type'],[@F_SrcT,@A_DstT],[D_x])
  end;
function ExecCeil(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Ceil',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecCheckNumerics(const I_tensor:TF_TensorPtr; const A_message:string; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('CheckNumerics',[I_tensor],['T','message'],['type','string'],[@F_T,@A_message],[D_tensor])
  end;
function ExecCholesky(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Cholesky',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecCholeskyGrad(const I_l:TF_TensorPtr; const I_grad:TF_TensorPtr; const D_l:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_l);
  result:=ExecOper('CholeskyGrad',[I_l,I_grad],['T'],['type'],[@F_T],[D_l,D_grad])
  end;
function ExecComplex(const I_real:TF_TensorPtr; const I_imag:TF_TensorPtr; const A_Tout:TF_DataType; const D_real:boolean=false; const D_imag:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_real);
  result:=ExecOper('Complex',[I_real,I_imag],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_real,D_imag])
  end;
function ExecComplexAbs(const I_x:TF_TensorPtr; const A_Tout:TF_DataType; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('ComplexAbs',[I_x],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_x])
  end;
function ExecConcatenateDataset(const I_input_dataset:TF_TensorPtr; const I_another_dataset:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_another_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ConcatenateDataset',[I_input_dataset,I_another_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_another_dataset])
  end;
function ExecConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('ConditionalAccumulator',[],['dtype','shape','container','shared_name'],['type','shape','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name],[])
  end;
function ExecConj(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conj',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecConst(const A_value:TF_TensorPtr; const A_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('Const',[],['value','dtype'],['tensor','type'],[@A_value,@A_dtype],[])
  end;
function ExecConv2D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv2D',[I_input,I_filter],['T','strides','use_cudnn_on_gpu','padding','data_format'],['type','list(int)','bool','string','string'],[@F_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_data_format],[D_input,D_filter])
  end;
function ExecConv2DBackpropFilter(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv2DBackpropFilter',[I_input,I_filter_sizes,I_out_backprop],['T','strides','use_cudnn_on_gpu','padding','data_format'],['type','list(int)','bool','string','string'],[@F_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_data_format],[D_input,D_filter_sizes,D_out_backprop])
  end;
function ExecConv2DBackpropInput(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_data_format:string; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_filter);
  result:=ExecOper('Conv2DBackpropInput',[I_input_sizes,I_filter,I_out_backprop],['T','strides','use_cudnn_on_gpu','padding','data_format'],['type','list(int)','bool','string','string'],[@F_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_data_format],[D_input_sizes,D_filter,D_out_backprop])
  end;
function ExecConv3D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv3D',[I_input,I_filter],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@F_T,@A_strides,@A_padding,@A_data_format],[D_input,D_filter])
  end;
function ExecConv3DBackpropFilter(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv3DBackpropFilter',[I_input,I_filter,I_out_backprop],['T','strides','padding'],['type','list(int)','string'],[@F_T,@A_strides,@A_padding],[D_input,D_filter,D_out_backprop])
  end;
function ExecConv3DBackpropFilterV2(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv3DBackpropFilterV2',[I_input,I_filter_sizes,I_out_backprop],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@F_T,@A_strides,@A_padding,@A_data_format],[D_input,D_filter_sizes,D_out_backprop])
  end;
function ExecConv3DBackpropInput(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv3DBackpropInput',[I_input,I_filter,I_out_backprop],['T','strides','padding'],['type','list(int)','string'],[@F_T,@A_strides,@A_padding],[D_input,D_filter,D_out_backprop])
  end;
function ExecConv3DBackpropInputV2(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_filter);
  result:=ExecOper('Conv3DBackpropInputV2',[I_input_sizes,I_filter,I_out_backprop],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@F_T,@A_strides,@A_padding,@A_data_format],[D_input_sizes,D_filter,D_out_backprop])
  end;
function ExecCopy(const I_input:TF_TensorPtr; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Copy',[I_input],['T','tensor_name','debug_ops_spec'],['type','string','list(string)'],[@F_T,@A_tensor_name,@A_debug_ops_spec],[D_input])
  end;
function ExecCopyHost(const I_input:TF_TensorPtr; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('CopyHost',[I_input],['T','tensor_name','debug_ops_spec'],['type','string','list(string)'],[@F_T,@A_tensor_name,@A_debug_ops_spec],[D_input])
  end;
function ExecCos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Cos',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecCosh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Cosh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecCountUpTo(const I_ref:TF_TensorPtr; const A_limit:cint64; const D_ref:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('CountUpTo',[I_ref],['limit','T'],['int','type'],[@A_limit,@F_T],[D_ref])
  end;
function ExecCropAndResize(const I_image:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const I_crop_size:TF_TensorPtr; const A_method:string; const A_extrapolation_value:real; const D_image:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false; const D_crop_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_image);
  result:=ExecOper('CropAndResize',[I_image,I_boxes,I_box_ind,I_crop_size],['T','method','extrapolation_value'],['type','string','float'],[@F_T,@A_method,@A_extrapolation_value],[D_image,D_boxes,D_box_ind,D_crop_size])
  end;
function ExecCropAndResizeGradBoxes(const I_grads:TF_TensorPtr; const I_image:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const A_method:string; const D_grads:boolean=false; const D_image:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_image);
  result:=ExecOper('CropAndResizeGradBoxes',[I_grads,I_image,I_boxes,I_box_ind],['T','method'],['type','string'],[@F_T,@A_method],[D_grads,D_image,D_boxes,D_box_ind])
  end;
function ExecCropAndResizeGradImage(const I_grads:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const I_image_size:TF_TensorPtr; const A_T:TF_DataType; const A_method:string; const D_grads:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false; const D_image_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('CropAndResizeGradImage',[I_grads,I_boxes,I_box_ind,I_image_size],['T','method'],['type','string'],[@A_T,@A_method],[D_grads,D_boxes,D_box_ind,D_image_size])
  end;
function ExecCross(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Cross',[I_a,I_b],['T'],['type'],[@F_T],[D_a,D_b])
  end;
function ExecCumprod(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  F_Tidx:=TF_TensorType(I_axis);
  result:=ExecOper('Cumprod',[I_x,I_axis],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@F_T,@F_Tidx],[D_x,D_axis])
  end;
function ExecCumsum(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  F_Tidx:=TF_TensorType(I_axis);
  result:=ExecOper('Cumsum',[I_x,I_axis],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@F_T,@F_Tidx],[D_x,D_axis])
  end;
function ExecDebugIdentity(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugIdentity',[I_input],['T','device_name','tensor_name','debug_urls','gated_grpc'],['type','string','string','list(string)','bool'],[@F_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_gated_grpc],[D_input])
  end;
function ExecDebugNanCount(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugNanCount',[I_input],['T','device_name','tensor_name','debug_urls','gated_grpc'],['type','string','string','list(string)','bool'],[@F_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_gated_grpc],[D_input])
  end;
function ExecDebugNumericSummary(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_lower_bound:real; const A_upper_bound:real; const A_mute_if_healthy:boolean; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugNumericSummary',[I_input],['T','device_name','tensor_name','debug_urls','lower_bound','upper_bound','mute_if_healthy','gated_grpc'],['type','string','string','list(string)','float','float','bool','bool'],[@F_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_lower_bound,@A_upper_bound,@A_mute_if_healthy,@A_gated_grpc],[D_input])
  end;
function ExecDecodeBase64(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeBase64',[I_input],[],[],[],[D_input])
  end;
function ExecDecodeBmp(const I_contents:TF_TensorPtr; const A_channels:cint64; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeBmp',[I_contents],['channels'],['int'],[@A_channels],[D_contents])
  end;
function ExecDecodeGif(const I_contents:TF_TensorPtr; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeGif',[I_contents],[],[],[],[D_contents])
  end;
function ExecDecodeJSONExample(const I_json_examples:TF_TensorPtr; const D_json_examples:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeJSONExample',[I_json_examples],[],[],[],[D_json_examples])
  end;
function ExecDecodeJpeg(const I_contents:TF_TensorPtr; const A_channels:cint64; const A_ratio:cint64; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeJpeg',[I_contents],['channels','ratio','fancy_upscaling','try_recover_truncated','acceptable_fraction','dct_method'],['int','int','bool','bool','float','string'],[@A_channels,@A_ratio,@A_fancy_upscaling,@A_try_recover_truncated,@A_acceptable_fraction,@A_dct_method],[D_contents])
  end;
function ExecDecodePng(const I_contents:TF_TensorPtr; const A_channels:cint64; const A_dtype:TF_DataType; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodePng',[I_contents],['channels','dtype'],['int','type'],[@A_channels,@A_dtype],[D_contents])
  end;
function ExecDecodeRaw(const I_bytes:TF_TensorPtr; const A_out_type:TF_DataType; const A_little_endian:boolean; const D_bytes:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeRaw',[I_bytes],['out_type','little_endian'],['type','bool'],[@A_out_type,@A_little_endian],[D_bytes])
  end;
function ExecDenseToSparseBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const I_row_shape:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_batch_size:boolean=false; const D_row_shape:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DenseToSparseBatchDataset',[I_input_dataset,I_batch_size,I_row_shape],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_batch_size,D_row_shape])
  end;
function ExecDepthToSpace(const I_input:TF_TensorPtr; const A_block_size:cint64; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DepthToSpace',[I_input],['T','block_size'],['type','int'],[@F_T,@A_block_size],[D_input])
  end;
function ExecDepthwiseConv2dNative(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DepthwiseConv2dNative',[I_input,I_filter],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@F_T,@A_strides,@A_padding,@A_data_format],[D_input,D_filter])
  end;
function ExecDepthwiseConv2dNativeBackpropFilter(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DepthwiseConv2dNativeBackpropFilter',[I_input,I_filter_sizes,I_out_backprop],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@F_T,@A_strides,@A_padding,@A_data_format],[D_input,D_filter_sizes,D_out_backprop])
  end;
function ExecDepthwiseConv2dNativeBackpropInput(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_filter);
  result:=ExecOper('DepthwiseConv2dNativeBackpropInput',[I_input_sizes,I_filter,I_out_backprop],['T','strides','padding','data_format'],['type','list(int)','string','string'],[@F_T,@A_strides,@A_padding,@A_data_format],[D_input_sizes,D_filter,D_out_backprop])
  end;
function ExecDequantize(const I_input:TF_TensorPtr; const I_min_range:TF_TensorPtr; const I_max_range:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_min_range:boolean=false; const D_max_range:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Dequantize',[I_input,I_min_range,I_max_range],['T','mode'],['type','string'],[@F_T,@A_mode],[D_input,D_min_range,D_max_range])
  end;
function ExecDestroyTemporaryVariable(const I_ref:TF_TensorPtr; const A_var_name:string; const D_ref:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('DestroyTemporaryVariable',[I_ref],['T','var_name'],['type','string'],[@F_T,@A_var_name],[D_ref])
  end;
function ExecDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonal);
  result:=ExecOper('Diag',[I_diagonal],['T'],['type'],[@F_T],[D_diagonal])
  end;
function ExecDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DiagPart',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecDigamma(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Digamma',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecDilation2D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Dilation2D',[I_input,I_filter],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@F_T,@A_strides,@A_rates,@A_padding],[D_input,D_filter])
  end;
function ExecDilation2DBackpropFilter(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Dilation2DBackpropFilter',[I_input,I_filter,I_out_backprop],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@F_T,@A_strides,@A_rates,@A_padding],[D_input,D_filter,D_out_backprop])
  end;
function ExecDilation2DBackpropInput(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Dilation2DBackpropInput',[I_input,I_filter,I_out_backprop],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@F_T,@A_strides,@A_rates,@A_padding],[D_input,D_filter,D_out_backprop])
  end;
function ExecDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Div',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecDrawBoundingBoxes(const I_images:TF_TensorPtr; const I_boxes:TF_TensorPtr; const D_images:boolean=false; const D_boxes:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('DrawBoundingBoxes',[I_images,I_boxes],['T'],['type'],[@F_T],[D_images,D_boxes])
  end;
function ExecEditDistance(const I_hypothesis_indices:TF_TensorPtr; const I_hypothesis_values:TF_TensorPtr; const I_hypothesis_shape:TF_TensorPtr; const I_truth_indices:TF_TensorPtr; const I_truth_values:TF_TensorPtr; const I_truth_shape:TF_TensorPtr; const A_normalize:boolean; const D_hypothesis_indices:boolean=false; const D_hypothesis_values:boolean=false; const D_hypothesis_shape:boolean=false; const D_truth_indices:boolean=false; const D_truth_values:boolean=false; const D_truth_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_hypothesis_values);
  result:=ExecOper('EditDistance',[I_hypothesis_indices,I_hypothesis_values,I_hypothesis_shape,I_truth_indices,I_truth_values,I_truth_shape],['normalize','T'],['bool','type'],[@A_normalize,@F_T],[D_hypothesis_indices,D_hypothesis_values,D_hypothesis_shape,D_truth_indices,D_truth_values,D_truth_shape])
  end;
function ExecElu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Elu',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecEluGrad(const I_gradients:TF_TensorPtr; const I_outputs:TF_TensorPtr; const D_gradients:boolean=false; const D_outputs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('EluGrad',[I_gradients,I_outputs],['T'],['type'],[@F_T],[D_gradients,D_outputs])
  end;
function ExecEncodeBase64(const I_input:TF_TensorPtr; const A_pad:boolean; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('EncodeBase64',[I_input],['pad'],['bool'],[@A_pad],[D_input])
  end;
function ExecEncodeJpeg(const I_image:TF_TensorPtr; const A_format:string; const A_quality:cint64; const A_progressive:boolean; const A_optimize_size:boolean; const A_chroma_downsampling:boolean; const A_density_unit:string; const A_x_density:cint64; const A_y_density:cint64; const A_xmp_metadata:string; const D_image:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('EncodeJpeg',[I_image],['format','quality','progressive','optimize_size','chroma_downsampling','density_unit','x_density','y_density','xmp_metadata'],['string','int','bool','bool','bool','string','int','int','string'],[@A_format,@A_quality,@A_progressive,@A_optimize_size,@A_chroma_downsampling,@A_density_unit,@A_x_density,@A_y_density,@A_xmp_metadata],[D_image])
  end;
function ExecEncodePng(const I_image:TF_TensorPtr; const A_compression:cint64; const D_image:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_image);
  result:=ExecOper('EncodePng',[I_image],['compression','T'],['int','type'],[@A_compression,@F_T],[D_image])
  end;
function ExecEncodeWav(const I_audio:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const D_audio:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('EncodeWav',[I_audio,I_sample_rate],[],[],[],[D_audio,D_sample_rate])
  end;
function ExecEnter(const I_data:TF_TensorPtr; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('Enter',[I_data],['T','frame_name','is_constant','parallel_iterations'],['type','string','bool','int'],[@F_T,@A_frame_name,@A_is_constant,@A_parallel_iterations],[D_data])
  end;
function ExecEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Equal',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecErf(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Erf',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecErfc(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Erfc',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecExit(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('Exit',[I_data],['T'],['type'],[@F_T],[D_data])
  end;
function ExecExp(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Exp',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecExpandDims(const I_input:TF_TensorPtr; const I_dim:TF_TensorPtr; const D_input:boolean=false; const D_dim:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tdim:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tdim:=TF_TensorType(I_dim);
  result:=ExecOper('ExpandDims',[I_input,I_dim],['T','Tdim'],['type','type'],[@F_T,@F_Tdim],[D_input,D_dim])
  end;
function ExecExpm1(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Expm1',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecExtractGlimpse(const I_input:TF_TensorPtr; const I_size:TF_TensorPtr; const I_offsets:TF_TensorPtr; const A_centered:boolean; const A_normalized:boolean; const A_uniform_noise:boolean; const D_input:boolean=false; const D_size:boolean=false; const D_offsets:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExtractGlimpse',[I_input,I_size,I_offsets],['centered','normalized','uniform_noise'],['bool','bool','bool'],[@A_centered,@A_normalized,@A_uniform_noise],[D_input,D_size,D_offsets])
  end;
function ExecExtractImagePatches(const I_images:TF_TensorPtr; const A_ksizes:TF_IntList; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string; const D_images:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ExtractImagePatches',[I_images],['ksizes','strides','rates','T','padding'],['list(int)','list(int)','list(int)','type','string'],[@A_ksizes,@A_strides,@A_rates,@F_T,@A_padding],[D_images])
  end;
function ExecFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FFT',[I_input],[],[],[],[D_input])
  end;
function ExecFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FFT2D',[I_input],[],[],[],[D_input])
  end;
function ExecFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FFT3D',[I_input],[],[],[],[D_input])
  end;
function ExecFIFOQueue(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('FIFOQueue',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecFIFOQueueV2(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('FIFOQueueV2',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecFact():TF_TensorPtr;
  begin
  result:=ExecOper('Fact',[],[],[],[],[])
  end;
function ExecFakeQuantWithMinMaxArgs(const I_inputs:TF_TensorPtr; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean; const D_inputs:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQuantWithMinMaxArgs',[I_inputs],['min','max','num_bits','narrow_range'],['float','float','int','bool'],[@A_min,@A_max,@A_num_bits,@A_narrow_range],[D_inputs])
  end;
function ExecFakeQuantWithMinMaxArgsGradient(const I_gradients:TF_TensorPtr; const I_inputs:TF_TensorPtr; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean; const D_gradients:boolean=false; const D_inputs:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQuantWithMinMaxArgsGradient',[I_gradients,I_inputs],['min','max','num_bits','narrow_range'],['float','float','int','bool'],[@A_min,@A_max,@A_num_bits,@A_narrow_range],[D_gradients,D_inputs])
  end;
function ExecFakeQuantWithMinMaxVars(const I_inputs:TF_TensorPtr; const I_min:TF_TensorPtr; const I_max:TF_TensorPtr; const A_num_bits:cint64; const A_narrow_range:boolean; const D_inputs:boolean=false; const D_min:boolean=false; const D_max:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQuantWithMinMaxVars',[I_inputs,I_min,I_max],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range],[D_inputs,D_min,D_max])
  end;
function ExecFakeQuantWithMinMaxVarsPerChannel(const I_inputs:TF_TensorPtr; const I_min:TF_TensorPtr; const I_max:TF_TensorPtr; const A_num_bits:cint64; const A_narrow_range:boolean; const D_inputs:boolean=false; const D_min:boolean=false; const D_max:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQuantWithMinMaxVarsPerChannel',[I_inputs,I_min,I_max],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range],[D_inputs,D_min,D_max])
  end;
function ExecFakeQueue(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQueue',[I_resource],[],[],[],[D_resource])
  end;
function ExecFill(const I_dims:TF_TensorPtr; const I_value:TF_TensorPtr; const D_dims:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('Fill',[I_dims,I_value],['T'],['type'],[@F_T],[D_dims,D_value])
  end;
function ExecFixedLengthRecordDataset(const I_filenames:TF_TensorPtr; const I_header_bytes:TF_TensorPtr; const I_record_bytes:TF_TensorPtr; const I_footer_bytes:TF_TensorPtr; const D_filenames:boolean=false; const D_header_bytes:boolean=false; const D_record_bytes:boolean=false; const D_footer_bytes:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FixedLengthRecordDataset',[I_filenames,I_header_bytes,I_record_bytes,I_footer_bytes],[],[],[],[D_filenames,D_header_bytes,D_record_bytes,D_footer_bytes])
  end;
function ExecFixedLengthRecordReader(const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('FixedLengthRecordReader',[],['header_bytes','record_bytes','footer_bytes','hop_bytes','container','shared_name'],['int','int','int','int','string','string'],[@A_header_bytes,@A_record_bytes,@A_footer_bytes,@A_hop_bytes,@A_container,@A_shared_name],[])
  end;
function ExecFixedLengthRecordReaderV2(const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string; const A_encoding:string):TF_TensorPtr;
  begin
  result:=ExecOper('FixedLengthRecordReaderV2',[],['header_bytes','record_bytes','footer_bytes','hop_bytes','container','shared_name','encoding'],['int','int','int','int','string','string','string'],[@A_header_bytes,@A_record_bytes,@A_footer_bytes,@A_hop_bytes,@A_container,@A_shared_name,@A_encoding],[])
  end;
function ExecFloor(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Floor',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecFloorDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('FloorDiv',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecFloorMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('FloorMod',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecFractionalAvgPoolGrad(const I_orig_input_tensor_shape:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const I_row_pooling_sequence:TF_TensorPtr; const I_col_pooling_sequence:TF_TensorPtr; const A_overlapping:boolean; const D_orig_input_tensor_shape:boolean=false; const D_out_backprop:boolean=false; const D_row_pooling_sequence:boolean=false; const D_col_pooling_sequence:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_out_backprop);
  result:=ExecOper('FractionalAvgPoolGrad',[I_orig_input_tensor_shape,I_out_backprop,I_row_pooling_sequence,I_col_pooling_sequence],['overlapping','T'],['bool','type'],[@A_overlapping,@F_T],[D_orig_input_tensor_shape,D_out_backprop,D_row_pooling_sequence,D_col_pooling_sequence])
  end;
function ExecFractionalMaxPoolGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const I_row_pooling_sequence:TF_TensorPtr; const I_col_pooling_sequence:TF_TensorPtr; const A_overlapping:boolean; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_out_backprop:boolean=false; const D_row_pooling_sequence:boolean=false; const D_col_pooling_sequence:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('FractionalMaxPoolGrad',[I_orig_input,I_orig_output,I_out_backprop,I_row_pooling_sequence,I_col_pooling_sequence],['overlapping','T'],['bool','type'],[@A_overlapping,@F_T],[D_orig_input,D_orig_output,D_out_backprop,D_row_pooling_sequence,D_col_pooling_sequence])
  end;
function ExecFusedPadConv2D(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_mode:string; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_paddings:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('FusedPadConv2D',[I_input,I_paddings,I_filter],['T','mode','strides','padding'],['type','string','list(int)','string'],[@F_T,@A_mode,@A_strides,@A_padding],[D_input,D_paddings,D_filter])
  end;
function ExecFusedResizeAndPadConv2D(const I_input:TF_TensorPtr; const I_size:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_resize_align_corners:boolean; const A_mode:string; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_size:boolean=false; const D_paddings:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('FusedResizeAndPadConv2D',[I_input,I_size,I_paddings,I_filter],['T','resize_align_corners','mode','strides','padding'],['type','bool','string','list(int)','string'],[@F_T,@A_resize_align_corners,@A_mode,@A_strides,@A_padding],[D_input,D_size,D_paddings,D_filter])
  end;
function ExecGather(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_validate_indices:boolean; const D_params:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_Tparams:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_Tparams:=TF_TensorType(I_params);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('Gather',[I_params,I_indices],['validate_indices','Tparams','Tindices'],['bool','type','type'],[@A_validate_indices,@F_Tparams,@F_Tindices],[D_params,D_indices])
  end;
function ExecGatherNd(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const D_params:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_Tparams:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_Tparams:=TF_TensorType(I_params);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('GatherNd',[I_params,I_indices],['Tparams','Tindices'],['type','type'],[@F_Tparams,@F_Tindices],[D_params,D_indices])
  end;
function ExecGatherV2(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_axis:TF_TensorPtr; const D_params:boolean=false; const D_indices:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_Tparams:TF_DataType;
    F_Tindices:TF_DataType;
    F_Taxis:TF_DataType;
  begin
  F_Tparams:=TF_TensorType(I_params);
  F_Tindices:=TF_TensorType(I_indices);
  F_Taxis:=TF_TensorType(I_axis);
  result:=ExecOper('GatherV2',[I_params,I_indices,I_axis],['Tparams','Tindices','Taxis'],['type','type','type'],[@F_Tparams,@F_Tindices,@F_Taxis],[D_params,D_indices,D_axis])
  end;
function ExecGetSessionHandle(const I_value:TF_TensorPtr; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('GetSessionHandle',[I_value],['T'],['type'],[@F_T],[D_value])
  end;
function ExecGetSessionHandleV2(const I_value:TF_TensorPtr; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('GetSessionHandleV2',[I_value],['T'],['type'],[@F_T],[D_value])
  end;
function ExecGetSessionTensor(const I_handle:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('GetSessionTensor',[I_handle],['dtype'],['type'],[@A_dtype],[D_handle])
  end;
function ExecGreater(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Greater',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecGreaterEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('GreaterEqual',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecHSVToRGB(const I_images:TF_TensorPtr; const D_images:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('HSVToRGB',[I_images],['T'],['type'],[@F_T],[D_images])
  end;
function ExecHashTable(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('HashTable',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype],[])
  end;
function ExecHashTableV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('HashTableV2',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype],[])
  end;
function ExecHistogramSummary(const I_tag:TF_TensorPtr; const I_values:TF_TensorPtr; const D_tag:boolean=false; const D_values:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_values);
  result:=ExecOper('HistogramSummary',[I_tag,I_values],['T'],['type'],[@F_T],[D_tag,D_values])
  end;
function ExecIFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IFFT',[I_input],[],[],[],[D_input])
  end;
function ExecIFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IFFT2D',[I_input],[],[],[],[D_input])
  end;
function ExecIFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IFFT3D',[I_input],[],[],[],[D_input])
  end;
function ExecIRFFT(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IRFFT',[I_input,I_fft_length],[],[],[],[D_input,D_fft_length])
  end;
function ExecIRFFT2D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IRFFT2D',[I_input,I_fft_length],[],[],[],[D_input,D_fft_length])
  end;
function ExecIRFFT3D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IRFFT3D',[I_input,I_fft_length],[],[],[],[D_input,D_fft_length])
  end;
function ExecIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Identity',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecIdentityReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('IdentityReader',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecIdentityReaderV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('IdentityReaderV2',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecIgamma(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Igamma',[I_a,I_x],['T'],['type'],[@F_T],[D_a,D_x])
  end;
function ExecIgammac(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Igammac',[I_a,I_x],['T'],['type'],[@F_T],[D_a,D_x])
  end;
function ExecIgnoreErrorsDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IgnoreErrorsDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecImag(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Imag',[I_input],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_input])
  end;
function ExecImageSummary(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const A_max_images:cint64; const A_bad_color:TF_TensorPtr; const D_tag:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('ImageSummary',[I_tag,I_tensor],['max_images','T','bad_color'],['int','type','tensor'],[@A_max_images,@F_T,@A_bad_color],[D_tag,D_tensor])
  end;
function ExecImmutableConst(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_memory_region_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('ImmutableConst',[],['dtype','shape','memory_region_name'],['type','shape','string'],[@A_dtype,@A_shape,@A_memory_region_name],[])
  end;
function ExecInTopK(const I_predictions:TF_TensorPtr; const I_targets:TF_TensorPtr; const A_k:cint64; const D_predictions:boolean=false; const D_targets:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_targets);
  result:=ExecOper('InTopK',[I_predictions,I_targets],['k','T'],['int','type'],[@A_k,@F_T],[D_predictions,D_targets])
  end;
function ExecInv(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Inv',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecInvGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('InvGrad',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecInvert(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Invert',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecInvertPermutation(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('InvertPermutation',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecIsFinite(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('IsFinite',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecIsInf(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('IsInf',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecIsNan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('IsNan',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecIsVariableInitialized(const I_ref:TF_TensorPtr; const D_ref:boolean=false):TF_TensorPtr;
  var
    F_dtype:TF_DataType;
  begin
  F_dtype:=TF_TensorType(I_ref);
  result:=ExecOper('IsVariableInitialized',[I_ref],['dtype'],['type'],[@F_dtype],[D_ref])
  end;
function ExecIterator(const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):TF_TensorPtr;
  begin
  result:=ExecOper('Iterator',[],['shared_name','container','output_types','output_shapes'],['string','string','list(type)','list(shape)'],[@A_shared_name,@A_container,@A_output_types,@A_output_shapes],[])
  end;
function ExecIteratorFromStringHandle(const I_string_handle:TF_TensorPtr; const D_string_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IteratorFromStringHandle',[I_string_handle],[],[],[],[D_string_handle])
  end;
function ExecIteratorToStringHandle(const I_resource_handle:TF_TensorPtr; const D_resource_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IteratorToStringHandle',[I_resource_handle],[],[],[],[D_resource_handle])
  end;
function ExecL2Loss(const I_t:TF_TensorPtr; const D_t:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_t);
  result:=ExecOper('L2Loss',[I_t],['T'],['type'],[@F_T],[D_t])
  end;
function ExecLMDBReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('LMDBReader',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecLRN(const I_input:TF_TensorPtr; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('LRN',[I_input],['depth_radius','bias','alpha','beta','T'],['int','float','float','float','type'],[@A_depth_radius,@A_bias,@A_alpha,@A_beta,@F_T],[D_input])
  end;
function ExecLRNGrad(const I_input_grads:TF_TensorPtr; const I_input_image:TF_TensorPtr; const I_output_image:TF_TensorPtr; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const D_input_grads:boolean=false; const D_input_image:boolean=false; const D_output_image:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input_grads);
  result:=ExecOper('LRNGrad',[I_input_grads,I_input_image,I_output_image],['depth_radius','bias','alpha','beta','T'],['int','float','float','float','type'],[@A_depth_radius,@A_bias,@A_alpha,@A_beta,@F_T],[D_input_grads,D_input_image,D_output_image])
  end;
function ExecLess(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Less',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecLessEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('LessEqual',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecLgamma(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Lgamma',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecLinSpace(const I_start:TF_TensorPtr; const I_stop:TF_TensorPtr; const I_num:TF_TensorPtr; const D_start:boolean=false; const D_stop:boolean=false; const D_num:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_start);
  F_Tidx:=TF_TensorType(I_num);
  result:=ExecOper('LinSpace',[I_start,I_stop,I_num],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_start,D_stop,D_num])
  end;
function ExecLog(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Log',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecLog1p(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Log1p',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecLogSoftmax(const I_logits:TF_TensorPtr; const D_logits:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_logits);
  result:=ExecOper('LogSoftmax',[I_logits],['T'],['type'],[@F_T],[D_logits])
  end;
function ExecLogicalAnd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LogicalAnd',[I_x,I_y],[],[],[],[D_x,D_y])
  end;
function ExecLogicalNot(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LogicalNot',[I_x],[],[],[],[D_x])
  end;
function ExecLogicalOr(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LogicalOr',[I_x,I_y],[],[],[],[D_x,D_y])
  end;
function ExecLookupTableFind(const I_table_handle:TF_TensorPtr; const I_keys:TF_TensorPtr; const I_default_value:TF_TensorPtr; const D_table_handle:boolean=false; const D_keys:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
  var
    F_Tin:TF_DataType;
    F_Tout:TF_DataType;
  begin
  F_Tin:=TF_TensorType(I_keys);
  F_Tout:=TF_TensorType(I_default_value);
  result:=ExecOper('LookupTableFind',[I_table_handle,I_keys,I_default_value],['Tin','Tout'],['type','type'],[@F_Tin,@F_Tout],[D_table_handle,D_keys,D_default_value])
  end;
function ExecLookupTableFindV2(const I_table_handle:TF_TensorPtr; const I_keys:TF_TensorPtr; const I_default_value:TF_TensorPtr; const D_table_handle:boolean=false; const D_keys:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
  var
    F_Tin:TF_DataType;
    F_Tout:TF_DataType;
  begin
  F_Tin:=TF_TensorType(I_keys);
  F_Tout:=TF_TensorType(I_default_value);
  result:=ExecOper('LookupTableFindV2',[I_table_handle,I_keys,I_default_value],['Tin','Tout'],['type','type'],[@F_Tin,@F_Tout],[D_table_handle,D_keys,D_default_value])
  end;
function ExecLookupTableSize(const I_table_handle:TF_TensorPtr; const D_table_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LookupTableSize',[I_table_handle],[],[],[],[D_table_handle])
  end;
function ExecLookupTableSizeV2(const I_table_handle:TF_TensorPtr; const D_table_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LookupTableSizeV2',[I_table_handle],[],[],[],[D_table_handle])
  end;
function ExecLoopCond(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LoopCond',[I_input],[],[],[],[D_input])
  end;
function ExecMapIncompleteSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('MapIncompleteSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecMapSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('MapSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('MatMul',[I_a,I_b],['transpose_a','transpose_b','T'],['bool','bool','type'],[@A_transpose_a,@A_transpose_b,@F_T],[D_a,D_b])
  end;
function ExecMatchingFiles(const I_pattern:TF_TensorPtr; const D_pattern:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('MatchingFiles',[I_pattern],[],[],[],[D_pattern])
  end;
function ExecMatrixBandPart(const I_input:TF_TensorPtr; const I_num_lower:TF_TensorPtr; const I_num_upper:TF_TensorPtr; const D_input:boolean=false; const D_num_lower:boolean=false; const D_num_upper:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixBandPart',[I_input,I_num_lower,I_num_upper],['T'],['type'],[@F_T],[D_input,D_num_lower,D_num_upper])
  end;
function ExecMatrixDeterminant(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixDeterminant',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecMatrixDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonal);
  result:=ExecOper('MatrixDiag',[I_diagonal],['T'],['type'],[@F_T],[D_diagonal])
  end;
function ExecMatrixDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixDiagPart',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecMatrixInverse(const I_input:TF_TensorPtr; const A_adjoint:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixInverse',[I_input],['adjoint','T'],['bool','type'],[@A_adjoint,@F_T],[D_input])
  end;
function ExecMatrixSetDiag(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixSetDiag',[I_input,I_diagonal],['T'],['type'],[@F_T],[D_input,D_diagonal])
  end;
function ExecMatrixSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('MatrixSolve',[I_matrix,I_rhs],['adjoint','T'],['bool','type'],[@A_adjoint,@F_T],[D_matrix,D_rhs])
  end;
function ExecMatrixSolveLs(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const I_l2_regularizer:TF_TensorPtr; const A_fast:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false; const D_l2_regularizer:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('MatrixSolveLs',[I_matrix,I_rhs,I_l2_regularizer],['T','fast'],['type','bool'],[@F_T,@A_fast],[D_matrix,D_rhs,D_l2_regularizer])
  end;
function ExecMatrixTriangularSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_lower:boolean; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('MatrixTriangularSolve',[I_matrix,I_rhs],['lower','adjoint','T'],['bool','bool','type'],[@A_lower,@A_adjoint,@F_T],[D_matrix,D_rhs])
  end;
function ExecMax(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Max',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecMaxPool(const I_input:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MaxPool',[I_input],['T','ksize','strides','padding','data_format'],['type','list(int)','list(int)','string','string'],[@F_T,@A_ksize,@A_strides,@A_padding,@A_data_format],[D_input])
  end;
function ExecMaxPool3D(const I_input:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MaxPool3D',[I_input],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_input])
  end;
function ExecMaxPool3DGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_TInput:TF_DataType;
    F_T:TF_DataType;
  begin
  F_TInput:=TF_TensorType(I_orig_input);
  F_T:=TF_TensorType(I_grad);
  result:=ExecOper('MaxPool3DGrad',[I_orig_input,I_orig_output,I_grad],['ksize','strides','padding','data_format','T','TInput'],['list(int)','list(int)','string','string','type','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T,@F_TInput],[D_orig_input,D_orig_output,D_grad])
  end;
function ExecMaxPool3DGradGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('MaxPool3DGradGrad',[I_orig_input,I_orig_output,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input,D_orig_output,D_grad])
  end;
function ExecMaxPoolGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('MaxPoolGrad',[I_orig_input,I_orig_output,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input,D_orig_output,D_grad])
  end;
function ExecMaxPoolGradGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('MaxPoolGradGrad',[I_orig_input,I_orig_output,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input,D_orig_output,D_grad])
  end;
function ExecMaxPoolGradGradWithArgmax(const I_input:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_argmax:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_grad:boolean=false; const D_argmax:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Targmax:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Targmax:=TF_TensorType(I_argmax);
  result:=ExecOper('MaxPoolGradGradWithArgmax',[I_input,I_grad,I_argmax],['ksize','strides','padding','Targmax','T'],['list(int)','list(int)','string','type','type'],[@A_ksize,@A_strides,@A_padding,@F_Targmax,@F_T],[D_input,D_grad,D_argmax])
  end;
function ExecMaxPoolGradWithArgmax(const I_input:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_argmax:TF_TensorPtr; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const D_input:boolean=false; const D_grad:boolean=false; const D_argmax:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Targmax:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Targmax:=TF_TensorType(I_argmax);
  result:=ExecOper('MaxPoolGradWithArgmax',[I_input,I_grad,I_argmax],['ksize','strides','padding','Targmax','T'],['list(int)','list(int)','string','type','type'],[@A_ksize,@A_strides,@A_padding,@F_Targmax,@F_T],[D_input,D_grad,D_argmax])
  end;
function ExecMaximum(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Maximum',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecMean(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Mean',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecMfcc(const I_spectrogram:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const A_upper_frequency_limit:real; const A_lower_frequency_limit:real; const A_filterbank_channel_count:cint64; const A_dct_coefficient_count:cint64; const D_spectrogram:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('Mfcc',[I_spectrogram,I_sample_rate],['upper_frequency_limit','lower_frequency_limit','filterbank_channel_count','dct_coefficient_count'],['float','float','int','int'],[@A_upper_frequency_limit,@A_lower_frequency_limit,@A_filterbank_channel_count,@A_dct_coefficient_count],[D_spectrogram,D_sample_rate])
  end;
function ExecMin(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Min',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecMinimum(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Minimum',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecMirrorPad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('MirrorPad',[I_input,I_paddings],['T','Tpaddings','mode'],['type','type','string'],[@F_T,@F_Tpaddings,@A_mode],[D_input,D_paddings])
  end;
function ExecMirrorPadGrad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('MirrorPadGrad',[I_input,I_paddings],['T','Tpaddings','mode'],['type','type','string'],[@F_T,@F_Tpaddings,@A_mode],[D_input,D_paddings])
  end;
function ExecMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Mod',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecMul(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Mul',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecMultinomial(const I_logits:TF_TensorPtr; const I_num_samples:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_logits:boolean=false; const D_num_samples:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_logits);
  result:=ExecOper('Multinomial',[I_logits,I_num_samples],['seed','seed2','T'],['int','int','type'],[@A_seed,@A_seed2,@F_T],[D_logits,D_num_samples])
  end;
function ExecMutableDenseHashTable(const I_empty_key:TF_TensorPtr; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real; const D_empty_key:boolean=false):TF_TensorPtr;
  var
    F_key_dtype:TF_DataType;
  begin
  F_key_dtype:=TF_TensorType(I_empty_key);
  result:=ExecOper('MutableDenseHashTable',[I_empty_key],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape','initial_num_buckets','max_load_factor'],['string','string','bool','type','type','shape','int','float'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@F_key_dtype,@A_value_dtype,@A_value_shape,@A_initial_num_buckets,@A_max_load_factor],[D_empty_key])
  end;
function ExecMutableDenseHashTableV2(const I_empty_key:TF_TensorPtr; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real; const D_empty_key:boolean=false):TF_TensorPtr;
  var
    F_key_dtype:TF_DataType;
  begin
  F_key_dtype:=TF_TensorType(I_empty_key);
  result:=ExecOper('MutableDenseHashTableV2',[I_empty_key],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape','initial_num_buckets','max_load_factor'],['string','string','bool','type','type','shape','int','float'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@F_key_dtype,@A_value_dtype,@A_value_shape,@A_initial_num_buckets,@A_max_load_factor],[D_empty_key])
  end;
function ExecMutableHashTable(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('MutableHashTable',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype],[])
  end;
function ExecMutableHashTableOfTensors(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('MutableHashTableOfTensors',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape'],['string','string','bool','type','type','shape'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape],[])
  end;
function ExecMutableHashTableOfTensorsV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('MutableHashTableOfTensorsV2',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape'],['string','string','bool','type','type','shape'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape],[])
  end;
function ExecMutableHashTableV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('MutableHashTableV2',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype],[])
  end;
function ExecNeg(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Neg',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecNextIteration(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('NextIteration',[I_data],['T'],['type'],[@F_T],[D_data])
  end;
function ExecNonMaxSuppression(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const A_iou_threshold:real; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('NonMaxSuppression',[I_boxes,I_scores,I_max_output_size],['iou_threshold'],['float'],[@A_iou_threshold],[D_boxes,D_scores,D_max_output_size])
  end;
function ExecNonMaxSuppressionV2(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const I_iou_threshold:TF_TensorPtr; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false; const D_iou_threshold:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('NonMaxSuppressionV2',[I_boxes,I_scores,I_max_output_size,I_iou_threshold],[],[],[],[D_boxes,D_scores,D_max_output_size,D_iou_threshold])
  end;
function ExecNotEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('NotEqual',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecOneHot(const I_indices:TF_TensorPtr; const I_depth:TF_TensorPtr; const I_on_value:TF_TensorPtr; const I_off_value:TF_TensorPtr; const A_axis:cint64; const D_indices:boolean=false; const D_depth:boolean=false; const D_on_value:boolean=false; const D_off_value:boolean=false):TF_TensorPtr;
  var
    F_TI:TF_DataType;
    F_T:TF_DataType;
  begin
  F_TI:=TF_TensorType(I_indices);
  F_T:=TF_TensorType(I_on_value);
  result:=ExecOper('OneHot',[I_indices,I_depth,I_on_value,I_off_value],['axis','T','TI'],['int','type','type'],[@A_axis,@F_T,@F_TI],[D_indices,D_depth,D_on_value,D_off_value])
  end;
function ExecOneShotIterator(const A_dataset_factory:TF_Function; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('OneShotIterator',[],['dataset_factory','output_types','output_shapes','container','shared_name'],['func','list(type)','list(shape)','string','string'],[@A_dataset_factory,@A_output_types,@A_output_shapes,@A_container,@A_shared_name],[])
  end;
function ExecOnesLike(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('OnesLike',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecOrderedMapIncompleteSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('OrderedMapIncompleteSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecOrderedMapSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('OrderedMapSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecPad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('Pad',[I_input,I_paddings],['T','Tpaddings'],['type','type'],[@F_T,@F_Tpaddings],[D_input,D_paddings])
  end;
function ExecPadV2(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_constant_values:TF_TensorPtr; const D_input:boolean=false; const D_paddings:boolean=false; const D_constant_values:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('PadV2',[I_input,I_paddings,I_constant_values],['T','Tpaddings'],['type','type'],[@F_T,@F_Tpaddings],[D_input,D_paddings,D_constant_values])
  end;
function ExecPaddingFIFOQueue(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('PaddingFIFOQueue',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecPaddingFIFOQueueV2(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('PaddingFIFOQueueV2',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecParameterizedTruncatedNormal(const I_shape:TF_TensorPtr; const I_means:TF_TensorPtr; const I_stdevs:TF_TensorPtr; const I_minvals:TF_TensorPtr; const I_maxvals:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_shape:boolean=false; const D_means:boolean=false; const D_stdevs:boolean=false; const D_minvals:boolean=false; const D_maxvals:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_dtype:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_dtype:=TF_TensorType(I_means);
  result:=ExecOper('ParameterizedTruncatedNormal',[I_shape,I_means,I_stdevs,I_minvals,I_maxvals],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@F_dtype,@F_T],[D_shape,D_means,D_stdevs,D_minvals,D_maxvals])
  end;
function ExecParseTensor(const I_serialized:TF_TensorPtr; const A_out_type:TF_DataType; const D_serialized:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ParseTensor',[I_serialized],['out_type'],['type'],[@A_out_type],[D_serialized])
  end;
function ExecPlaceholder(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('Placeholder',[],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape],[])
  end;
function ExecPlaceholderV2(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('PlaceholderV2',[],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape],[])
  end;
function ExecPlaceholderWithDefault(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const D_input:boolean=false):TF_TensorPtr;
  var
    F_dtype:TF_DataType;
  begin
  F_dtype:=TF_TensorType(I_input);
  result:=ExecOper('PlaceholderWithDefault',[I_input],['dtype','shape'],['type','shape'],[@F_dtype,@A_shape],[D_input])
  end;
function ExecPolygamma(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Polygamma',[I_a,I_x],['T'],['type'],[@F_T],[D_a,D_x])
  end;
function ExecPow(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Pow',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecPreventGradient(const I_input:TF_TensorPtr; const A_message:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('PreventGradient',[I_input],['T','message'],['type','string'],[@F_T,@A_message],[D_input])
  end;
function ExecPriorityQueue(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('PriorityQueue',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecPriorityQueueV2(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('PriorityQueueV2',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecProd(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Prod',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecQuantizeAndDequantize(const I_input:TF_TensorPtr; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_input_min:real; const A_input_max:real; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('QuantizeAndDequantize',[I_input],['signed_input','num_bits','range_given','input_min','input_max','T'],['bool','int','bool','float','float','type'],[@A_signed_input,@A_num_bits,@A_range_given,@A_input_min,@A_input_max,@F_T],[D_input])
  end;
function ExecQuantizeAndDequantizeV2(const I_input:TF_TensorPtr; const I_input_min:TF_TensorPtr; const I_input_max:TF_TensorPtr; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const D_input:boolean=false; const D_input_min:boolean=false; const D_input_max:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('QuantizeAndDequantizeV2',[I_input,I_input_min,I_input_max],['signed_input','num_bits','range_given','T'],['bool','int','bool','type'],[@A_signed_input,@A_num_bits,@A_range_given,@F_T],[D_input,D_input_min,D_input_max])
  end;
function ExecQuantizeAndDequantizeV3(const I_input:TF_TensorPtr; const I_input_min:TF_TensorPtr; const I_input_max:TF_TensorPtr; const I_num_bits:TF_TensorPtr; const A_signed_input:boolean; const A_range_given:boolean; const D_input:boolean=false; const D_input_min:boolean=false; const D_input_max:boolean=false; const D_num_bits:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('QuantizeAndDequantizeV3',[I_input,I_input_min,I_input_max,I_num_bits],['signed_input','range_given','T'],['bool','bool','type'],[@A_signed_input,@A_range_given,@F_T],[D_input,D_input_min,D_input_max,D_num_bits])
  end;
function ExecQueueIsClosed(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('QueueIsClosed',[I_handle],[],[],[],[D_handle])
  end;
function ExecQueueIsClosedV2(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('QueueIsClosedV2',[I_handle],[],[],[],[D_handle])
  end;
function ExecQueueSize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('QueueSize',[I_handle],[],[],[],[D_handle])
  end;
function ExecQueueSizeV2(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('QueueSizeV2',[I_handle],[],[],[],[D_handle])
  end;
function ExecRFFT(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RFFT',[I_input,I_fft_length],[],[],[],[D_input,D_fft_length])
  end;
function ExecRFFT2D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RFFT2D',[I_input,I_fft_length],[],[],[],[D_input,D_fft_length])
  end;
function ExecRFFT3D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RFFT3D',[I_input,I_fft_length],[],[],[],[D_input,D_fft_length])
  end;
function ExecRGBToHSV(const I_images:TF_TensorPtr; const D_images:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('RGBToHSV',[I_images],['T'],['type'],[@F_T],[D_images])
  end;
function ExecRandomCrop(const I_image:TF_TensorPtr; const I_size:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_image:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_image);
  result:=ExecOper('RandomCrop',[I_image,I_size],['T','seed','seed2'],['type','int','int'],[@F_T,@A_seed,@A_seed2],[D_image,D_size])
  end;
function ExecRandomGamma(const I_shape:TF_TensorPtr; const I_alpha:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_shape:boolean=false; const D_alpha:boolean=false):TF_TensorPtr;
  var
    F_S:TF_DataType;
    F_T:TF_DataType;
  begin
  F_S:=TF_TensorType(I_shape);
  F_T:=TF_TensorType(I_alpha);
  result:=ExecOper('RandomGamma',[I_shape,I_alpha],['seed','seed2','S','T'],['int','int','type','type'],[@A_seed,@A_seed2,@F_S,@F_T],[D_shape,D_alpha])
  end;
function ExecRandomPoisson(const I_shape:TF_TensorPtr; const I_rate:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_shape:boolean=false; const D_rate:boolean=false):TF_TensorPtr;
  var
    F_S:TF_DataType;
    F_dtype:TF_DataType;
  begin
  F_S:=TF_TensorType(I_shape);
  F_dtype:=TF_TensorType(I_rate);
  result:=ExecOper('RandomPoisson',[I_shape,I_rate],['seed','seed2','S','dtype'],['int','int','type','type'],[@A_seed,@A_seed2,@F_S,@F_dtype],[D_shape,D_rate])
  end;
function ExecRandomShuffle(const I_value:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('RandomShuffle',[I_value],['seed','seed2','T'],['int','int','type'],[@A_seed,@A_seed2,@F_T],[D_value])
  end;
function ExecRandomShuffleQueue(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('RandomShuffleQueue',[],['component_types','shapes','capacity','min_after_dequeue','seed','seed2','container','shared_name'],['list(type)','list(shape)','int','int','int','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_min_after_dequeue,@A_seed,@A_seed2,@A_container,@A_shared_name],[])
  end;
function ExecRandomShuffleQueueV2(const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('RandomShuffleQueueV2',[],['component_types','shapes','capacity','min_after_dequeue','seed','seed2','container','shared_name'],['list(type)','list(shape)','int','int','int','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_min_after_dequeue,@A_seed,@A_seed2,@A_container,@A_shared_name],[])
  end;
function ExecRandomStandardNormal(const I_shape:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('RandomStandardNormal',[I_shape],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@F_T],[D_shape])
  end;
function ExecRandomUniform(const I_shape:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('RandomUniform',[I_shape],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@F_T],[D_shape])
  end;
function ExecRandomUniformInt(const I_shape:TF_TensorPtr; const I_minval:TF_TensorPtr; const I_maxval:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const D_shape:boolean=false; const D_minval:boolean=false; const D_maxval:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tout:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_Tout:=TF_TensorType(I_minval);
  result:=ExecOper('RandomUniformInt',[I_shape,I_minval,I_maxval],['seed','seed2','Tout','T'],['int','int','type','type'],[@A_seed,@A_seed2,@F_Tout,@F_T],[D_shape,D_minval,D_maxval])
  end;
function ExecRange(const I_start:TF_TensorPtr; const I_limit:TF_TensorPtr; const I_delta:TF_TensorPtr; const D_start:boolean=false; const D_limit:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
  var
    F_Tidx:TF_DataType;
  begin
  F_Tidx:=TF_TensorType(I_start);
  result:=ExecOper('Range',[I_start,I_limit,I_delta],['Tidx'],['type'],[@F_Tidx],[D_start,D_limit,D_delta])
  end;
function ExecRangeDataset(const I_start:TF_TensorPtr; const I_stop:TF_TensorPtr; const I_step:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_start:boolean=false; const D_stop:boolean=false; const D_step:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RangeDataset',[I_start,I_stop,I_step],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_start,D_stop,D_step])
  end;
function ExecRank(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Rank',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecReadFile(const I_filename:TF_TensorPtr; const D_filename:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReadFile',[I_filename],[],[],[],[D_filename])
  end;
function ExecReaderNumRecordsProduced(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderNumRecordsProduced',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderNumRecordsProducedV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderNumRecordsProducedV2',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderNumWorkUnitsCompleted(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderNumWorkUnitsCompleted',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderNumWorkUnitsCompletedV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderNumWorkUnitsCompletedV2',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderSerializeState(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderSerializeState',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderSerializeStateV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderSerializeStateV2',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReal(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Real',[I_input],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_input])
  end;
function ExecRealDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('RealDiv',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecReciprocal(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Reciprocal',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecReciprocalGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('ReciprocalGrad',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecRecordInput(const A_file_pattern:string; const A_file_random_seed:cint64; const A_file_shuffle_shift_ratio:real; const A_file_buffer_size:cint64; const A_file_parallelism:cint64; const A_batch_size:cint64):TF_TensorPtr;
  begin
  result:=ExecOper('RecordInput',[],['file_pattern','file_random_seed','file_shuffle_shift_ratio','file_buffer_size','file_parallelism','batch_size'],['string','int','float','int','int','int'],[@A_file_pattern,@A_file_random_seed,@A_file_shuffle_shift_ratio,@A_file_buffer_size,@A_file_parallelism,@A_batch_size],[])
  end;
function ExecReduceJoin(const I_inputs:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const A_separator:string; const D_inputs:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReduceJoin',[I_inputs,I_reduction_indices],['keep_dims','separator'],['bool','string'],[@A_keep_dims,@A_separator],[D_inputs,D_reduction_indices])
  end;
function ExecRefEnter(const I_data:TF_TensorPtr; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('RefEnter',[I_data],['T','frame_name','is_constant','parallel_iterations'],['type','string','bool','int'],[@F_T,@A_frame_name,@A_is_constant,@A_parallel_iterations],[D_data])
  end;
function ExecRefExit(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('RefExit',[I_data],['T'],['type'],[@F_T],[D_data])
  end;
function ExecRefIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('RefIdentity',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecRefNextIteration(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('RefNextIteration',[I_data],['T'],['type'],[@F_T],[D_data])
  end;
function ExecRelu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Relu',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecRelu6(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Relu6',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecRelu6Grad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('Relu6Grad',[I_gradients,I_features],['T'],['type'],[@F_T],[D_gradients,D_features])
  end;
function ExecReluGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('ReluGrad',[I_gradients,I_features],['T'],['type'],[@F_T],[D_gradients,D_features])
  end;
function ExecRepeatDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RepeatDataset',[I_input_dataset,I_count],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_count])
  end;
function ExecReshape(const I_tensor:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_tensor:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tshape:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  F_Tshape:=TF_TensorType(I_shape);
  result:=ExecOper('Reshape',[I_tensor,I_shape],['T','Tshape'],['type','type'],[@F_T,@F_Tshape],[D_tensor,D_shape])
  end;
function ExecResizeArea(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ResizeArea',[I_images,I_size],['T','align_corners'],['type','bool'],[@F_T,@A_align_corners],[D_images,D_size])
  end;
function ExecResizeBicubic(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ResizeBicubic',[I_images,I_size],['T','align_corners'],['type','bool'],[@F_T,@A_align_corners],[D_images,D_size])
  end;
function ExecResizeBilinear(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ResizeBilinear',[I_images,I_size],['T','align_corners'],['type','bool'],[@F_T,@A_align_corners],[D_images,D_size])
  end;
function ExecResizeBilinearGrad(const I_grads:TF_TensorPtr; const I_original_image:TF_TensorPtr; const A_align_corners:boolean; const D_grads:boolean=false; const D_original_image:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_original_image);
  result:=ExecOper('ResizeBilinearGrad',[I_grads,I_original_image],['T','align_corners'],['type','bool'],[@F_T,@A_align_corners],[D_grads,D_original_image])
  end;
function ExecResizeNearestNeighbor(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ResizeNearestNeighbor',[I_images,I_size],['T','align_corners'],['type','bool'],[@F_T,@A_align_corners],[D_images,D_size])
  end;
function ExecResizeNearestNeighborGrad(const I_grads:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_grads:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grads);
  result:=ExecOper('ResizeNearestNeighborGrad',[I_grads,I_size],['T','align_corners'],['type','bool'],[@F_T,@A_align_corners],[D_grads,D_size])
  end;
function ExecRestore(const I_file_pattern:TF_TensorPtr; const I_tensor_name:TF_TensorPtr; const A_dt:TF_DataType; const A_preferred_shard:cint64; const D_file_pattern:boolean=false; const D_tensor_name:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('Restore',[I_file_pattern,I_tensor_name],['dt','preferred_shard'],['type','int'],[@A_dt,@A_preferred_shard],[D_file_pattern,D_tensor_name])
  end;
function ExecRestoreSlice(const I_file_pattern:TF_TensorPtr; const I_tensor_name:TF_TensorPtr; const I_shape_and_slice:TF_TensorPtr; const A_dt:TF_DataType; const A_preferred_shard:cint64; const D_file_pattern:boolean=false; const D_tensor_name:boolean=false; const D_shape_and_slice:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RestoreSlice',[I_file_pattern,I_tensor_name,I_shape_and_slice],['dt','preferred_shard'],['type','int'],[@A_dt,@A_preferred_shard],[D_file_pattern,D_tensor_name,D_shape_and_slice])
  end;
function ExecReverse(const I_tensor:TF_TensorPtr; const I_dims:TF_TensorPtr; const D_tensor:boolean=false; const D_dims:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('Reverse',[I_tensor,I_dims],['T'],['type'],[@F_T],[D_tensor,D_dims])
  end;
function ExecReverseSequence(const I_input:TF_TensorPtr; const I_seq_lengths:TF_TensorPtr; const A_seq_dim:cint64; const A_batch_dim:cint64; const D_input:boolean=false; const D_seq_lengths:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tlen:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tlen:=TF_TensorType(I_seq_lengths);
  result:=ExecOper('ReverseSequence',[I_input,I_seq_lengths],['seq_dim','batch_dim','T','Tlen'],['int','int','type','type'],[@A_seq_dim,@A_batch_dim,@F_T,@F_Tlen],[D_input,D_seq_lengths])
  end;
function ExecReverseV2(const I_tensor:TF_TensorPtr; const I_axis:TF_TensorPtr; const D_tensor:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  F_Tidx:=TF_TensorType(I_axis);
  result:=ExecOper('ReverseV2',[I_tensor,I_axis],['Tidx','T'],['type','type'],[@F_Tidx,@F_T],[D_tensor,D_axis])
  end;
function ExecRint(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Rint',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecRound(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Round',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecRsqrt(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Rsqrt',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecRsqrtGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('RsqrtGrad',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecScalarSummary(const I_tags:TF_TensorPtr; const I_values:TF_TensorPtr; const D_tags:boolean=false; const D_values:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_values);
  result:=ExecOper('ScalarSummary',[I_tags,I_values],['T'],['type'],[@F_T],[D_tags,D_values])
  end;
function ExecScatterAdd(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterAdd',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterDiv(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterDiv',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterMul(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterMul',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterNd(const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_indices:boolean=false; const D_updates:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_indices);
  F_T:=TF_TensorType(I_updates);
  result:=ExecOper('ScatterNd',[I_indices,I_updates,I_shape],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_indices,D_updates,D_shape])
  end;
function ExecScatterNdAdd(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterNdAdd',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterNdNonAliasingAdd(const I_input:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_input:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterNdNonAliasingAdd',[I_input,I_indices,I_updates],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_input,D_indices,D_updates])
  end;
function ExecScatterNdSub(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterNdSub',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterNdUpdate(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterNdUpdate',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterSub(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterSub',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterUpdate(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterUpdate',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecSdcaFprint(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SdcaFprint',[I_input],[],[],[],[D_input])
  end;
function ExecSegmentMax(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentMax',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSegmentMean(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentMean',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSegmentMin(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentMin',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSegmentProd(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentProd',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSegmentSum(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentSum',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSelect(const I_condition:TF_TensorPtr; const I_t:TF_TensorPtr; const I_e:TF_TensorPtr; const D_condition:boolean=false; const D_t:boolean=false; const D_e:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_t);
  result:=ExecOper('Select',[I_condition,I_t,I_e],['T'],['type'],[@F_T],[D_condition,D_t,D_e])
  end;
function ExecSelfAdjointEig(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('SelfAdjointEig',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecSerializeManySparse(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('SerializeManySparse',[I_sparse_indices,I_sparse_values,I_sparse_shape],['T'],['type'],[@F_T],[D_sparse_indices,D_sparse_values,D_sparse_shape])
  end;
function ExecSerializeSparse(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('SerializeSparse',[I_sparse_indices,I_sparse_values,I_sparse_shape],['T'],['type'],[@F_T],[D_sparse_indices,D_sparse_values,D_sparse_shape])
  end;
function ExecSetSize(const I_set_indices:TF_TensorPtr; const I_set_values:TF_TensorPtr; const I_set_shape:TF_TensorPtr; const A_validate_indices:boolean; const D_set_indices:boolean=false; const D_set_values:boolean=false; const D_set_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_set_values);
  result:=ExecOper('SetSize',[I_set_indices,I_set_values,I_set_shape],['validate_indices','T'],['bool','type'],[@A_validate_indices,@F_T],[D_set_indices,D_set_values,D_set_shape])
  end;
function ExecShape(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Shape',[I_input],['T','out_type'],['type','type'],[@F_T,@A_out_type],[D_input])
  end;
function ExecShardedFilename(const I_basename:TF_TensorPtr; const I_shard:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const D_basename:boolean=false; const D_shard:boolean=false; const D_num_shards:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShardedFilename',[I_basename,I_shard,I_num_shards],[],[],[],[D_basename,D_shard,D_num_shards])
  end;
function ExecShardedFilespec(const I_basename:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const D_basename:boolean=false; const D_num_shards:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShardedFilespec',[I_basename,I_num_shards],[],[],[],[D_basename,D_num_shards])
  end;
function ExecShuffleDataset(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShuffleDataset',[I_input_dataset,I_buffer_size,I_seed,I_seed2],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_buffer_size,D_seed,D_seed2])
  end;
function ExecSigmoid(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sigmoid',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSigmoidGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('SigmoidGrad',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecSign(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sign',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sin',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSinh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sinh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSize(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Size',[I_input],['T','out_type'],['type','type'],[@F_T,@A_out_type],[D_input])
  end;
function ExecSkipDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SkipDataset',[I_input_dataset,I_count],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_count])
  end;
function ExecSlice(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_size:TF_TensorPtr; const D_input:boolean=false; const D_begin:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Index:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Index:=TF_TensorType(I_begin);
  result:=ExecOper('Slice',[I_input,I_begin,I_size],['T','Index'],['type','type'],[@F_T,@F_Index],[D_input,D_begin,D_size])
  end;
function ExecSoftmax(const I_logits:TF_TensorPtr; const D_logits:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_logits);
  result:=ExecOper('Softmax',[I_logits],['T'],['type'],[@F_T],[D_logits])
  end;
function ExecSoftplus(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Softplus',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecSoftplusGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('SoftplusGrad',[I_gradients,I_features],['T'],['type'],[@F_T],[D_gradients,D_features])
  end;
function ExecSoftsign(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Softsign',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecSoftsignGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('SoftsignGrad',[I_gradients,I_features],['T'],['type'],[@F_T],[D_gradients,D_features])
  end;
function ExecSpaceToBatch(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_block_size:cint64; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('SpaceToBatch',[I_input,I_paddings],['T','Tpaddings','block_size'],['type','type','int'],[@F_T,@F_Tpaddings,@A_block_size],[D_input,D_paddings])
  end;
function ExecSpaceToBatchND(const I_input:TF_TensorPtr; const I_block_shape:TF_TensorPtr; const I_paddings:TF_TensorPtr; const D_input:boolean=false; const D_block_shape:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tblock_shape:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tblock_shape:=TF_TensorType(I_block_shape);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('SpaceToBatchND',[I_input,I_block_shape,I_paddings],['T','Tblock_shape','Tpaddings'],['type','type','type'],[@F_T,@F_Tblock_shape,@F_Tpaddings],[D_input,D_block_shape,D_paddings])
  end;
function ExecSpaceToDepth(const I_input:TF_TensorPtr; const A_block_size:cint64; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('SpaceToDepth',[I_input],['T','block_size'],['type','int'],[@F_T,@A_block_size],[D_input])
  end;
function ExecSparseApplyAdadelta(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_accum_update:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_accum_update:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_accum_update,D_lr,D_rho,D_epsilon,D_grad,D_indices])
  end;
function ExecSparseApplyAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyAdagrad',[I_var,I_accum,I_lr,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_lr,D_grad,D_indices])
  end;
function ExecSparseApplyAdagradDA(const I_var:TF_TensorPtr; const I_gradient_accumulator:TF_TensorPtr; const I_gradient_squared_accumulator:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_global_step:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_gradient_accumulator:boolean=false; const D_gradient_squared_accumulator:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_global_step:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_indices,I_lr,I_l1,I_l2,I_global_step],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_gradient_accumulator,D_gradient_squared_accumulator,D_grad,D_indices,D_lr,D_l1,D_l2,D_global_step])
  end;
function ExecSparseApplyCenteredRMSProp(const I_var:TF_TensorPtr; const I_mg:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_mg:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_mg,D_ms,D_mom,D_lr,D_rho,D_momentum,D_epsilon,D_grad,D_indices])
  end;
function ExecSparseApplyFtrl(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_lr_power],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_linear,D_grad,D_indices,D_lr,D_l1,D_l2,D_lr_power])
  end;
function ExecSparseApplyFtrlV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_l2_shrinkage:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_l2_shrinkage:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_linear,D_grad,D_indices,D_lr,D_l1,D_l2,D_l2_shrinkage,D_lr_power])
  end;
function ExecSparseApplyMomentum(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_momentum:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_momentum:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_indices,I_momentum],['T','Tindices','use_locking','use_nesterov'],['type','type','bool','bool'],[@F_T,@F_Tindices,@A_use_locking,@A_use_nesterov],[D_var,D_accum,D_lr,D_grad,D_indices,D_momentum])
  end;
function ExecSparseApplyProximalAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_lr,D_l1,D_l2,D_grad,D_indices])
  end;
function ExecSparseApplyProximalGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_alpha,D_l1,D_l2,D_grad,D_indices])
  end;
function ExecSparseApplyRMSProp(const I_var:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_ms,D_mom,D_lr,D_rho,D_momentum,D_epsilon,D_grad,D_indices])
  end;
function ExecSparseConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('SparseConditionalAccumulator',[],['dtype','shape','container','shared_name'],['type','shape','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name],[])
  end;
function ExecSparseDenseCwiseAdd(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sp_values);
  result:=ExecOper('SparseDenseCwiseAdd',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],['T'],['type'],[@F_T],[D_sp_indices,D_sp_values,D_sp_shape,D_dense])
  end;
function ExecSparseDenseCwiseDiv(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sp_values);
  result:=ExecOper('SparseDenseCwiseDiv',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],['T'],['type'],[@F_T],[D_sp_indices,D_sp_values,D_sp_shape,D_dense])
  end;
function ExecSparseDenseCwiseMul(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sp_values);
  result:=ExecOper('SparseDenseCwiseMul',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],['T'],['type'],[@F_T],[D_sp_indices,D_sp_values,D_sp_shape,D_dense])
  end;
function ExecSparseMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_a_is_sparse:boolean; const A_b_is_sparse:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_Ta:TF_DataType;
    F_Tb:TF_DataType;
  begin
  F_Ta:=TF_TensorType(I_a);
  F_Tb:=TF_TensorType(I_b);
  result:=ExecOper('SparseMatMul',[I_a,I_b],['transpose_a','transpose_b','a_is_sparse','b_is_sparse','Ta','Tb'],['bool','bool','bool','bool','type','type'],[@A_transpose_a,@A_transpose_b,@A_a_is_sparse,@A_b_is_sparse,@F_Ta,@F_Tb],[D_a,D_b])
  end;
function ExecSparseReduceMax(const I_input_indices:TF_TensorPtr; const I_input_values:TF_TensorPtr; const I_input_shape:TF_TensorPtr; const I_reduction_axes:TF_TensorPtr; const A_keep_dims:boolean; const D_input_indices:boolean=false; const D_input_values:boolean=false; const D_input_shape:boolean=false; const D_reduction_axes:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input_values);
  result:=ExecOper('SparseReduceMax',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],['keep_dims','T'],['bool','type'],[@A_keep_dims,@F_T],[D_input_indices,D_input_values,D_input_shape,D_reduction_axes])
  end;
function ExecSparseReduceSum(const I_input_indices:TF_TensorPtr; const I_input_values:TF_TensorPtr; const I_input_shape:TF_TensorPtr; const I_reduction_axes:TF_TensorPtr; const A_keep_dims:boolean; const D_input_indices:boolean=false; const D_input_values:boolean=false; const D_input_shape:boolean=false; const D_reduction_axes:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input_values);
  result:=ExecOper('SparseReduceSum',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],['keep_dims','T'],['bool','type'],[@A_keep_dims,@F_T],[D_input_indices,D_input_values,D_input_shape,D_reduction_axes])
  end;
function ExecSparseSegmentMean(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentMean',[I_data,I_indices,I_segment_ids],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_data,D_indices,D_segment_ids])
  end;
function ExecSparseSegmentMeanGrad(const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_output_dim0:TF_TensorPtr; const D_grad:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_output_dim0:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grad);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentMeanGrad',[I_grad,I_indices,I_segment_ids,I_output_dim0],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_grad,D_indices,D_segment_ids,D_output_dim0])
  end;
function ExecSparseSegmentSqrtN(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentSqrtN',[I_data,I_indices,I_segment_ids],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_data,D_indices,D_segment_ids])
  end;
function ExecSparseSegmentSqrtNGrad(const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_output_dim0:TF_TensorPtr; const D_grad:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_output_dim0:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grad);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentSqrtNGrad',[I_grad,I_indices,I_segment_ids,I_output_dim0],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_grad,D_indices,D_segment_ids,D_output_dim0])
  end;
function ExecSparseSegmentSum(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentSum',[I_data,I_indices,I_segment_ids],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_data,D_indices,D_segment_ids])
  end;
function ExecSparseSoftmax(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sp_values);
  result:=ExecOper('SparseSoftmax',[I_sp_indices,I_sp_values,I_sp_shape],['T'],['type'],[@F_T],[D_sp_indices,D_sp_values,D_sp_shape])
  end;
function ExecSparseTensorDenseAdd(const I_a_indices:TF_TensorPtr; const I_a_values:TF_TensorPtr; const I_a_shape:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a_indices:boolean=false; const D_a_values:boolean=false; const D_a_shape:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_a_indices);
  F_T:=TF_TensorType(I_a_values);
  result:=ExecOper('SparseTensorDenseAdd',[I_a_indices,I_a_values,I_a_shape,I_b],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_a_indices,D_a_values,D_a_shape,D_b])
  end;
function ExecSparseTensorDenseMatMul(const I_a_indices:TF_TensorPtr; const I_a_values:TF_TensorPtr; const I_a_shape:TF_TensorPtr; const I_b:TF_TensorPtr; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const D_a_indices:boolean=false; const D_a_values:boolean=false; const D_a_shape:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_a_indices);
  F_T:=TF_TensorType(I_a_values);
  result:=ExecOper('SparseTensorDenseMatMul',[I_a_indices,I_a_values,I_a_shape,I_b],['T','Tindices','adjoint_a','adjoint_b'],['type','type','bool','bool'],[@F_T,@F_Tindices,@A_adjoint_a,@A_adjoint_b],[D_a_indices,D_a_values,D_a_shape,D_b])
  end;
function ExecSparseTensorSliceDataset(const I_indices:TF_TensorPtr; const I_values:TF_TensorPtr; const I_dense_shape:TF_TensorPtr; const D_indices:boolean=false; const D_values:boolean=false; const D_dense_shape:boolean=false):TF_TensorPtr;
  var
    F_Tvalues:TF_DataType;
  begin
  F_Tvalues:=TF_TensorType(I_values);
  result:=ExecOper('SparseTensorSliceDataset',[I_indices,I_values,I_dense_shape],['Tvalues'],['type'],[@F_Tvalues],[D_indices,D_values,D_dense_shape])
  end;
function ExecSparseToDense(const I_sparse_indices:TF_TensorPtr; const I_output_shape:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_default_value:TF_TensorPtr; const A_validate_indices:boolean; const D_sparse_indices:boolean=false; const D_output_shape:boolean=false; const D_sparse_values:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_sparse_indices);
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('SparseToDense',[I_sparse_indices,I_output_shape,I_sparse_values,I_default_value],['validate_indices','T','Tindices'],['bool','type','type'],[@A_validate_indices,@F_T,@F_Tindices],[D_sparse_indices,D_output_shape,D_sparse_values,D_default_value])
  end;
function ExecSqrt(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sqrt',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSqrtGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('SqrtGrad',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecSquare(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Square',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSquaredDifference(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('SquaredDifference',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecSqueeze(const I_input:TF_TensorPtr; const A_squeeze_dims:TF_IntList; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Squeeze',[I_input],['T','squeeze_dims'],['type','list(int)'],[@F_T,@A_squeeze_dims],[D_input])
  end;
function ExecStack(const A_elem_type:TF_DataType; const A_stack_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('Stack',[],['elem_type','stack_name'],['type','string'],[@A_elem_type,@A_stack_name],[])
  end;
function ExecStackPop(const I_handle:TF_TensorPtr; const A_elem_type:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StackPop',[I_handle],['elem_type'],['type'],[@A_elem_type],[D_handle])
  end;
function ExecStackPopV2(const I_handle:TF_TensorPtr; const A_elem_type:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StackPopV2',[I_handle],['elem_type'],['type'],[@A_elem_type],[D_handle])
  end;
function ExecStackPush(const I_handle:TF_TensorPtr; const I_elem:TF_TensorPtr; const A_swap_memory:boolean; const D_handle:boolean=false; const D_elem:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_elem);
  result:=ExecOper('StackPush',[I_handle,I_elem],['T','swap_memory'],['type','bool'],[@F_T,@A_swap_memory],[D_handle,D_elem])
  end;
function ExecStackPushV2(const I_handle:TF_TensorPtr; const I_elem:TF_TensorPtr; const A_swap_memory:boolean; const D_handle:boolean=false; const D_elem:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_elem);
  result:=ExecOper('StackPushV2',[I_handle,I_elem],['T','swap_memory'],['type','bool'],[@F_T,@A_swap_memory],[D_handle,D_elem])
  end;
function ExecStackV2(const I_max_size:TF_TensorPtr; const A_elem_type:TF_DataType; const A_stack_name:string; const D_max_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StackV2',[I_max_size],['elem_type','stack_name'],['type','string'],[@A_elem_type,@A_stack_name],[D_max_size])
  end;
function ExecStageSize(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('StageSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecStatelessRandomNormal(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('StatelessRandomNormal',[I_shape,I_seed],['dtype','T'],['type','type'],[@A_dtype,@F_T],[D_shape,D_seed])
  end;
function ExecStatelessRandomUniform(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('StatelessRandomUniform',[I_shape,I_seed],['dtype','T'],['type','type'],[@A_dtype,@F_T],[D_shape,D_seed])
  end;
function ExecStatelessTruncatedNormal(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('StatelessTruncatedNormal',[I_shape,I_seed],['dtype','T'],['type','type'],[@A_dtype,@F_T],[D_shape,D_seed])
  end;
function ExecStopGradient(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('StopGradient',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecStridedSlice(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64; const D_input:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Index:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Index:=TF_TensorType(I_begin);
  result:=ExecOper('StridedSlice',[I_input,I_begin,I_end,I_strides],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@F_T,@F_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask],[D_input,D_begin,D_end,D_strides])
  end;
function ExecStridedSliceAssign(const I_ref:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_value:TF_TensorPtr; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64; const D_ref:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Index:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Index:=TF_TensorType(I_begin);
  result:=ExecOper('StridedSliceAssign',[I_ref,I_begin,I_end,I_strides,I_value],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@F_T,@F_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask],[D_ref,D_begin,D_end,D_strides,D_value])
  end;
function ExecStridedSliceGrad(const I_shape:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_dy:TF_TensorPtr; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64; const D_shape:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
  var
    F_Index:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Index:=TF_TensorType(I_shape);
  F_T:=TF_TensorType(I_dy);
  result:=ExecOper('StridedSliceGrad',[I_shape,I_begin,I_end,I_strides,I_dy],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@F_T,@F_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask],[D_shape,D_begin,D_end,D_strides,D_dy])
  end;
function ExecStringToHashBucket(const I_string_tensor:TF_TensorPtr; const A_num_buckets:cint64; const D_string_tensor:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringToHashBucket',[I_string_tensor],['num_buckets'],['int'],[@A_num_buckets],[D_string_tensor])
  end;
function ExecStringToHashBucketFast(const I_input:TF_TensorPtr; const A_num_buckets:cint64; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringToHashBucketFast',[I_input],['num_buckets'],['int'],[@A_num_buckets],[D_input])
  end;
function ExecStringToHashBucketStrong(const I_input:TF_TensorPtr; const A_num_buckets:cint64; const A_key:TF_IntList; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringToHashBucketStrong',[I_input],['num_buckets','key'],['int','list(int)'],[@A_num_buckets,@A_key],[D_input])
  end;
function ExecStringToNumber(const I_string_tensor:TF_TensorPtr; const A_out_type:TF_DataType; const D_string_tensor:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringToNumber',[I_string_tensor],['out_type'],['type'],[@A_out_type],[D_string_tensor])
  end;
function ExecSub(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sub',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecSubstr(const I_input:TF_TensorPtr; const I_pos:TF_TensorPtr; const I_len:TF_TensorPtr; const D_input:boolean=false; const D_pos:boolean=false; const D_len:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_pos);
  result:=ExecOper('Substr',[I_input,I_pos,I_len],['T'],['type'],[@F_T],[D_input,D_pos,D_len])
  end;
function ExecSum(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Sum',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecTFRecordDataset(const I_filenames:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const D_filenames:boolean=false; const D_compression_type:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TFRecordDataset',[I_filenames,I_compression_type],[],[],[],[D_filenames,D_compression_type])
  end;
function ExecTFRecordReader(const A_container:string; const A_shared_name:string; const A_compression_type:string):TF_TensorPtr;
  begin
  result:=ExecOper('TFRecordReader',[],['container','shared_name','compression_type'],['string','string','string'],[@A_container,@A_shared_name,@A_compression_type],[])
  end;
function ExecTFRecordReaderV2(const A_container:string; const A_shared_name:string; const A_compression_type:string):TF_TensorPtr;
  begin
  result:=ExecOper('TFRecordReaderV2',[],['container','shared_name','compression_type'],['string','string','string'],[@A_container,@A_shared_name,@A_compression_type],[])
  end;
function ExecTakeDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TakeDataset',[I_input_dataset,I_count],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_count])
  end;
function ExecTan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Tan',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecTanh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Tanh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecTanhGrad(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('TanhGrad',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecTemporaryVariable(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_var_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('TemporaryVariable',[],['shape','dtype','var_name'],['shape','type','string'],[@A_shape,@A_dtype,@A_var_name],[])
  end;
function ExecTensorArray(const I_size:TF_TensorPtr; const A_dtype:TF_DataType; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const A_element_shape:TF_Shape; const D_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArray',[I_size],['dtype','dynamic_size','clear_after_read','tensor_array_name','element_shape'],['type','bool','bool','string','shape'],[@A_dtype,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name,@A_element_shape],[D_size])
  end;
function ExecTensorArrayGather(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGather',[I_handle,I_indices,I_flow_in],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape],[D_handle,D_indices,D_flow_in])
  end;
function ExecTensorArrayGatherV2(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGatherV2',[I_handle,I_indices,I_flow_in],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape],[D_handle,D_indices,D_flow_in])
  end;
function ExecTensorArrayGatherV3(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGatherV3',[I_handle,I_indices,I_flow_in],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape],[D_handle,D_indices,D_flow_in])
  end;
function ExecTensorArrayGrad(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_source:string; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGrad',[I_handle,I_flow_in],['source'],['string'],[@A_source],[D_handle,D_flow_in])
  end;
function ExecTensorArrayGradV2(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_source:string; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGradV2',[I_handle,I_flow_in],['source'],['string'],[@A_source],[D_handle,D_flow_in])
  end;
function ExecTensorArrayPack(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayPack',[I_handle,I_flow_in],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape],[D_handle,D_flow_in])
  end;
function ExecTensorArrayRead(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayRead',[I_handle,I_index,I_flow_in],['dtype'],['type'],[@A_dtype],[D_handle,D_index,D_flow_in])
  end;
function ExecTensorArrayReadV2(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayReadV2',[I_handle,I_index,I_flow_in],['dtype'],['type'],[@A_dtype],[D_handle,D_index,D_flow_in])
  end;
function ExecTensorArrayReadV3(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayReadV3',[I_handle,I_index,I_flow_in],['dtype'],['type'],[@A_dtype],[D_handle,D_index,D_flow_in])
  end;
function ExecTensorArrayScatter(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayScatter',[I_handle,I_indices,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_indices,D_value,D_flow_in])
  end;
function ExecTensorArrayScatterV2(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayScatterV2',[I_handle,I_indices,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_indices,D_value,D_flow_in])
  end;
function ExecTensorArrayScatterV3(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayScatterV3',[I_handle,I_indices,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_indices,D_value,D_flow_in])
  end;
function ExecTensorArraySize(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArraySize',[I_handle,I_flow_in],[],[],[],[D_handle,D_flow_in])
  end;
function ExecTensorArraySizeV2(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArraySizeV2',[I_handle,I_flow_in],[],[],[],[D_handle,D_flow_in])
  end;
function ExecTensorArraySizeV3(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArraySizeV3',[I_handle,I_flow_in],[],[],[],[D_handle,D_flow_in])
  end;
function ExecTensorArraySplit(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArraySplit',[I_handle,I_value,I_lengths,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_value,D_lengths,D_flow_in])
  end;
function ExecTensorArraySplitV2(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArraySplitV2',[I_handle,I_value,I_lengths,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_value,D_lengths,D_flow_in])
  end;
function ExecTensorArraySplitV3(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArraySplitV3',[I_handle,I_value,I_lengths,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_value,D_lengths,D_flow_in])
  end;
function ExecTensorArrayUnpack(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayUnpack',[I_handle,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_value,D_flow_in])
  end;
function ExecTensorArrayV2(const I_size:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const D_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayV2',[I_size],['dtype','element_shape','dynamic_size','clear_after_read','tensor_array_name'],['type','shape','bool','bool','string'],[@A_dtype,@A_element_shape,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name],[D_size])
  end;
function ExecTensorArrayWrite(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayWrite',[I_handle,I_index,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_index,D_value,D_flow_in])
  end;
function ExecTensorArrayWriteV2(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayWriteV2',[I_handle,I_index,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_index,D_value,D_flow_in])
  end;
function ExecTensorArrayWriteV3(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayWriteV3',[I_handle,I_index,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_index,D_value,D_flow_in])
  end;
function ExecTensorSummary(const I_tensor:TF_TensorPtr; const A_description:string; const A_labels:TF_StringList; const A_display_name:string; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('TensorSummary',[I_tensor],['T','description','labels','display_name'],['type','string','list(string)','string'],[@F_T,@A_description,@A_labels,@A_display_name],[D_tensor])
  end;
function ExecTensorSummaryV2(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_serialized_summary_metadata:TF_TensorPtr; const D_tag:boolean=false; const D_tensor:boolean=false; const D_serialized_summary_metadata:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('TensorSummaryV2',[I_tag,I_tensor,I_serialized_summary_metadata],['T'],['type'],[@F_T],[D_tag,D_tensor,D_serialized_summary_metadata])
  end;
function ExecTextLineDataset(const I_filenames:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const D_filenames:boolean=false; const D_compression_type:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TextLineDataset',[I_filenames,I_compression_type],[],[],[],[D_filenames,D_compression_type])
  end;
function ExecTextLineReader(const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('TextLineReader',[],['skip_header_lines','container','shared_name'],['int','string','string'],[@A_skip_header_lines,@A_container,@A_shared_name],[])
  end;
function ExecTextLineReaderV2(const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('TextLineReaderV2',[],['skip_header_lines','container','shared_name'],['int','string','string'],[@A_skip_header_lines,@A_container,@A_shared_name],[])
  end;
function ExecTile(const I_input:TF_TensorPtr; const I_multiples:TF_TensorPtr; const D_input:boolean=false; const D_multiples:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tmultiples:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tmultiples:=TF_TensorType(I_multiples);
  result:=ExecOper('Tile',[I_input,I_multiples],['T','Tmultiples'],['type','type'],[@F_T,@F_Tmultiples],[D_input,D_multiples])
  end;
function ExecTileGrad(const I_input:TF_TensorPtr; const I_multiples:TF_TensorPtr; const D_input:boolean=false; const D_multiples:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('TileGrad',[I_input,I_multiples],['T'],['type'],[@F_T],[D_input,D_multiples])
  end;
function ExecTranspose(const I_x:TF_TensorPtr; const I_perm:TF_TensorPtr; const D_x:boolean=false; const D_perm:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tperm:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  F_Tperm:=TF_TensorType(I_perm);
  result:=ExecOper('Transpose',[I_x,I_perm],['T','Tperm'],['type','type'],[@F_T,@F_Tperm],[D_x,D_perm])
  end;
function ExecTruncateDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('TruncateDiv',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecTruncateMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('TruncateMod',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecTruncatedNormal(const I_shape:TF_TensorPtr; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('TruncatedNormal',[I_shape],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@F_T],[D_shape])
  end;
function ExecUnsortedSegmentMax(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('UnsortedSegmentMax',[I_data,I_segment_ids,I_num_segments],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids,D_num_segments])
  end;
function ExecUnsortedSegmentSum(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('UnsortedSegmentSum',[I_data,I_segment_ids,I_num_segments],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids,D_num_segments])
  end;
function ExecVariable(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('Variable',[],['shape','dtype','container','shared_name'],['shape','type','string','string'],[@A_shape,@A_dtype,@A_container,@A_shared_name],[])
  end;
function ExecVariableV2(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('VariableV2',[],['shape','dtype','container','shared_name'],['shape','type','string','string'],[@A_shape,@A_dtype,@A_container,@A_shared_name],[])
  end;
function ExecWhere(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('Where',[I_input],[],[],[],[D_input])
  end;
function ExecWholeFileReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('WholeFileReader',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecWholeFileReaderV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('WholeFileReaderV2',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecZerosLike(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('ZerosLike',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecZeta(const I_x:TF_TensorPtr; const I_q:TF_TensorPtr; const D_x:boolean=false; const D_q:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Zeta',[I_x,I_q],['T'],['type'],[@F_T],[D_x,D_q])
  end;

end.

