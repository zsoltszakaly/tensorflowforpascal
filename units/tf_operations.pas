unit tf_operations;

//**********************************************************************************************************************************
//
//  Pascal methods to create and manage TensorFlow based Operations
//
//  Copyright: (C) 2020-2023, Zsolt Szakaly
//
//  This source is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
//  published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
//
//  This code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
//  A copy of the GNU General Public License is available on the World Wide Web at <http://www.gnu.org/copyleft/gpl.html>. You can
//  also obtain it by writing to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1335, USA.
//
//  Change log:
//    13/02/2020 Initial version
//    15/02/2020 TGraph.GetOperationByName added
//               TGraph.AddOper return value change to string, giving back the name of the operation if successful, or '' if not.
//               TGraph.AddConstant added for string type
//               TSession.Run longer version added to run graphs by Operation name as well
//    18/02/2020 TGraph.AddOper changed to handle list attributes correctly
//    21/02/2020 Multiple versions of TSession.Run, ExecOper to cater for various InputList, OutputList scenarios
//               TGraph.AddInputs to handle multiple inputs easier
//               TGraph.AddOper corrections to handle InputLists correctly
//    20/10/2021 Removed types declared unnecessary, like charPtr and replaced it with more standard PChar
//    17/01/2023 Unimportant compiler warnings are "fixed"
//    22/01/2023 AddConstant expanded to handle TF_Bool
//    25/01/2023 The most general AddOper and ExecOper routines are deprecated because they assumed that Inputs are always before
//                 InputLists
//               Many new overload versions of AddOper and ExecOper added
//    31/01/2023 In AddOperation there is no need to name the outputs any more, it is enough to pass on the necessary number of ''
//
//**********************************************************************************************************************************
//
//  Description
//
//  The unit has two parts
//    Graph based operations
//    Direct calls (Eager approach)
//
//  Using the Graph approach (TGraph object), you can easily create a TensorFlow Graph and add Nodes or Operations to it. The
//  Generic method is called AddOper. There are some typical, operation independent nodes, often added to a Graph. To make it easier
//  some convenience functions are also implemented to add constants, inputs, variables and tensors. All "real" operations can be
//  added with AddOper, or you can use tf_wrapper, generated by WrapperMaker automatically from the TensorFlow operation description
//  file. For operation specific methods see the tf_wrapper separately.
//
//  For Eager execution (when no Graph is built, but operations are executed on Tensors immediately), there is ExecOper in this
//  file. ExecOper has two versions, one simplified for those operations that has only Inputs, but NO InputLists, and that has
//  ONE output, and no OutputList. For all more complex operations the longer version of ExecOper can be used. Most of the time, you
//  will not want to use ExecOper, but use operation specific Exec<oper> functions that are in tf_wrapper. One additional feature of
//  ExecOper (and all the Exec<oper> functions as well), that Input Tensors can be deleted immediately at the end of the execution
//  of the operation. This can not only save one extra line in your code (TF_DeleteTensor()), but also allows to create input
//  Tensors in the call itself without risking memory leak. See examples.pas for some more details.
//
//  Many of the TensorFlow operations were tested and OK, but there is no guarantee that complex operations, especially with
//  list() type attributes is working correctly. Recent bugfixes improved it, but still not 100% safe. Be careful!
//
//**********************************************************************************************************************************

interface

uses
  ctypes,                              // Used for typecasts
  SysUtils,                            // Needed for string conversions
  tf_api,                              // The c_api.h interface
  tf_tensors;                          // Basic Tensor handling

// Some extra type definitions on top of what tf_api has
type
  TF_OperOutput=record // A record to identify an Operation Output in the Graph by a name (normally only operations have name)
    FName:string;
    FOutput:TF_Output;
    end;
  TF_OperOutputs=array of TF_OperOutput; // The type to store all the OperOutputs of a Graph

//**********************************************************************************************************************************
//    Graph based operations
//**********************************************************************************************************************************

type
  TGraph=object               // The main Graph Object, including a TF Graph, a TF Status and an Outputs array for easier reference
    public                    // Fields to access through methods
      FGraph:TF_GraphPtr;
      FStatus:TF_StatusPtr;
      FOperOutputs:TF_OperOutputs;
    public                     // The constructor and destructor
      constructor Init;
      destructor  Done; virtual;
    public                     // The generic function to add an Operation to the Graph
      function    AddOper(const AOperationType:string;
                          const AInputs:array of string; const AInputLists:TF_StringLists;
                          const AOutputs:array of string;
                          const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                          const AOperationName:string=''):string; deprecated;
      function    AddOper(const AOperationType:string;
                          const AInputsAndInputLists:array of TF_StringList; const AInputOrInputLists:array of boolean;
                          const AOutputs:array of string;
                          const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                          const AOperationName:string=''):string;
      function    AddOper(const AOperationType:string;
                          const AInputs:array of string;
                          const AOutputs:array of string;
                          const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                          const AOperationName:string=''):string;
      function    AddOper(const AOperationType:string;
                          const AOutputs:array of string;
                          const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                          const AOperationName:string=''):string;
    public                     // Functions to find Output or OutputList based on its name
      function    GetOutputByName(const AName:string):TF_Output;
      function    GetOutputsByName(const ANames:TF_StringList):TF_Outputs;
      function    GetOperationByName(const AName:string):TF_OperationPtr;
    public                     // Convenience functions to add Constants, Inputs, Tensors and Variables to a Graph
      function    AddConstant(const AName:string;const AValue; ADataType:TF_DataType):string;
      function    AddConstant(const AName:string; AValue:boolean):string;
      function    AddConstant(const AName:string; AValue:Int8):string;
      function    AddConstant(const AName:string; AValue:Int16):string;
      function    AddConstant(const AName:string; AValue:Int32):string;
      function    AddConstant(const AName:string; AValue:Int64):string;
      function    AddConstant(const AName:string;AValue:UInt8):string;
      function    AddConstant(const AName:string;AValue:UInt16):string;
      function    AddConstant(const AName:string;AValue:UInt32):string;
      function    AddConstant(const AName:string;AValue:UInt64):string;
      function    AddConstant(const AName:string; AValue:Single):string;
      function    AddConstant(const AName:string; AValue:String):string;
      function    AddInput(const AName:string;  ADataType:TF_DataType):string;
      function    AddInputs(const AName:string; const ACount:Int64; ADataType:TF_DataType):TF_StringList;
      function    AddInputs(const ANames: array of string; ADataType:TF_DataType):TF_StringList;
      function    AddTensor(const AName:string; const ATensor:TF_TensorPtr; ADeleteTensor:boolean=false):string;
      function    AddVar(const AName:string; const AShape:TF_ShapePtr; AType:TF_AttrType):string;
    end;

type
  TSession=object
    private
      FSession:TF_SessionPtr;
      FGraph:TGraph;
      FStatus:TF_StatusPtr;
    public
      constructor Init(const AGraph:TGraph);
      destructor  Done; virtual;
      function    Run(const AOperations:array of string;
                      const AInputs:array of string; const AInputValues:array of TF_TensorPtr;
                      const AOutputs:array of string):TF_TensorPtrs; // Multiple outputs with Operations
      function    Run(const AInputs:array of string; const AInputValues:array of TF_TensorPtr;
                      const AOutputs:array of string):TF_TensorPtrs; // Multiple outputs, no Operations
      function    Run(const AOperations:array of string;
                      const AInputs:array of string; const AInputValues:array of TF_TensorPtr;
                      const AOutput:string):TF_TensorPtr; // Single output with Operations
      function    Run(const AInputs:array of string; const AInputValues:array of TF_TensorPtr;
                      const AOutput:string):TF_TensorPtr; // Single output, no Operations
      procedure   Run(const AOperations:array of string;
                      const AInputs:array of string; const AInputValues:array of TF_TensorPtr); // No output with Inputs
      procedure   Run(const AOperations:array of string); // No output, no Inputs
    end;

// *********************************************************************************************************************************
// THE EAGER OPERATION
// *********************************************************************************************************************************

function  ExecOper( // nInput, nInputList, nOutput
                   const AOperationType:string; const AOutputCount:Int64;
                   const AInputTs:array of TF_TensorPtr; const AInputTLists:array of TF_TensorPtrs;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteIs:array of boolean; const ADeleteILs:array of boolean):TF_TensorPtrs; deprecated;
function  ExecOper( // n(Input + InputList), nOutput
                   const AOperationType:string; const AOutputCount:Int64;
                   const AInputTsAndInputTLists:array of TF_TensorPtrs; const AInputTOrInputTLists:array of boolean;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteIAndILs:array of boolean):TF_TensorPtrs;
function  ExecOper( // n(Input + InputList), 1Output
                   const AOperationType:string;
                   const AInputTsAndInputTLists:array of TF_TensorPtrs; const AInputTOrInputTLists:array of boolean;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteIAndILs:array of boolean):TF_TensorPtr;
function  ExecOper( // nInput, 0InputList, nOutput
                   const AOperationType:string; const AOutputCount:Int64;
                   const AInputTs:array of TF_TensorPtr;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteIs:array of boolean):TF_TensorPtrs;
function  ExecOper( // nInput, 0InputList, 1Output
                   const AOperationType:string;
                   const AInputTs:array of TF_TensorPtr;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteIs:array of boolean):TF_TensorPtr;
function  ExecOper( // 1Input, 0InputList, nOutput
                   const AOperationType:string; const AOutputCount:Int64;
                   const AInputT:TF_TensorPtr;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteI:boolean):TF_TensorPtrs;
function  ExecOper( // 1Input, 0InputList, 1Output
                   const AOperationType:string;
                   const AInputT:TF_TensorPtr;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteI:boolean):TF_TensorPtr;
function  ExecOper( // 0Input, 0InputList, nOutput
                   const AOperationType:string; const AOutputCount:Int64;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer):
                   TF_TensorPtrs;
function  ExecOper( // 0Input, 0InputList, 1Output
                   const AOperationType:string;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer):
                   TF_TensorPtr;

implementation

// *********************************************************************************************************************************
// THE GRAPH OPERATIONS
// *********************************************************************************************************************************

constructor TGraph.Init;
  begin
  FGraph:=TF_NewGraph;
  FStatus:=TF_NewStatus;
  SetLength(FOperOutputs,0);
  end;
destructor  TGraph.Done;
  begin
  SetLength(FOperOutputs,0);
  TF_DeleteStatus(FStatus);
  TF_DeleteGraph(FGraph);
  end;
function    TGraph.AddOper(const AOperationType:string;
                           const AInputs:array of string; const AInputLists:TF_StringLists;
                           const AOutputs: array of string;
                           const AAttrNames: array of string; const AAttrTypes: array of string; const AAttrValues: array of pointer;
                           const AOperationName:string=''):string; deprecated;
  // this is a deprecated method, because InputLists follows the Inputs, what is not always the case (only 99%)
  // still for backward compatibility, it is changed to call the "new" version
  var
    InputsAndInputLists:       array of TF_StringList = nil;
    InputOrInputLists:         array of boolean = nil;
    i:                         integer;
  begin
  SetLength(InputsAndInputLists, length(AInputs) + length(AInputLists));
  SetLength(InputOrInputLists, length(AInputs) + length(AInputLists));
  for i := 0 to High(AInputs) do
    begin
    InputsAndInputLists[i] := [AInputs[i]];
    InputOrInputLists[i] := true;
    end;
  for i := 0 to High(AInputLists) do
    begin
    InputsAndInputLists[length(AInputs) + i] := AInputLists[i];
    InputOrInputLists[length(AInputs) + i] := false;
    end;
  result := AddOper(AOperationType, InputsAndInputLists, InputOrInputLists, AOutputs, AAttrNames, AAttrTypes, AAttrValues, AOperationName);
  end;
function    TGraph.AddOper(const AOperationType:string;
                           const AInputsAndInputLists:array of TF_StringList; const AInputOrInputLists:array of boolean;
                           const AOutputs: array of string;
                           const AAttrNames: array of string; const AAttrTypes: array of string; const AAttrValues: array of pointer;
                           const AOperationName:string=''):string;
  var
    OperationDescription:      TF_OperationDescriptionPtr;
    OperationType:             string;
    OperationName:             string;
    AttrName:                  string;
    AttrDims:                  array of cint;
    OffSet:                    Int32;
    Index:                     integer;
    i:                         integer;
    Operation:                 TF_OperationPtr;
    OK:                        boolean;
  begin
  OK:=true;
  OffSet:=Length(FOperOutputs);
  SetLength(FOperOutputs,OffSet+Length(AOutputs));
  OperationType:=AOperationType+#0; // depending on the compiler, string can be null-terminated or not. To be safe, a #0 is added
  if AOperationName<>'' then
    OperationName:=AOperationName
  else
    OperationName:=AOperationType+IntToStr(OffSet);
  OperationDescription:=TF_NewOperation(FGraph, @OperationType[1], @OperationName[1]);
  for Index:=0 to length(AInputsAndInputLists)-1 do
    begin
    if (length(AInputOrInputLists) <= Index) or AInputOrInputLists[Index] then
      begin
      TF_AddInput(OperationDescription,GetOutputByName(AInputsAndInputLists[Index][0]));
      end
    else
      begin
      if Length(TF_StringList(AInputsAndInputLists[Index]))>0 then
        TF_AddInputList(OperationDescription,addr(GetOutputsByName(AInputsAndInputLists[Index])[0]),Length(AInputsAndInputLists[Index]));
      end;
    end;
  for Index:=0 to Length(AAttrNames)-1 do
    begin
    AttrName:=AAttrNames[Index]+#0;
    if AAttrTypes[Index]='bool' then
      begin
      TF_SetAttrBool(OperationDescription,@AttrName[1],char(AAttrValues[Index]^));
      end
    else if AAttrTypes[Index]='float' then
      begin
      TF_SetAttrFloat(OperationDescription,@AttrName[1],cfloat(AAttrValues[Index]^));
      end
    else if AAttrTypes[Index]='func' then
      begin
      TF_SetAttrFuncname(OperationDescription,@AttrName[1],PChar(@string(AAttrValues[Index]^)[1]),length(string(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='int' then
      begin
      TF_SetAttrInt(OperationDescription,@AttrName[1],cint64(AAttrValues[Index]^));
      end
    else if AAttrTypes[Index]='list(float)' then
      begin
      TF_SetAttrFloatList(OperationDescription,@AttrName[1],pcfloat(@TF_FloatList(AAttrValues[Index]^)[0]),Length(TF_FloatList(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='list(func)' then { TODO : There is no dedicated TF_SetAttFuncnameList. Is it OK like this? }
      begin
      TF_SetAttrFuncname(OperationDescription,@AttrName[1],PChar(@TF_FuncnameList(AAttrValues[Index]^)[0]),Length(TF_FuncnameList(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='list(int)' then
      begin
      TF_SetAttrIntList(OperationDescription,@AttrName[1],pcint64(@TF_IntList(AAttrValues[Index]^)[0]),Length(TF_IntList(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='list(shape)' then
      begin
      AttrDims:=nil;
      SetLength(AttrDims,Length(TF_ShapeList(AAttrValues[Index]^)));
      for i:=0 to Length(AttrDims)-1 do
        AttrDims[i]:=Length(TF_ShapeList(AAttrValues[Index]^)[i]);
      TF_SetAttrShapeList(OperationDescription,@AttrName[1],ppcint64(@TF_ShapeList(AAttrValues[Index]^)[0]),
                        pcint(@AttrDims[0]),Length(TF_ShapeList(AAttrValues[Index]^)));
      SetLength(AttrDims,0);
      end
    else if AAttrTypes[Index]='list(string)' then
      begin
      SetLength(AttrDims,Length(TF_StringList(AAttrValues[Index]^)));
      for i:=0 to Length(AttrDims)-1 do
        AttrDims[i]:=Length(TF_StringList(AAttrValues[Index]^)[i]);
      TF_SetAttrStringList(OperationDescription,@AttrName[1],ppointer(@TF_StringList(AAttrValues[Index]^)[0]),
                           pcsize_t(@AttrDims[0]),Length(TF_StringList(AAttrValues[Index]^)));
      SetLength(AttrDims,0);
      end
    else if AAttrTypes[Index]='list(type)' then
      begin
      TF_SetAttrTypeList(OperationDescription,@AttrName[1],addr(TF_TypeList(AAttrValues[Index]^)[0]),Length(TF_TypeList(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='shape' then
      begin
      TF_SetAttrShape(OperationDescription,@AttrName[1],pcint64(@(TF_ShapePtr(AAttrValues[Index])^[0])),Length(TF_ShapePtr(AAttrValues[Index])^));
      end
    else if AAttrTypes[Index]='string' then
      begin
      TF_SetAttrString(OperationDescription,@AttrName[1],pointer(@(string(AAttrValues[Index]^)[1])),Length(string(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='tensor' then
      begin
      TF_SetAttrTensor(OperationDescription,@AttrName[1],TF_TensorPtr(AAttrValues[Index]^),FStatus);
      OK:=OK and TF_CheckStatus(FStatus);
      end
    else if AAttrTypes[Index]='type' then
      begin
      TF_SetAttrType(OperationDescription,@AttrName[1],TF_DataType(AAttrValues[Index]^));
      end
    else writeln('Unknown parameter type '+AAttrTypes[Index]);
    end;
  Operation:=TF_FinishOperation(OperationDescription,FStatus);
  OK:=OK and TF_CheckStatus(FStatus);
  for Index := 0 to High(AOutputs) do // if there are outputs, they are registered in TGraph for immediate usability later
    with FOperOutputs[OffSet+Index] do
      begin
      FOutput.Oper:=Operation;
      FOutput.Index:=Index;
      if AOutputs[Index] <> '' then
        FName := AOutputs[Index]
      else
        begin
        if High(AOutputs) = 0 then
          FName := OperationName
        else
          FName := OperationName + '_' + IntToStr(Index);
        end;
      end;
  if OK then
    result:=OperationName
  else
    result:='';
  end;
function    TGraph.AddOper(const AOperationType:string;
                           const AInputs:array of string;
                           const AOutputs: array of string;
                           const AAttrNames: array of string; const AAttrTypes: array of string; const AAttrValues: array of pointer;
                           const AOperationName:string=''):string;
  var
    InputsAndInputLists:       array of TF_StringList = nil;
    i:                         integer;
  begin
  // a simplified version, when there are no InputLists then no need to pass them in an array of TF_StringLists
  SetLength(InputsAndInputLists, length(AInputs));
  for i := 0 to High(AInputs) do
    InputsAndInputLists[i] := [AInputs[i]];
  result := AddOper(AOperationType, InputsAndInputLists, [], AOutputs, AAttrNames, AAttrTypes, AAttrValues, AOperationName);
  end;
function    TGraph.AddOper(const AOperationType:string;
                           const AOutputs: array of string;
                           const AAttrNames: array of string; const AAttrTypes: array of string; const AAttrValues: array of pointer;
                           const AOperationName:string=''):string;
  begin
  // an even more simplified version, when there are no Input at all
  result := AddOper(AOperationType, [], [], AOutputs, AAttrNames, AAttrTypes, AAttrValues, AOperationName);
  end;

function    TGraph.GetOutputByName(const AName:string):TF_Output;
  var i:integer;
  begin
  i:=0;
  while i<=length(FOperOutputs) do
    begin
    if FOperOutputs[i].FName=AName then
      begin
      result:=FOperOutputs[i].FOutput;
      exit;
      end;
    inc(i);
    end;
  writeln('Error, Output not found');
  end;
function    TGraph.GetOutputsByName(const ANames:TF_StringList):TF_Outputs;
  var
    i:integer;
  begin
  result:=nil;
  SetLength(result,Length(ANames));
  for i:=0 to Length(ANames)-1 do
    result[i]:=GetOutputByName(ANames[i]);
  end;
function    TGraph.GetOperationByName(const AName:string):TF_OperationPtr;
  var Name:string;
  begin
  Name:=AName+#0;
  result:=TF_GraphOperationByName(FGraph,@Name[1]);
  end;

function    TGraph.AddConstant(const AName:string;const AValue; ADataType:TF_DataType):string;
  var
    ConstantT:TF_TensorPtr;
  begin
  case ADataType of
    TF_BOOL:ConstantT:=CreateTensorBool(boolean(AValue));
    TF_INT8:ConstantT:=CreateTensorInt8(Int8(AValue));
    TF_INT16:ConstantT:=CreateTensorInt16(Int16(AValue));
    TF_INT32:ConstantT:=CreateTensorInt32(Int32(AValue));
    TF_INT64:ConstantT:=CreateTensorInt64(Int64(AValue));
    TF_UINT8:ConstantT:=CreateTensorUInt8(UInt8(AValue));
    TF_UINT16:ConstantT:=CreateTensorUInt16(UInt16(AValue));
    TF_UINT32:ConstantT:=CreateTensorUInt32(UInt32(AValue));
    TF_UINT64:ConstantT:=CreateTensorUInt64(UInt64(AValue));
    TF_FLOAT:ConstantT:=CreateTensorSingle(Single(AValue));
    TF_STRING:ConstantT:=CreateTensorString(PChar(AValue));
    else
      raise Exception.Create('Data type not implemented');
    end;
  result:=AddOper('Const',[AName],['dtype','value'],['type','tensor'],[@ADataType,@ConstantT]);
  TF_DeleteTensor(ConstantT);
  end;
function    TGraph.AddConstant(const AName:string; AValue:boolean):string;
  begin
  result:=AddConstant(AName,AValue,TF_BOOL);
  end;
function    TGraph.AddConstant(const AName:string; AValue:Int8):string;
  begin
  result:=AddConstant(AName,AValue,TF_INT8);
  end;
function    TGraph.AddConstant(const AName:string; AValue:Int16):string;
  begin
  result:=AddConstant(AName,AValue,TF_INT16);
  end;
function    TGraph.AddConstant(const AName:string; AValue:Int32):string;
  begin
  result:=AddConstant(AName,AValue,TF_INT32);
  end;
function    TGraph.AddConstant(const AName:string; AValue:Int64):string;
  begin
  result:=AddConstant(AName,AValue,TF_INT64);
  end;
function    TGraph.AddConstant(const AName:string; AValue:UInt8):string;
  begin
  result:=AddConstant(AName,AValue,TF_UINT8);
  end;
function    TGraph.AddConstant(const AName:string; AValue:UInt16):string;
  begin
  result:=AddConstant(AName,AValue,TF_UINT16);
  end;
function    TGraph.AddConstant(const AName:string; AValue:UInt32):string;
  begin
  result:=AddConstant(AName,AValue,TF_UINT32);
  end;
function    TGraph.AddConstant(const AName:string; AValue:UInt64):string;
  begin
  result:=AddConstant(AName,AValue,TF_UINT64);
  end;
function    TGraph.AddConstant(const AName:string; AValue:Single):string;
  begin
  result:=AddConstant(AName,AValue,TF_FLOAT);
  end;
function    TGraph.AddConstant(const AName:string; AValue:String):string;
  begin
  result:=AddConstant(AName,AValue,TF_String);
  end;
function    TGraph.AddInput(const AName:string; ADataType:TF_DataType):string;
  begin
  result:=AddOper('Placeholder',[AName],['dtype'],['type'],[@ADataType]);
  end;
function    TGraph.AddInputs(const AName:string; const ACount:Int64; ADataType:TF_DataType):TF_StringList;
  var i:Int64;
  begin
  result:=nil;
  SetLength(result,ACount);
  for i:=0 to ACount-1 do
    result[i]:=AddOper('Placeholder',[AName+'_'+inttostr(i)],['dtype'],['type'],[@ADataType]);
  end;
function    TGraph.AddInputs(const ANames: array of string; ADataType:TF_DataType):TF_StringList;
  var i:Int64;
  begin
  result:=nil;
  SetLength(result,Length(ANames));
  for i:=0 to Length(ANames)-1 do
    result[i]:=AddOper('Placeholder',[ANames[i]],['dtype'],['type'],[@ADataType]);
  end;
function    TGraph.AddTensor(const AName:string; const ATensor:TF_TensorPtr; ADeleteTensor:boolean=false):string;
  var TensorType:TF_DataType;
  begin
  TensorType:=TF_TensorType(ATensor);
  result:=AddOper('Const',[AName],['dtype','value'],['type','tensor'],[@TensorType,@ATensor]);
  if ADeleteTensor then
    TF_DeleteTensor(ATensor);
  end;
function    TGraph.AddVar(const AName:string; const AShape:TF_ShapePtr; AType:TF_AttrType):string;
  begin
  result:=AddOper('Variable',[AName],['dtype','shape'],['type','shape'],[@AType,@AShape]);
  end;

constructor TSession.Init(const AGraph:TGraph);
  var
    SessionOptions:TF_SessionOptionsPtr;
  begin
  FGraph:=AGraph;
  FStatus:=FGraph.FStatus;
  SessionOptions:=TF_NewSessionOptions;
  FSession:=TF_NewSession(FGraph.FGraph,SessionOptions,FStatus); // using the GGraph and the Options created earlier
  TF_CheckStatus(AGraph.FStatus);
  TF_DeleteSessionOptions(SessionOptions);
  end;
destructor  TSession.Done;
  begin
  TF_CloseSession(FSession,FStatus);
  TF_CheckStatus(FStatus);
  TF_DeleteSession(FSession,FStatus);
  TF_CheckStatus(FStatus);
  end;
function    TSession.Run(const AOperations:array of string;
                         const AInputs:array of string; const AInputValues:array of TF_TensorPtr;
                         const AOutputs:array of string):TF_TensorPtrs;
  var
    InputOperations:array of TF_Output=nil;
    OutputOperations:array of TF_Output=nil;
    ExecuteOperations:array of TF_OperationPtr=nil;
    i:integer;
  begin
  SetLength(InputOperations,length(AInputs));
  for i:=0 to Length(AInputs)-1 do
    InputOperations[i]:=FGraph.GetOutputByName(AInputs[i]);
  SetLength(OutputOperations,length(AOutputs));
  for i:=0 to Length(AOutputs)-1 do
    OutputOperations[i]:=FGraph.GetOutputByName(AOutputs[i]);
  result:=nil;
  SetLength(result,Length(OutputOperations));
  SetLength(ExecuteOperations,length(AOperations));
  for i:=0 to Length(AOperations)-1 do
    ExecuteOperations[i]:=FGraph.GetOperationByName(AOperations[i]);
  TF_SessionRun(FSession, nil,
                @InputOperations[0],@AInputValues[0],Length(InputOperations),
                @OutputOperations[0],@result[0],Length(OutputOperations),
                @ExecuteOperations[0],Length(ExecuteOperations),
                nil, FStatus);
  TF_CheckStatus(FStatus);
  end;
function    TSession.Run(const AInputs:array of string; const AInputValues:array of TF_TensorPtr;
                         const AOutputs:array of string):TF_TensorPtrs;
  begin
  result:=Run([],AInputs,AInputValues,AOutputs);
  end;
function    TSession.Run(const AOperations:array of string;
                         const AInputs:array of string; const AInputValues:array of TF_TensorPtr;
                         const AOutput:string):TF_TensorPtr; // Single output with Operations
  begin
  result:=Run(AOperations,AInputs,AInputValues,[AOutput])[0];
  end;
function    TSession.Run(const AInputs:array of string; const AInputValues:array of TF_TensorPtr;
                         const AOutput:string):TF_TensorPtr;
  begin
  result:=Run([],AInputs,AInputValues,[AOutput])[0];
  end;
procedure   TSession.Run(const AOperations:array of string; const AInputs:array of string;
                         const AInputValues:array of TF_TensorPtr);
  begin
  Run(AOperations,AInputs,AInputValues,[]);
  end;
procedure   TSession.Run(const AOperations:array of string);
  begin
  Run(AOperations,[],[],[]);
  end;

// *********************************************************************************************************************************
// THE EAGER OPERATION
// *********************************************************************************************************************************

function  ExecOper( // nInput, nInputList, nOutput
                  const AOperationType:string; const AOutputCount:Int64;
                  const AInputTs:array of TF_TensorPtr; const AInputTLists:array of TF_TensorPtrs;
                  const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                  const ADeleteIs:array of boolean; const ADeleteILs:array of boolean):TF_TensorPtrs; deprecated;
  // this is a deprecated function, because InputLists follows the Inputs, what is not always the case (only 99%)
  // still for backward compatibility, it is changed to call the "new" version
  var
    InputTsAndInputTLists:     array of TF_TensorPtrs = nil;
    InputTOrInputTLists:       array of boolean = nil;
    DeleteIAndILs:             array of boolean = nil;
    i:                         integer;
  begin
  SetLength(InputTsAndInputTLists, length(AInputTs) + length(AInputTLists));
  SetLength(InputTOrInputTLists, length(AInputTs) + length(AInputTLists));
  SetLength(DeleteIAndILs, length(AInputTs) + length(AInputTLists));
  for i := 0 to High(AInputTs) do
    begin
    InputTsAndInputTLists[i] := [AInputTs[i]];
    InputTOrInputTLists[i] := true;
    DeleteIAndILs[i] := ADeleteIs[i];
    end;
  for i := 0 to High(AInputTLists) do
    begin
    InputTsAndInputTLists[length(AInputTs) + i] := AInputTLists[i];
    InputTOrInputTLists[length(AInputTs) + i] := false;
    DeleteIAndILs[length(AInputTs) + i] := ADeleteILs[i];
    end;
  result := ExecOper(AOperationType, AOutputCount, InputTsAndInputTLists, InputTOrInputTLists, AAttrNames, AAttrTypes, AAttrValues,
                     DeleteIAndILs);
  end;
function  ExecOper( // n(Input + InputList), nOutput
                  const AOperationType:string; const AOutputCount:Int64;
                  const AInputTsAndInputTLists:array of TF_TensorPtrs; const AInputTOrInputTLists:array of boolean;
                  const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                  const ADeleteIAndILs:array of boolean):TF_TensorPtrs;
  var
    Graph:TGraph;
    Index1,Index2:integer;
    InputAndInputListNames: array of TF_StringList=nil;
    OutputNames:array of string=nil;
    Session:TSession;
    OperationName:string;
  begin
  Graph.Init;
  SetLength(InputAndInputListNames, Length(AInputTsAndInputTLists));
  for Index1:=0 to Length(AInputTsAndInputTLists)-1 do
    begin
    if (length(AInputTOrInputTLists) <= Index1) or AInputTOrInputTLists[Index1] then
      begin
      InputAndInputListNames[Index1]:=['Input'+IntToStr(Index1)];
      Graph.AddTensor(InputAndInputListNames[Index1][0],AInputTsAndInputTLists[Index1][0],ADeleteIAndILs[Index1]);
      end
    else
      begin
      SetLength(InputAndInputListNames[Index1],Length(AInputTsAndInputTLists[Index1]));
      for Index2:=0 to Length(AInputTsAndInputTLists[Index1])-1 do
        begin
        InputAndInputListNames[Index1,Index2]:='Input'+IntToStr(Index1)+'_'+IntToStr(Index2);
        Graph.AddTensor(InputAndInputListNames[Index1,Index2],AInputTsAndInputTLists[Index1][Index2],ADeleteIAndILs[Index1]);
        end;
      end;
    end;
  SetLength(OutputNames,AOutputCount);
  for Index1:=0 to AOutputCount-1 do
    OutputNames[Index1]:='Output'+IntToStr(Index1);
  OperationName:=Graph.AddOper(AOperationType,
                               InputAndInputListNames,AInputTOrInputTLists,
                               OutputNames,
                               AAttrNames,AAttrTypes,AAttrValues);
  Session.Init(Graph);
  result:=Session.Run([OperationName],[],[],OutputNames);
  Session.Done;
  Graph.Done;
  end;
function  ExecOper( // n(Input + InputList), 1Output
                  const AOperationType:string;
                  const AInputTsAndInputTLists:array of TF_TensorPtrs; const AInputTOrInputTLists:array of boolean;
                  const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                  const ADeleteIAndILs:array of boolean):TF_TensorPtr;
  begin
  result := ExecOper(AOperationType,1,AInputTsAndInputTLists, AInputTOrInputTLists, AAttrnames, AAttrTypes, AattrValues, ADeleteIAndILs)[0];
  end;
function  ExecOper( // nInput, 0InputList, nOutput
                   const AOperationType:string; const AOutputCount:Int64;
                   const AInputTs:array of TF_TensorPtr;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteIs:array of boolean):TF_TensorPtrs;
  var
    InputTsAndInputTLists:array of TF_TensorPtrs=nil;
    i : integer;
  begin
  SetLength(InputTsAndInputTLists, length(AInputTs));
  for i := 0 to High(AInputTs) do
    InputTsAndInputTLists[i] := [AInputTs[i]];
  result:=ExecOper(AOperationType,AOutputCount,InputTsAndInputTLists,[],AAttrNames,AAttrTypes,AAttrValues,ADeleteIs);
  end;
function  ExecOper( // nInput, 0InputList, 1Output
                   const AOperationType:string;
                   const AInputTs:array of TF_TensorPtr;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteIs:array of boolean):TF_TensorPtr;
  begin
  result:=ExecOper(AOperationType,1,AInputTs,AAttrNames,AAttrTypes,AAttrValues,ADeleteIs)[0];
  end;
function  ExecOper( // 1Input, 0InputList, nOutput
                   const AOperationType:string; const AOutputCount:Int64;
                   const AInputT:TF_TensorPtr;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteI:boolean):TF_TensorPtrs;
  begin
  result:=ExecOper(AOperationType,AOutputCount,[AInputT],AAttrNames,AAttrTypes,AAttrValues,[ADeleteI]);
  end;
function  ExecOper( // 1Input, 0InputList, 1Output
                   const AOperationType:string;
                   const AInputT:TF_TensorPtr;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                   const ADeleteI:boolean):TF_TensorPtr;
  begin
  result:=ExecOper(AOperationType,[AInputT],AAttrNames,AAttrTypes,AAttrValues,[ADeleteI]);
  end;
function  ExecOper( // 0Input, 0InputList, nOutput
                   const AOperationType:string; const AOutputCount:Int64;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer):
                   TF_TensorPtrs;
  begin
  result:=ExecOper(AOperationType,AOutputCount,[],AAttrNames,AAttrTypes,AAttrValues,[]);
  end;
function  ExecOper( // 0Input, 0InputList, 1Output
                   const AOperationType:string;
                   const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer):
                   TF_TensorPtr;
  begin
  result:=ExecOper(AOperationType,[],AAttrNames,AAttrTypes,AAttrValues,[]);
  end;

end.

